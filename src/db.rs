// Code generated by Prisma Client Rust. DO NOT EDIT

#![allow(warnings, unused)]
pub static DATAMODEL_STR: &'static str =
    include_str!("/d/projects/speedboat-api/prisma/schema.prisma");
static DATABASE_STR: &'static str = "postgresql";
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
    url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder()
        .with_url(url.to_string())
        .build()
        .await
}
pub mod channels {
    use super::_prisma::*;
    use super::*;
    pub mod channel_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i64) -> T {
            UniqueWhereParam::ChannelIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ChannelId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementChannelId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementChannelId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyChannelId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideChannelId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetChannelId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ChannelId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("channel_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ChannelId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("channel_id").build()
            }
        }
    }
    pub mod guild_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i64>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i64>) -> WhereParam {
            WhereParam::GuildIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::GuildId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementGuildId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementGuildId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyGuildId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideGuildId(value)
        }
        pub struct Set(pub Option<i64>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGuildId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GuildId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GuildId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::NameEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetName(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("name").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("name").build()
            }
        }
    }
    pub mod topic {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::TopicEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Topic(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Topic(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Topic(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Topic(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Topic(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Topic(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Topic(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Topic(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Topic(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Topic(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Topic(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Topic(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTopic(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Topic(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("topic").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Topic(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("topic").build()
            }
        }
    }
    pub mod type_ {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::Type_Equals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Type_(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::Type_(_prisma::read_filters::IntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::Type_(_prisma::read_filters::IntFilter::NotInVec(value))
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::Type_(_prisma::read_filters::IntFilter::Lt(value))
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::Type_(_prisma::read_filters::IntFilter::Lte(value))
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::Type_(_prisma::read_filters::IntFilter::Gt(value))
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::Type_(_prisma::read_filters::IntFilter::Gte(value))
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::Type_(_prisma::read_filters::IntFilter::Not(value))
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementType_(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementType_(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyType_(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideType_(value)
        }
        pub struct Set(pub Option<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetType_(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Type_(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("type_").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Type_(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("type_").build()
            }
        }
    }
    pub mod first_message_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i64>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i64>) -> WhereParam {
            WhereParam::FirstMessageIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::FirstMessageId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::FirstMessageId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::FirstMessageId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::FirstMessageId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::FirstMessageId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::FirstMessageId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::FirstMessageId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::FirstMessageId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementFirstMessageId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementFirstMessageId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyFirstMessageId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideFirstMessageId(value)
        }
        pub struct Set(pub Option<i64>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetFirstMessageId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FirstMessageId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("first_message_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FirstMessageId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("first_message_id").build()
            }
        }
    }
    pub mod deleted {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::DeletedEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Deleted(direction)
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDeleted(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Deleted(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("deleted").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Deleted(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("deleted").build()
            }
        }
    }
    pub fn create(
        channel_id: i64,
        deleted: bool,
        _params: Vec<SetParam>,
    ) -> (i64, bool, Vec<SetParam>) {
        (channel_id, deleted, _params)
    }
    pub fn create_unchecked(
        channel_id: i64,
        deleted: bool,
        _params: Vec<SetParam>,
    ) -> (i64, bool, Vec<SetParam>) {
        (channel_id, deleted, _params)
    }
    #[macro_export]
    macro_rules ! _select_channels { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: channels :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: channels :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: channels :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: channels :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: channels :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: channels :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { channel_id , guild_id , name , topic , type_ , first_message_id , deleted } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: channels :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: channels :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: channels :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: channels :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: channels :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: channels :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["channel_id" , "guild_id" , "name" , "topic" , "type_" , "first_message_id" , "deleted"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: channels :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; channel_id) => { i64 } ; (@ field_type ; guild_id) => { Option < i64 > } ; (@ field_type ; name) => { Option < String > } ; (@ field_type ; topic) => { Option < String > } ; (@ field_type ; type_) => { Option < i32 > } ; (@ field_type ; first_message_id) => { Option < i64 > } ; (@ field_type ; deleted) => { bool } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Channels" , available fields are "channel_id, guild_id, name, topic, type_, first_message_id, deleted")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; channel_id) => { Into :: < $ crate :: prisma :: channels :: SelectParam > :: into ($ crate :: prisma :: channels :: channel_id :: Select) } ; (@ selection_field_to_selection_param ; guild_id) => { Into :: < $ crate :: prisma :: channels :: SelectParam > :: into ($ crate :: prisma :: channels :: guild_id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < $ crate :: prisma :: channels :: SelectParam > :: into ($ crate :: prisma :: channels :: name :: Select) } ; (@ selection_field_to_selection_param ; topic) => { Into :: < $ crate :: prisma :: channels :: SelectParam > :: into ($ crate :: prisma :: channels :: topic :: Select) } ; (@ selection_field_to_selection_param ; type_) => { Into :: < $ crate :: prisma :: channels :: SelectParam > :: into ($ crate :: prisma :: channels :: type_ :: Select) } ; (@ selection_field_to_selection_param ; first_message_id) => { Into :: < $ crate :: prisma :: channels :: SelectParam > :: into ($ crate :: prisma :: channels :: first_message_id :: Select) } ; (@ selection_field_to_selection_param ; deleted) => { Into :: < $ crate :: prisma :: channels :: SelectParam > :: into ($ crate :: prisma :: channels :: deleted :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: channels :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; channel_id) => { "channel_id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; topic) => { "topic" } ; (@ field_serde_name ; type_) => { "type_" } ; (@ field_serde_name ; first_message_id) => { "first_message_id" } ; (@ field_serde_name ; deleted) => { "deleted" } ; }
    pub use _select_channels as select;
    pub enum SelectParam {
        ChannelId(channel_id::Select),
        GuildId(guild_id::Select),
        Name(name::Select),
        Topic(topic::Select),
        Type_(type_::Select),
        FirstMessageId(first_message_id::Select),
        Deleted(deleted::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::ChannelId(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Topic(data) => data.to_selection(),
                Self::Type_(data) => data.to_selection(),
                Self::FirstMessageId(data) => data.to_selection(),
                Self::Deleted(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_channels { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: channels :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: channels :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: channels :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: channels :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: channels :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: channels :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: channels :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: channels :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub channel_id : i64 , pub guild_id : Option < i64 > , pub name : Option < String > , pub topic : Option < String > , pub type_ : Option < i32 > , pub first_message_id : Option < i64 > , pub deleted : bool , $ (pub $ field : $ crate :: prisma :: channels :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (channel_id) , stringify ! (guild_id) , stringify ! (name) , stringify ! (topic) , stringify ! (type_) , stringify ! (first_message_id) , stringify ! (deleted)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; channel_id) , & self . channel_id) ? ; state . serialize_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; guild_id) , & self . guild_id) ? ; state . serialize_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; name) , & self . name) ? ; state . serialize_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; topic) , & self . topic) ? ; state . serialize_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; type_) , & self . type_) ? ; state . serialize_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; first_message_id) , & self . first_message_id) ? ; state . serialize_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; deleted) , & self . deleted) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , channel_id , guild_id , name , topic , type_ , first_message_id , deleted } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: channels :: include ! (@ field_serde_name ; channel_id) , ", " , $ crate :: prisma :: channels :: include ! (@ field_serde_name ; guild_id) , ", " , $ crate :: prisma :: channels :: include ! (@ field_serde_name ; name) , ", " , $ crate :: prisma :: channels :: include ! (@ field_serde_name ; topic) , ", " , $ crate :: prisma :: channels :: include ! (@ field_serde_name ; type_) , ", " , $ crate :: prisma :: channels :: include ! (@ field_serde_name ; first_message_id) , ", " , $ crate :: prisma :: channels :: include ! (@ field_serde_name ; deleted) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: channels :: include ! (@ field_serde_name ; channel_id) => Ok (Field :: channel_id) , $ crate :: prisma :: channels :: include ! (@ field_serde_name ; guild_id) => Ok (Field :: guild_id) , $ crate :: prisma :: channels :: include ! (@ field_serde_name ; name) => Ok (Field :: name) , $ crate :: prisma :: channels :: include ! (@ field_serde_name ; topic) => Ok (Field :: topic) , $ crate :: prisma :: channels :: include ! (@ field_serde_name ; type_) => Ok (Field :: type_) , $ crate :: prisma :: channels :: include ! (@ field_serde_name ; first_message_id) => Ok (Field :: first_message_id) , $ crate :: prisma :: channels :: include ! (@ field_serde_name ; deleted) => Ok (Field :: deleted) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut channel_id = None ; let mut guild_id = None ; let mut name = None ; let mut topic = None ; let mut type_ = None ; let mut first_message_id = None ; let mut deleted = None ; while let Some (key) = map . next_key () ? { match key { Field :: channel_id => { if channel_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; channel_id))) ; } channel_id = Some (map . next_value () ?) ; } Field :: guild_id => { if guild_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; guild_id))) ; } guild_id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; name))) ; } name = Some (map . next_value () ?) ; } Field :: topic => { if topic . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; topic))) ; } topic = Some (map . next_value () ?) ; } Field :: type_ => { if type_ . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; type_))) ; } type_ = Some (map . next_value () ?) ; } Field :: first_message_id => { if first_message_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; first_message_id))) ; } first_message_id = Some (map . next_value () ?) ; } Field :: deleted => { if deleted . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; deleted))) ; } deleted = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; $ field))) ? ;) * let channel_id = channel_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; channel_id))) ? ; let guild_id = guild_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; guild_id))) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; name))) ? ; let topic = topic . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; topic))) ? ; let type_ = type_ . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; type_))) ? ; let first_message_id = first_message_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; first_message_id))) ? ; let deleted = deleted . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: channels :: include ! (@ field_serde_name ; deleted))) ? ; Ok (Data { channel_id , guild_id , name , topic , type_ , first_message_id , deleted , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["channel_id" , "guild_id" , "name" , "topic" , "type_" , "first_message_id" , "deleted"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: channels :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Channels" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: channels :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; channel_id) => { "channel_id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; topic) => { "topic" } ; (@ field_serde_name ; type_) => { "type_" } ; (@ field_serde_name ; first_message_id) => { "first_message_id" } ; (@ field_serde_name ; deleted) => { "deleted" } ; }
    pub use _include_channels as include;
    pub enum IncludeParam {
        ChannelId(channel_id::Include),
        GuildId(guild_id::Include),
        Name(name::Include),
        Topic(topic::Include),
        Type_(type_::Include),
        FirstMessageId(first_message_id::Include),
        Deleted(deleted::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::ChannelId(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Topic(data) => data.to_selection(),
                Self::Type_(data) => data.to_selection(),
                Self::FirstMessageId(data) => data.to_selection(),
                Self::Deleted(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "channel_id")]
        pub channel_id: i64,
        #[serde(rename = "guild_id")]
        pub guild_id: Option<i64>,
        #[serde(rename = "name")]
        pub name: Option<String>,
        #[serde(rename = "topic")]
        pub topic: Option<String>,
        #[serde(rename = "type_")]
        pub type_: Option<i32>,
        #[serde(rename = "first_message_id")]
        pub first_message_id: Option<i64>,
        #[serde(rename = "deleted")]
        pub deleted: bool,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetChannelId(i64),
        IncrementChannelId(i64),
        DecrementChannelId(i64),
        MultiplyChannelId(i64),
        DivideChannelId(i64),
        SetGuildId(Option<i64>),
        IncrementGuildId(i64),
        DecrementGuildId(i64),
        MultiplyGuildId(i64),
        DivideGuildId(i64),
        SetName(Option<String>),
        SetTopic(Option<String>),
        SetType_(Option<i32>),
        IncrementType_(i32),
        DecrementType_(i32),
        MultiplyType_(i32),
        DivideType_(i32),
        SetFirstMessageId(Option<i64>),
        IncrementFirstMessageId(i64),
        DecrementFirstMessageId(i64),
        MultiplyFirstMessageId(i64),
        DivideFirstMessageId(i64),
        SetDeleted(bool),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetChannelId(value) => (
                    "channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementChannelId(value) => (
                    "channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementChannelId(value) => (
                    "channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyChannelId(value) => (
                    "channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideChannelId(value) => (
                    "channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetGuildId(value) => (
                    "guild_id".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetName(value) => (
                    "name".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetTopic(value) => (
                    "topic".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetType_(value) => (
                    "type_".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementType_(value) => (
                    "type_".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementType_(value) => (
                    "type_".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyType_(value) => (
                    "type_".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideType_(value) => (
                    "type_".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetFirstMessageId(value) => (
                    "first_message_id".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementFirstMessageId(value) => (
                    "first_message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementFirstMessageId(value) => (
                    "first_message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyFirstMessageId(value) => (
                    "first_message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideFirstMessageId(value) => (
                    "first_message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetDeleted(value) => (
                    "deleted".to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        ChannelId(::prisma_client_rust::Direction),
        GuildId(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        Topic(::prisma_client_rust::Direction),
        Type_(::prisma_client_rust::Direction),
        FirstMessageId(::prisma_client_rust::Direction),
        Deleted(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::ChannelId(direction) => (
                    "channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::GuildId(direction) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    "name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Topic(direction) => (
                    "topic".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Type_(direction) => (
                    "type_".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::FirstMessageId(direction) => (
                    "first_message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Deleted(direction) => (
                    "deleted".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        ChannelIdEquals(i64),
        ChannelId(_prisma::read_filters::BigIntFilter),
        GuildIdEquals(Option<i64>),
        GuildId(_prisma::read_filters::BigIntFilter),
        NameEquals(Option<String>),
        Name(_prisma::read_filters::StringFilter),
        TopicEquals(Option<String>),
        Topic(_prisma::read_filters::StringFilter),
        Type_Equals(Option<i32>),
        Type_(_prisma::read_filters::IntFilter),
        FirstMessageIdEquals(Option<i64>),
        FirstMessageId(_prisma::read_filters::BigIntFilter),
        DeletedEquals(bool),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::ChannelIdEquals(value) => (
                    "channel_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::ChannelId(value) => ("channel_id", value.into()),
                Self::GuildIdEquals(value) => (
                    "guild_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::GuildId(value) => ("guild_id", value.into()),
                Self::NameEquals(value) => (
                    "name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::Name(value) => ("name", value.into()),
                Self::TopicEquals(value) => (
                    "topic",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::Topic(value) => ("topic", value.into()),
                Self::Type_Equals(value) => (
                    "type_",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::Type_(value) => ("type_", value.into()),
                Self::FirstMessageIdEquals(value) => (
                    "first_message_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::FirstMessageId(value) => ("first_message_id", value.into()),
                Self::DeletedEquals(value) => (
                    "deleted",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        ChannelIdEquals(i64),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::ChannelIdEquals(value) => Self::ChannelIdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "Channels";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            [
                "channel_id",
                "guild_id",
                "name",
                "topic",
                "type_",
                "first_message_id",
                "deleted",
            ]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            channel_id: i64,
            deleted: bool,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(channel_id::set(channel_id));
            _params.push(deleted::set(deleted));
            Create::new(self.client, _params)
        }
        pub fn create_many(self, data: Vec<(i64, bool, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(channel_id, deleted, mut _params)| {
                    _params.push(channel_id::set(channel_id));
                    _params.push(deleted::set(deleted));
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (channel_id, deleted, mut _params): (i64, bool, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(channel_id::set(channel_id));
            _params.push(deleted::set(deleted));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod commands {
    use super::_prisma::*;
    use super::*;
    pub mod message_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i64) -> T {
            UniqueWhereParam::MessageIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::MessageId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementMessageId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementMessageId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyMessageId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideMessageId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetMessageId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MessageId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("message_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MessageId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("message_id").build()
            }
        }
    }
    pub mod plugin {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::PluginEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Plugin(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Plugin(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Plugin(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Plugin(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Plugin(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Plugin(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Plugin(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Plugin(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Plugin(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Plugin(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Plugin(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Plugin(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPlugin(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Plugin(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("plugin").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Plugin(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("plugin").build()
            }
        }
    }
    pub mod command {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::CommandEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Command(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCommand(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Command(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("command").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Command(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("command").build()
            }
        }
    }
    pub mod version {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::VersionEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Version(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Version(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Version(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Version(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Version(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Version(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Version(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Version(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Version(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Version(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Version(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Version(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetVersion(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Version(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("version").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Version(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("version").build()
            }
        }
    }
    pub mod success {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::SuccessEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Success(direction)
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetSuccess(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Success(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("success").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Success(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("success").build()
            }
        }
    }
    pub mod traceback {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::TracebackEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Traceback(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Traceback(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Traceback(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Traceback(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Traceback(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Traceback(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Traceback(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Traceback(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Traceback(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Traceback(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Traceback(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Traceback(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTraceback(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Traceback(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("traceback").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Traceback(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("traceback").build()
            }
        }
    }
    pub fn create(
        message_id: i64,
        plugin: String,
        command: String,
        version: String,
        success: bool,
        _params: Vec<SetParam>,
    ) -> (i64, String, String, String, bool, Vec<SetParam>) {
        (message_id, plugin, command, version, success, _params)
    }
    pub fn create_unchecked(
        message_id: i64,
        plugin: String,
        command: String,
        version: String,
        success: bool,
        _params: Vec<SetParam>,
    ) -> (i64, String, String, String, bool, Vec<SetParam>) {
        (message_id, plugin, command, version, success, _params)
    }
    #[macro_export]
    macro_rules ! _select_commands { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: commands :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: commands :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: commands :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: commands :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: commands :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: commands :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { message_id , plugin , command , version , success , traceback } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: commands :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: commands :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: commands :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: commands :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: commands :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: commands :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["message_id" , "plugin" , "command" , "version" , "success" , "traceback"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: commands :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; message_id) => { i64 } ; (@ field_type ; plugin) => { String } ; (@ field_type ; command) => { String } ; (@ field_type ; version) => { String } ; (@ field_type ; success) => { bool } ; (@ field_type ; traceback) => { Option < String > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Commands" , available fields are "message_id, plugin, command, version, success, traceback")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; message_id) => { Into :: < $ crate :: prisma :: commands :: SelectParam > :: into ($ crate :: prisma :: commands :: message_id :: Select) } ; (@ selection_field_to_selection_param ; plugin) => { Into :: < $ crate :: prisma :: commands :: SelectParam > :: into ($ crate :: prisma :: commands :: plugin :: Select) } ; (@ selection_field_to_selection_param ; command) => { Into :: < $ crate :: prisma :: commands :: SelectParam > :: into ($ crate :: prisma :: commands :: command :: Select) } ; (@ selection_field_to_selection_param ; version) => { Into :: < $ crate :: prisma :: commands :: SelectParam > :: into ($ crate :: prisma :: commands :: version :: Select) } ; (@ selection_field_to_selection_param ; success) => { Into :: < $ crate :: prisma :: commands :: SelectParam > :: into ($ crate :: prisma :: commands :: success :: Select) } ; (@ selection_field_to_selection_param ; traceback) => { Into :: < $ crate :: prisma :: commands :: SelectParam > :: into ($ crate :: prisma :: commands :: traceback :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: commands :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; message_id) => { "message_id" } ; (@ field_serde_name ; plugin) => { "plugin" } ; (@ field_serde_name ; command) => { "command" } ; (@ field_serde_name ; version) => { "version" } ; (@ field_serde_name ; success) => { "success" } ; (@ field_serde_name ; traceback) => { "traceback" } ; }
    pub use _select_commands as select;
    pub enum SelectParam {
        MessageId(message_id::Select),
        Plugin(plugin::Select),
        Command(command::Select),
        Version(version::Select),
        Success(success::Select),
        Traceback(traceback::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::MessageId(data) => data.to_selection(),
                Self::Plugin(data) => data.to_selection(),
                Self::Command(data) => data.to_selection(),
                Self::Version(data) => data.to_selection(),
                Self::Success(data) => data.to_selection(),
                Self::Traceback(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_commands { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: commands :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: commands :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: commands :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: commands :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: commands :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: commands :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: commands :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: commands :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub message_id : i64 , pub plugin : String , pub command : String , pub version : String , pub success : bool , pub traceback : Option < String > , $ (pub $ field : $ crate :: prisma :: commands :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (message_id) , stringify ! (plugin) , stringify ! (command) , stringify ! (version) , stringify ! (success) , stringify ! (traceback)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; message_id) , & self . message_id) ? ; state . serialize_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; plugin) , & self . plugin) ? ; state . serialize_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; command) , & self . command) ? ; state . serialize_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; version) , & self . version) ? ; state . serialize_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; success) , & self . success) ? ; state . serialize_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; traceback) , & self . traceback) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , message_id , plugin , command , version , success , traceback } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: commands :: include ! (@ field_serde_name ; message_id) , ", " , $ crate :: prisma :: commands :: include ! (@ field_serde_name ; plugin) , ", " , $ crate :: prisma :: commands :: include ! (@ field_serde_name ; command) , ", " , $ crate :: prisma :: commands :: include ! (@ field_serde_name ; version) , ", " , $ crate :: prisma :: commands :: include ! (@ field_serde_name ; success) , ", " , $ crate :: prisma :: commands :: include ! (@ field_serde_name ; traceback) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: commands :: include ! (@ field_serde_name ; message_id) => Ok (Field :: message_id) , $ crate :: prisma :: commands :: include ! (@ field_serde_name ; plugin) => Ok (Field :: plugin) , $ crate :: prisma :: commands :: include ! (@ field_serde_name ; command) => Ok (Field :: command) , $ crate :: prisma :: commands :: include ! (@ field_serde_name ; version) => Ok (Field :: version) , $ crate :: prisma :: commands :: include ! (@ field_serde_name ; success) => Ok (Field :: success) , $ crate :: prisma :: commands :: include ! (@ field_serde_name ; traceback) => Ok (Field :: traceback) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut message_id = None ; let mut plugin = None ; let mut command = None ; let mut version = None ; let mut success = None ; let mut traceback = None ; while let Some (key) = map . next_key () ? { match key { Field :: message_id => { if message_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; message_id))) ; } message_id = Some (map . next_value () ?) ; } Field :: plugin => { if plugin . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; plugin))) ; } plugin = Some (map . next_value () ?) ; } Field :: command => { if command . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; command))) ; } command = Some (map . next_value () ?) ; } Field :: version => { if version . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; version))) ; } version = Some (map . next_value () ?) ; } Field :: success => { if success . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; success))) ; } success = Some (map . next_value () ?) ; } Field :: traceback => { if traceback . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; traceback))) ; } traceback = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; $ field))) ? ;) * let message_id = message_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; message_id))) ? ; let plugin = plugin . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; plugin))) ? ; let command = command . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; command))) ? ; let version = version . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; version))) ? ; let success = success . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; success))) ? ; let traceback = traceback . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: commands :: include ! (@ field_serde_name ; traceback))) ? ; Ok (Data { message_id , plugin , command , version , success , traceback , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["message_id" , "plugin" , "command" , "version" , "success" , "traceback"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: commands :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Commands" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: commands :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; message_id) => { "message_id" } ; (@ field_serde_name ; plugin) => { "plugin" } ; (@ field_serde_name ; command) => { "command" } ; (@ field_serde_name ; version) => { "version" } ; (@ field_serde_name ; success) => { "success" } ; (@ field_serde_name ; traceback) => { "traceback" } ; }
    pub use _include_commands as include;
    pub enum IncludeParam {
        MessageId(message_id::Include),
        Plugin(plugin::Include),
        Command(command::Include),
        Version(version::Include),
        Success(success::Include),
        Traceback(traceback::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::MessageId(data) => data.to_selection(),
                Self::Plugin(data) => data.to_selection(),
                Self::Command(data) => data.to_selection(),
                Self::Version(data) => data.to_selection(),
                Self::Success(data) => data.to_selection(),
                Self::Traceback(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "message_id")]
        pub message_id: i64,
        #[serde(rename = "plugin")]
        pub plugin: String,
        #[serde(rename = "command")]
        pub command: String,
        #[serde(rename = "version")]
        pub version: String,
        #[serde(rename = "success")]
        pub success: bool,
        #[serde(rename = "traceback")]
        pub traceback: Option<String>,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetMessageId(i64),
        IncrementMessageId(i64),
        DecrementMessageId(i64),
        MultiplyMessageId(i64),
        DivideMessageId(i64),
        SetPlugin(String),
        SetCommand(String),
        SetVersion(String),
        SetSuccess(bool),
        SetTraceback(Option<String>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetMessageId(value) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementMessageId(value) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementMessageId(value) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyMessageId(value) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideMessageId(value) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetPlugin(value) => (
                    "plugin".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetCommand(value) => (
                    "command".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetVersion(value) => (
                    "version".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetSuccess(value) => (
                    "success".to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetTraceback(value) => (
                    "traceback".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        MessageId(::prisma_client_rust::Direction),
        Plugin(::prisma_client_rust::Direction),
        Command(::prisma_client_rust::Direction),
        Version(::prisma_client_rust::Direction),
        Success(::prisma_client_rust::Direction),
        Traceback(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::MessageId(direction) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Plugin(direction) => (
                    "plugin".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Command(direction) => (
                    "command".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Version(direction) => (
                    "version".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Success(direction) => (
                    "success".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Traceback(direction) => (
                    "traceback".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        MessageIdEquals(i64),
        MessageId(_prisma::read_filters::BigIntFilter),
        PluginEquals(String),
        Plugin(_prisma::read_filters::StringFilter),
        CommandEquals(String),
        Command(_prisma::read_filters::StringFilter),
        VersionEquals(String),
        Version(_prisma::read_filters::StringFilter),
        SuccessEquals(bool),
        TracebackEquals(Option<String>),
        Traceback(_prisma::read_filters::StringFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::MessageIdEquals(value) => (
                    "message_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::MessageId(value) => ("message_id", value.into()),
                Self::PluginEquals(value) => (
                    "plugin",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::Plugin(value) => ("plugin", value.into()),
                Self::CommandEquals(value) => (
                    "command",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::Command(value) => ("command", value.into()),
                Self::VersionEquals(value) => (
                    "version",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::Version(value) => ("version", value.into()),
                Self::SuccessEquals(value) => (
                    "success",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                ),
                Self::TracebackEquals(value) => (
                    "traceback",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::Traceback(value) => ("traceback", value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        MessageIdEquals(i64),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::MessageIdEquals(value) => Self::MessageIdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "Commands";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            [
                "message_id",
                "plugin",
                "command",
                "version",
                "success",
                "traceback",
            ]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            message_id: i64,
            plugin: String,
            command: String,
            version: String,
            success: bool,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(message_id::set(message_id));
            _params.push(plugin::set(plugin));
            _params.push(command::set(command));
            _params.push(version::set(version));
            _params.push(success::set(success));
            Create::new(self.client, _params)
        }
        pub fn create_many(
            self,
            data: Vec<(i64, String, String, String, bool, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(message_id, plugin, command, version, success, mut _params)| {
                        _params.push(message_id::set(message_id));
                        _params.push(plugin::set(plugin));
                        _params.push(command::set(command));
                        _params.push(version::set(version));
                        _params.push(success::set(success));
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (message_id, plugin, command, version, success, mut _params): (
                i64,
                String,
                String,
                String,
                bool,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(message_id::set(message_id));
            _params.push(plugin::set(plugin));
            _params.push(command::set(command));
            _params.push(version::set(version));
            _params.push(success::set(success));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod events {
    use super::_prisma::*;
    use super::*;
    pub mod session {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::SessionEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Session(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Session(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Session(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Session(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Session(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Session(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Session(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Session(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Session(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Session(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Session(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Session(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetSession(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Session(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("session").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Session(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("session").build()
            }
        }
    }
    pub mod seq {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::SeqEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Seq(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::Seq(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::Seq(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::Seq(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::Seq(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::Seq(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::Seq(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::Seq(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementSeq(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementSeq(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplySeq(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideSeq(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetSeq(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Seq(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("seq").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Seq(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("seq").build()
            }
        }
    }
    pub mod timestamp {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::TimestampEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Timestamp(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::Timestamp(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::Timestamp(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Timestamp(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Timestamp(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Timestamp(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Timestamp(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Timestamp(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTimestamp(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Timestamp(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("timestamp").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Timestamp(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("timestamp").build()
            }
        }
    }
    pub mod event {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::EventEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Event(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Event(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Event(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Event(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Event(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Event(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Event(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Event(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Event(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Event(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Event(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Event(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEvent(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Event(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("event").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Event(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("event").build()
            }
        }
    }
    pub mod data {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: ::prisma_client_rust::serde_json::Value) -> T {
            Set(value).into()
        }
        pub fn equals(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::DataEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Data(direction)
        }
        pub fn path(value: Vec<String>) -> WhereParam {
            WhereParam::Data(_prisma::read_filters::JsonFilter::Path(value))
        }
        pub fn string_contains(value: String) -> WhereParam {
            WhereParam::Data(_prisma::read_filters::JsonFilter::StringContains(value))
        }
        pub fn string_starts_with(value: String) -> WhereParam {
            WhereParam::Data(_prisma::read_filters::JsonFilter::StringStartsWith(value))
        }
        pub fn string_ends_with(value: String) -> WhereParam {
            WhereParam::Data(_prisma::read_filters::JsonFilter::StringEndsWith(value))
        }
        pub fn array_contains(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Data(_prisma::read_filters::JsonFilter::ArrayContains(value))
        }
        pub fn array_starts_with(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Data(_prisma::read_filters::JsonFilter::ArrayStartsWith(value))
        }
        pub fn array_ends_with(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Data(_prisma::read_filters::JsonFilter::ArrayEndsWith(value))
        }
        pub fn lt(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Data(_prisma::read_filters::JsonFilter::Lt(value))
        }
        pub fn lte(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Data(_prisma::read_filters::JsonFilter::Lte(value))
        }
        pub fn gt(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Data(_prisma::read_filters::JsonFilter::Gt(value))
        }
        pub fn gte(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Data(_prisma::read_filters::JsonFilter::Gte(value))
        }
        pub fn not(value: JsonNullValueFilter) -> WhereParam {
            WhereParam::Data(_prisma::read_filters::JsonFilter::Not(value))
        }
        pub struct Set(pub ::prisma_client_rust::serde_json::Value);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetData(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Data(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("data").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Data(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("data").build()
            }
        }
    }
    pub fn session_seq<T: From<UniqueWhereParam>>(session: String, seq: i64) -> T {
        UniqueWhereParam::SessionSeqEquals(session, seq).into()
    }
    pub fn create(
        session: String,
        seq: i64,
        timestamp: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        event: String,
        data: ::prisma_client_rust::serde_json::Value,
        _params: Vec<SetParam>,
    ) -> (
        String,
        i64,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        String,
        ::prisma_client_rust::serde_json::Value,
        Vec<SetParam>,
    ) {
        (session, seq, timestamp, event, data, _params)
    }
    pub fn create_unchecked(
        session: String,
        seq: i64,
        timestamp: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        event: String,
        data: ::prisma_client_rust::serde_json::Value,
        _params: Vec<SetParam>,
    ) -> (
        String,
        i64,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        String,
        ::prisma_client_rust::serde_json::Value,
        Vec<SetParam>,
    ) {
        (session, seq, timestamp, event, data, _params)
    }
    #[macro_export]
    macro_rules ! _select_events { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: events :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: events :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: events :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: events :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: events :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: events :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { session , seq , timestamp , event , data } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: events :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: events :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: events :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: events :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: events :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: events :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["session" , "seq" , "timestamp" , "event" , "data"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: events :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; session) => { String } ; (@ field_type ; seq) => { i64 } ; (@ field_type ; timestamp) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; event) => { String } ; (@ field_type ; data) => { :: prisma_client_rust :: serde_json :: Value } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Events" , available fields are "session, seq, timestamp, event, data")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; session) => { Into :: < $ crate :: prisma :: events :: SelectParam > :: into ($ crate :: prisma :: events :: session :: Select) } ; (@ selection_field_to_selection_param ; seq) => { Into :: < $ crate :: prisma :: events :: SelectParam > :: into ($ crate :: prisma :: events :: seq :: Select) } ; (@ selection_field_to_selection_param ; timestamp) => { Into :: < $ crate :: prisma :: events :: SelectParam > :: into ($ crate :: prisma :: events :: timestamp :: Select) } ; (@ selection_field_to_selection_param ; event) => { Into :: < $ crate :: prisma :: events :: SelectParam > :: into ($ crate :: prisma :: events :: event :: Select) } ; (@ selection_field_to_selection_param ; data) => { Into :: < $ crate :: prisma :: events :: SelectParam > :: into ($ crate :: prisma :: events :: data :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: events :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; session) => { "session" } ; (@ field_serde_name ; seq) => { "seq" } ; (@ field_serde_name ; timestamp) => { "timestamp" } ; (@ field_serde_name ; event) => { "event" } ; (@ field_serde_name ; data) => { "data" } ; }
    pub use _select_events as select;
    pub enum SelectParam {
        Session(session::Select),
        Seq(seq::Select),
        Timestamp(timestamp::Select),
        Event(event::Select),
        Data(data::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Session(data) => data.to_selection(),
                Self::Seq(data) => data.to_selection(),
                Self::Timestamp(data) => data.to_selection(),
                Self::Event(data) => data.to_selection(),
                Self::Data(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_events { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: events :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: events :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: events :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: events :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: events :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: events :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: events :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: events :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub session : String , pub seq : i64 , pub timestamp : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub event : String , pub data : :: prisma_client_rust :: serde_json :: Value , $ (pub $ field : $ crate :: prisma :: events :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (session) , stringify ! (seq) , stringify ! (timestamp) , stringify ! (event) , stringify ! (data)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: events :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: events :: include ! (@ field_serde_name ; session) , & self . session) ? ; state . serialize_field ($ crate :: prisma :: events :: include ! (@ field_serde_name ; seq) , & self . seq) ? ; state . serialize_field ($ crate :: prisma :: events :: include ! (@ field_serde_name ; timestamp) , & self . timestamp) ? ; state . serialize_field ($ crate :: prisma :: events :: include ! (@ field_serde_name ; event) , & self . event) ? ; state . serialize_field ($ crate :: prisma :: events :: include ! (@ field_serde_name ; data) , & self . data) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , session , seq , timestamp , event , data } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: events :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: events :: include ! (@ field_serde_name ; session) , ", " , $ crate :: prisma :: events :: include ! (@ field_serde_name ; seq) , ", " , $ crate :: prisma :: events :: include ! (@ field_serde_name ; timestamp) , ", " , $ crate :: prisma :: events :: include ! (@ field_serde_name ; event) , ", " , $ crate :: prisma :: events :: include ! (@ field_serde_name ; data) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: events :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: events :: include ! (@ field_serde_name ; session) => Ok (Field :: session) , $ crate :: prisma :: events :: include ! (@ field_serde_name ; seq) => Ok (Field :: seq) , $ crate :: prisma :: events :: include ! (@ field_serde_name ; timestamp) => Ok (Field :: timestamp) , $ crate :: prisma :: events :: include ! (@ field_serde_name ; event) => Ok (Field :: event) , $ crate :: prisma :: events :: include ! (@ field_serde_name ; data) => Ok (Field :: data) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut session = None ; let mut seq = None ; let mut timestamp = None ; let mut event = None ; let mut data = None ; while let Some (key) = map . next_key () ? { match key { Field :: session => { if session . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: events :: include ! (@ field_serde_name ; session))) ; } session = Some (map . next_value () ?) ; } Field :: seq => { if seq . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: events :: include ! (@ field_serde_name ; seq))) ; } seq = Some (map . next_value () ?) ; } Field :: timestamp => { if timestamp . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: events :: include ! (@ field_serde_name ; timestamp))) ; } timestamp = Some (map . next_value () ?) ; } Field :: event => { if event . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: events :: include ! (@ field_serde_name ; event))) ; } event = Some (map . next_value () ?) ; } Field :: data => { if data . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: events :: include ! (@ field_serde_name ; data))) ; } data = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: events :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: events :: include ! (@ field_serde_name ; $ field))) ? ;) * let session = session . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: events :: include ! (@ field_serde_name ; session))) ? ; let seq = seq . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: events :: include ! (@ field_serde_name ; seq))) ? ; let timestamp = timestamp . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: events :: include ! (@ field_serde_name ; timestamp))) ? ; let event = event . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: events :: include ! (@ field_serde_name ; event))) ? ; let data = data . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: events :: include ! (@ field_serde_name ; data))) ? ; Ok (Data { session , seq , timestamp , event , data , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["session" , "seq" , "timestamp" , "event" , "data"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: events :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Events" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: events :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; session) => { "session" } ; (@ field_serde_name ; seq) => { "seq" } ; (@ field_serde_name ; timestamp) => { "timestamp" } ; (@ field_serde_name ; event) => { "event" } ; (@ field_serde_name ; data) => { "data" } ; }
    pub use _include_events as include;
    pub enum IncludeParam {
        Session(session::Include),
        Seq(seq::Include),
        Timestamp(timestamp::Include),
        Event(event::Include),
        Data(data::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Session(data) => data.to_selection(),
                Self::Seq(data) => data.to_selection(),
                Self::Timestamp(data) => data.to_selection(),
                Self::Event(data) => data.to_selection(),
                Self::Data(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "session")]
        pub session: String,
        #[serde(rename = "seq")]
        pub seq: i64,
        #[serde(rename = "timestamp")]
        pub timestamp:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "event")]
        pub event: String,
        #[serde(rename = "data")]
        pub data: ::prisma_client_rust::serde_json::Value,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetSession(String),
        SetSeq(i64),
        IncrementSeq(i64),
        DecrementSeq(i64),
        MultiplySeq(i64),
        DivideSeq(i64),
        SetTimestamp(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetEvent(String),
        SetData(::prisma_client_rust::serde_json::Value),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetSession(value) => (
                    "session".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetSeq(value) => (
                    "seq".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementSeq(value) => (
                    "seq".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementSeq(value) => (
                    "seq".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplySeq(value) => (
                    "seq".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideSeq(value) => (
                    "seq".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetTimestamp(value) => (
                    "timestamp".to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetEvent(value) => (
                    "event".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetData(value) => (
                    "data".to_string(),
                    ::prisma_client_rust::PrismaValue::Json(serde_json::to_string(&value).unwrap()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Session(::prisma_client_rust::Direction),
        Seq(::prisma_client_rust::Direction),
        Timestamp(::prisma_client_rust::Direction),
        Event(::prisma_client_rust::Direction),
        Data(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Session(direction) => (
                    "session".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Seq(direction) => (
                    "seq".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Timestamp(direction) => (
                    "timestamp".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Event(direction) => (
                    "event".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Data(direction) => (
                    "data".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        SessionSeqEquals(String, i64),
        SessionEquals(String),
        Session(_prisma::read_filters::StringFilter),
        SeqEquals(i64),
        Seq(_prisma::read_filters::BigIntFilter),
        TimestampEquals(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        Timestamp(_prisma::read_filters::DateTimeFilter),
        EventEquals(String),
        Event(_prisma::read_filters::StringFilter),
        DataEquals(::prisma_client_rust::serde_json::Value),
        Data(_prisma::read_filters::JsonFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::SessionSeqEquals(session, seq) => (
                    "session_seq",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            "session".to_string(),
                            ::prisma_client_rust::PrismaValue::String(session),
                        ),
                        (
                            "seq".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(seq),
                        ),
                    ]),
                ),
                Self::SessionEquals(value) => (
                    "session",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::Session(value) => ("session", value.into()),
                Self::SeqEquals(value) => (
                    "seq",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::Seq(value) => ("seq", value.into()),
                Self::TimestampEquals(value) => (
                    "timestamp",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::Timestamp(value) => ("timestamp", value.into()),
                Self::EventEquals(value) => (
                    "event",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::Event(value) => ("event", value.into()),
                Self::DataEquals(value) => (
                    "data",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Json(
                            serde_json::to_string(&value).unwrap(),
                        ),
                    )]),
                ),
                Self::Data(value) => ("data", value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        SessionSeqEquals(String, i64),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::SessionSeqEquals(session, seq) => {
                    Self::SessionSeqEquals(session, seq)
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "Events";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["session", "seq", "timestamp", "event", "data"]
                .into_iter()
                .map(|o| {
                    let builder = ::prisma_client_rust::Selection::builder(o);
                    builder.build()
                })
                .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            session: String,
            seq: i64,
            timestamp: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            event: String,
            data: ::prisma_client_rust::serde_json::Value,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(session::set(session));
            _params.push(seq::set(seq));
            _params.push(timestamp::set(timestamp));
            _params.push(event::set(event));
            _params.push(data::set(data));
            Create::new(self.client, _params)
        }
        pub fn create_many(
            self,
            data: Vec<(
                String,
                i64,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                String,
                ::prisma_client_rust::serde_json::Value,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(session, seq, timestamp, event, data, mut _params)| {
                    _params.push(session::set(session));
                    _params.push(seq::set(seq));
                    _params.push(timestamp::set(timestamp));
                    _params.push(event::set(event));
                    _params.push(data::set(data));
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (session, seq, timestamp, event, data, mut _params): (
                String,
                i64,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                String,
                ::prisma_client_rust::serde_json::Value,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(session::set(session));
            _params.push(seq::set(seq));
            _params.push(timestamp::set(timestamp));
            _params.push(event::set(event));
            _params.push(data::set(data));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod guild_bans {
    use super::_prisma::*;
    use super::*;
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementUserId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementUserId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyUserId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideUserId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("user_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("user_id").build()
            }
        }
    }
    pub mod guild_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::GuildIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::GuildId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementGuildId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementGuildId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyGuildId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideGuildId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGuildId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GuildId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GuildId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
    }
    pub mod reason {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::ReasonEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Reason(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetReason(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Reason(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("reason").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Reason(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("reason").build()
            }
        }
    }
    pub fn user_id_guild_id<T: From<UniqueWhereParam>>(user_id: i64, guild_id: i64) -> T {
        UniqueWhereParam::UserIdGuildIdEquals(user_id, guild_id).into()
    }
    pub fn create(
        user_id: i64,
        guild_id: i64,
        _params: Vec<SetParam>,
    ) -> (i64, i64, Vec<SetParam>) {
        (user_id, guild_id, _params)
    }
    pub fn create_unchecked(
        user_id: i64,
        guild_id: i64,
        _params: Vec<SetParam>,
    ) -> (i64, i64, Vec<SetParam>) {
        (user_id, guild_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_guild_bans { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: guild_bans :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: guild_bans :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: guild_bans :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: guild_bans :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: guild_bans :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: guild_bans :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { user_id , guild_id , reason } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: guild_bans :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: guild_bans :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: guild_bans :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: guild_bans :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_bans :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_bans :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["user_id" , "guild_id" , "reason"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: guild_bans :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; user_id) => { i64 } ; (@ field_type ; guild_id) => { i64 } ; (@ field_type ; reason) => { Option < String > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "GuildBans" , available fields are "user_id, guild_id, reason")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < $ crate :: prisma :: guild_bans :: SelectParam > :: into ($ crate :: prisma :: guild_bans :: user_id :: Select) } ; (@ selection_field_to_selection_param ; guild_id) => { Into :: < $ crate :: prisma :: guild_bans :: SelectParam > :: into ($ crate :: prisma :: guild_bans :: guild_id :: Select) } ; (@ selection_field_to_selection_param ; reason) => { Into :: < $ crate :: prisma :: guild_bans :: SelectParam > :: into ($ crate :: prisma :: guild_bans :: reason :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: guild_bans :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; reason) => { "reason" } ; }
    pub use _select_guild_bans as select;
    pub enum SelectParam {
        UserId(user_id::Select),
        GuildId(guild_id::Select),
        Reason(reason::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::UserId(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::Reason(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_guild_bans { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: guild_bans :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: guild_bans :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: guild_bans :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: guild_bans :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: guild_bans :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: guild_bans :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: guild_bans :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: guild_bans :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub user_id : i64 , pub guild_id : i64 , pub reason : Option < String > , $ (pub $ field : $ crate :: prisma :: guild_bans :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (user_id) , stringify ! (guild_id) , stringify ! (reason)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: guild_bans :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: guild_bans :: include ! (@ field_serde_name ; user_id) , & self . user_id) ? ; state . serialize_field ($ crate :: prisma :: guild_bans :: include ! (@ field_serde_name ; guild_id) , & self . guild_id) ? ; state . serialize_field ($ crate :: prisma :: guild_bans :: include ! (@ field_serde_name ; reason) , & self . reason) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , user_id , guild_id , reason } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: guild_bans :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: guild_bans :: include ! (@ field_serde_name ; user_id) , ", " , $ crate :: prisma :: guild_bans :: include ! (@ field_serde_name ; guild_id) , ", " , $ crate :: prisma :: guild_bans :: include ! (@ field_serde_name ; reason) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: guild_bans :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: guild_bans :: include ! (@ field_serde_name ; user_id) => Ok (Field :: user_id) , $ crate :: prisma :: guild_bans :: include ! (@ field_serde_name ; guild_id) => Ok (Field :: guild_id) , $ crate :: prisma :: guild_bans :: include ! (@ field_serde_name ; reason) => Ok (Field :: reason) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut user_id = None ; let mut guild_id = None ; let mut reason = None ; while let Some (key) = map . next_key () ? { match key { Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_bans :: include ! (@ field_serde_name ; user_id))) ; } user_id = Some (map . next_value () ?) ; } Field :: guild_id => { if guild_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_bans :: include ! (@ field_serde_name ; guild_id))) ; } guild_id = Some (map . next_value () ?) ; } Field :: reason => { if reason . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_bans :: include ! (@ field_serde_name ; reason))) ; } reason = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_bans :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_bans :: include ! (@ field_serde_name ; $ field))) ? ;) * let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_bans :: include ! (@ field_serde_name ; user_id))) ? ; let guild_id = guild_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_bans :: include ! (@ field_serde_name ; guild_id))) ? ; let reason = reason . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_bans :: include ! (@ field_serde_name ; reason))) ? ; Ok (Data { user_id , guild_id , reason , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["user_id" , "guild_id" , "reason"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: guild_bans :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "GuildBans" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: guild_bans :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; reason) => { "reason" } ; }
    pub use _include_guild_bans as include;
    pub enum IncludeParam {
        UserId(user_id::Include),
        GuildId(guild_id::Include),
        Reason(reason::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::UserId(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::Reason(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "user_id")]
        pub user_id: i64,
        #[serde(rename = "guild_id")]
        pub guild_id: i64,
        #[serde(rename = "reason")]
        pub reason: Option<String>,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetUserId(i64),
        IncrementUserId(i64),
        DecrementUserId(i64),
        MultiplyUserId(i64),
        DivideUserId(i64),
        SetGuildId(i64),
        IncrementGuildId(i64),
        DecrementGuildId(i64),
        MultiplyGuildId(i64),
        DivideGuildId(i64),
        SetReason(Option<String>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetReason(value) => (
                    "reason".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        UserId(::prisma_client_rust::Direction),
        GuildId(::prisma_client_rust::Direction),
        Reason(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::UserId(direction) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::GuildId(direction) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Reason(direction) => (
                    "reason".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        UserIdGuildIdEquals(i64, i64),
        UserIdEquals(i64),
        UserId(_prisma::read_filters::BigIntFilter),
        GuildIdEquals(i64),
        GuildId(_prisma::read_filters::BigIntFilter),
        ReasonEquals(Option<String>),
        Reason(_prisma::read_filters::StringFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::UserIdGuildIdEquals(user_id, guild_id) => (
                    "user_id_guild_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            "user_id".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(user_id),
                        ),
                        (
                            "guild_id".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(guild_id),
                        ),
                    ]),
                ),
                Self::UserIdEquals(value) => (
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::UserId(value) => ("user_id", value.into()),
                Self::GuildIdEquals(value) => (
                    "guild_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::GuildId(value) => ("guild_id", value.into()),
                Self::ReasonEquals(value) => (
                    "reason",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::Reason(value) => ("reason", value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        UserIdGuildIdEquals(i64, i64),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::UserIdGuildIdEquals(user_id, guild_id) => {
                    Self::UserIdGuildIdEquals(user_id, guild_id)
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "Guild_Bans";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["user_id", "guild_id", "reason"]
                .into_iter()
                .map(|o| {
                    let builder = ::prisma_client_rust::Selection::builder(o);
                    builder.build()
                })
                .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(self, user_id: i64, guild_id: i64, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.push(user_id::set(user_id));
            _params.push(guild_id::set(guild_id));
            Create::new(self.client, _params)
        }
        pub fn create_many(self, data: Vec<(i64, i64, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(user_id, guild_id, mut _params)| {
                    _params.push(user_id::set(user_id));
                    _params.push(guild_id::set(guild_id));
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (user_id, guild_id, mut _params): (i64, i64, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(user_id::set(user_id));
            _params.push(guild_id::set(guild_id));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod guild_config_changes {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::NotInVec(value))
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Lt(value))
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Lte(value))
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Gt(value))
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Gte(value))
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Not(value))
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i64>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i64>) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementUserId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementUserId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyUserId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideUserId(value)
        }
        pub struct Set(pub Option<i64>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("user_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("user_id").build()
            }
        }
    }
    pub mod guild_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::GuildIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::GuildId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementGuildId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementGuildId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyGuildId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideGuildId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGuildId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GuildId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GuildId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
    }
    pub mod before_raw {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<Vec<u8>>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<Vec<u8>>) -> WhereParam {
            WhereParam::BeforeRawEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::BeforeRaw(direction)
        }
        pub fn in_vec(value: Vec<Vec<u8>>) -> WhereParam {
            WhereParam::BeforeRaw(_prisma::read_filters::BytesFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<Vec<u8>>) -> WhereParam {
            WhereParam::BeforeRaw(_prisma::read_filters::BytesFilter::NotInVec(value))
        }
        pub fn not(value: Vec<u8>) -> WhereParam {
            WhereParam::BeforeRaw(_prisma::read_filters::BytesFilter::Not(value))
        }
        pub struct Set(pub Option<Vec<u8>>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetBeforeRaw(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::BeforeRaw(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("before_raw").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::BeforeRaw(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("before_raw").build()
            }
        }
    }
    pub mod after_raw {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Vec<u8>) -> WhereParam {
            WhereParam::AfterRawEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::AfterRaw(direction)
        }
        pub fn in_vec(value: Vec<Vec<u8>>) -> WhereParam {
            WhereParam::AfterRaw(_prisma::read_filters::BytesFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<Vec<u8>>) -> WhereParam {
            WhereParam::AfterRaw(_prisma::read_filters::BytesFilter::NotInVec(value))
        }
        pub fn not(value: Vec<u8>) -> WhereParam {
            WhereParam::AfterRaw(_prisma::read_filters::BytesFilter::Not(value))
        }
        pub struct Set(pub Vec<u8>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAfterRaw(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AfterRaw(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("after_raw").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AfterRaw(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("after_raw").build()
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_at").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_at").build()
            }
        }
    }
    pub fn create(
        guild_id: i64,
        after_raw: Vec<u8>,
        created_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        _params: Vec<SetParam>,
    ) -> (
        i64,
        Vec<u8>,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        Vec<SetParam>,
    ) {
        (guild_id, after_raw, created_at, _params)
    }
    pub fn create_unchecked(
        guild_id: i64,
        after_raw: Vec<u8>,
        created_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        _params: Vec<SetParam>,
    ) -> (
        i64,
        Vec<u8>,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        Vec<SetParam>,
    ) {
        (guild_id, after_raw, created_at, _params)
    }
    #[macro_export]
    macro_rules ! _select_guild_config_changes { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: guild_config_changes :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: guild_config_changes :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: guild_config_changes :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: guild_config_changes :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: guild_config_changes :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: guild_config_changes :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , user_id , guild_id , before_raw , after_raw , created_at } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: guild_config_changes :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: guild_config_changes :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: guild_config_changes :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: guild_config_changes :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_config_changes :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_config_changes :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "user_id" , "guild_id" , "before_raw" , "after_raw" , "created_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: guild_config_changes :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; user_id) => { Option < i64 > } ; (@ field_type ; guild_id) => { i64 } ; (@ field_type ; before_raw) => { Option < Vec < u8 > > } ; (@ field_type ; after_raw) => { Vec < u8 > } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "GuildConfigChanges" , available fields are "id, user_id, guild_id, before_raw, after_raw, created_at")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: guild_config_changes :: SelectParam > :: into ($ crate :: prisma :: guild_config_changes :: id :: Select) } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < $ crate :: prisma :: guild_config_changes :: SelectParam > :: into ($ crate :: prisma :: guild_config_changes :: user_id :: Select) } ; (@ selection_field_to_selection_param ; guild_id) => { Into :: < $ crate :: prisma :: guild_config_changes :: SelectParam > :: into ($ crate :: prisma :: guild_config_changes :: guild_id :: Select) } ; (@ selection_field_to_selection_param ; before_raw) => { Into :: < $ crate :: prisma :: guild_config_changes :: SelectParam > :: into ($ crate :: prisma :: guild_config_changes :: before_raw :: Select) } ; (@ selection_field_to_selection_param ; after_raw) => { Into :: < $ crate :: prisma :: guild_config_changes :: SelectParam > :: into ($ crate :: prisma :: guild_config_changes :: after_raw :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < $ crate :: prisma :: guild_config_changes :: SelectParam > :: into ($ crate :: prisma :: guild_config_changes :: created_at :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: guild_config_changes :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; before_raw) => { "before_raw" } ; (@ field_serde_name ; after_raw) => { "after_raw" } ; (@ field_serde_name ; created_at) => { "created_at" } ; }
    pub use _select_guild_config_changes as select;
    pub enum SelectParam {
        Id(id::Select),
        UserId(user_id::Select),
        GuildId(guild_id::Select),
        BeforeRaw(before_raw::Select),
        AfterRaw(after_raw::Select),
        CreatedAt(created_at::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::BeforeRaw(data) => data.to_selection(),
                Self::AfterRaw(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_guild_config_changes { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: guild_config_changes :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: guild_config_changes :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: guild_config_changes :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: guild_config_changes :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: guild_config_changes :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: guild_config_changes :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: guild_config_changes :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: guild_config_changes :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub user_id : Option < i64 > , pub guild_id : i64 , pub before_raw : Option < Vec < u8 > > , pub after_raw : Vec < u8 > , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : $ crate :: prisma :: guild_config_changes :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (user_id) , stringify ! (guild_id) , stringify ! (before_raw) , stringify ! (after_raw) , stringify ! (created_at)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; user_id) , & self . user_id) ? ; state . serialize_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; guild_id) , & self . guild_id) ? ; state . serialize_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; before_raw) , & self . before_raw) ? ; state . serialize_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; after_raw) , & self . after_raw) ? ; state . serialize_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; created_at) , & self . created_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , user_id , guild_id , before_raw , after_raw , created_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; user_id) , ", " , $ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; guild_id) , ", " , $ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; before_raw) , ", " , $ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; after_raw) , ", " , $ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; created_at) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; user_id) => Ok (Field :: user_id) , $ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; guild_id) => Ok (Field :: guild_id) , $ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; before_raw) => Ok (Field :: before_raw) , $ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; after_raw) => Ok (Field :: after_raw) , $ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; created_at) => Ok (Field :: created_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut user_id = None ; let mut guild_id = None ; let mut before_raw = None ; let mut after_raw = None ; let mut created_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; user_id))) ; } user_id = Some (map . next_value () ?) ; } Field :: guild_id => { if guild_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; guild_id))) ; } guild_id = Some (map . next_value () ?) ; } Field :: before_raw => { if before_raw . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; before_raw))) ; } before_raw = Some (map . next_value () ?) ; } Field :: after_raw => { if after_raw . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; after_raw))) ; } after_raw = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; created_at))) ; } created_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; id))) ? ; let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; user_id))) ? ; let guild_id = guild_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; guild_id))) ? ; let before_raw = before_raw . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; before_raw))) ? ; let after_raw = after_raw . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; after_raw))) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_config_changes :: include ! (@ field_serde_name ; created_at))) ? ; Ok (Data { id , user_id , guild_id , before_raw , after_raw , created_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "user_id" , "guild_id" , "before_raw" , "after_raw" , "created_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: guild_config_changes :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "GuildConfigChanges" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: guild_config_changes :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; before_raw) => { "before_raw" } ; (@ field_serde_name ; after_raw) => { "after_raw" } ; (@ field_serde_name ; created_at) => { "created_at" } ; }
    pub use _include_guild_config_changes as include;
    pub enum IncludeParam {
        Id(id::Include),
        UserId(user_id::Include),
        GuildId(guild_id::Include),
        BeforeRaw(before_raw::Include),
        AfterRaw(after_raw::Include),
        CreatedAt(created_at::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::BeforeRaw(data) => data.to_selection(),
                Self::AfterRaw(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "user_id")]
        pub user_id: Option<i64>,
        #[serde(rename = "guild_id")]
        pub guild_id: i64,
        #[serde(rename = "before_raw")]
        pub before_raw: Option<Vec<u8>>,
        #[serde(rename = "after_raw")]
        pub after_raw: Vec<u8>,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetUserId(Option<i64>),
        IncrementUserId(i64),
        DecrementUserId(i64),
        MultiplyUserId(i64),
        DivideUserId(i64),
        SetGuildId(i64),
        IncrementGuildId(i64),
        DecrementGuildId(i64),
        MultiplyGuildId(i64),
        DivideGuildId(i64),
        SetBeforeRaw(Option<Vec<u8>>),
        SetAfterRaw(Vec<u8>),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetUserId(value) => (
                    "user_id".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetBeforeRaw(value) => (
                    "before_raw".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetAfterRaw(value) => (
                    "after_raw".to_string(),
                    ::prisma_client_rust::PrismaValue::Bytes(value),
                ),
                SetParam::SetCreatedAt(value) => (
                    "created_at".to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        UserId(::prisma_client_rust::Direction),
        GuildId(::prisma_client_rust::Direction),
        BeforeRaw(::prisma_client_rust::Direction),
        AfterRaw(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::GuildId(direction) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::BeforeRaw(direction) => (
                    "before_raw".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::AfterRaw(direction) => (
                    "after_raw".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    "created_at".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(i32),
        Id(_prisma::read_filters::IntFilter),
        UserIdEquals(Option<i64>),
        UserId(_prisma::read_filters::BigIntFilter),
        GuildIdEquals(i64),
        GuildId(_prisma::read_filters::BigIntFilter),
        BeforeRawEquals(Option<Vec<u8>>),
        BeforeRaw(_prisma::read_filters::BytesFilter),
        AfterRawEquals(Vec<u8>),
        AfterRaw(_prisma::read_filters::BytesFilter),
        CreatedAtEquals(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::Id(value) => ("id", value.into()),
                Self::UserIdEquals(value) => (
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::UserId(value) => ("user_id", value.into()),
                Self::GuildIdEquals(value) => (
                    "guild_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::GuildId(value) => ("guild_id", value.into()),
                Self::BeforeRawEquals(value) => (
                    "before_raw",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::BeforeRaw(value) => ("before_raw", value.into()),
                Self::AfterRawEquals(value) => (
                    "after_raw",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Bytes(value),
                    )]),
                ),
                Self::AfterRaw(value) => ("after_raw", value.into()),
                Self::CreatedAtEquals(value) => (
                    "created_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAt(value) => ("created_at", value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "Guild_Config_Changes";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            [
                "id",
                "user_id",
                "guild_id",
                "before_raw",
                "after_raw",
                "created_at",
            ]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            guild_id: i64,
            after_raw: Vec<u8>,
            created_at: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(guild_id::set(guild_id));
            _params.push(after_raw::set(after_raw));
            _params.push(created_at::set(created_at));
            Create::new(self.client, _params)
        }
        pub fn create_many(
            self,
            data: Vec<(
                i64,
                Vec<u8>,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(guild_id, after_raw, created_at, mut _params)| {
                    _params.push(guild_id::set(guild_id));
                    _params.push(after_raw::set(after_raw));
                    _params.push(created_at::set(created_at));
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (guild_id, after_raw, created_at, mut _params): (
                i64,
                Vec<u8>,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(guild_id::set(guild_id));
            _params.push(after_raw::set(after_raw));
            _params.push(created_at::set(created_at));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod guild_emojis {
    use super::_prisma::*;
    use super::*;
    pub mod emoji_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i64) -> T {
            UniqueWhereParam::EmojiIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::EmojiId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::EmojiId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::EmojiId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::EmojiId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::EmojiId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::EmojiId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::EmojiId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::EmojiId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementEmojiId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementEmojiId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyEmojiId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideEmojiId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEmojiId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::EmojiId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("emoji_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::EmojiId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("emoji_id").build()
            }
        }
    }
    pub mod guild_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::GuildIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::GuildId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementGuildId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementGuildId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyGuildId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideGuildId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGuildId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GuildId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GuildId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::NameEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetName(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("name").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("name").build()
            }
        }
    }
    pub mod require_colons {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::RequireColonsEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::RequireColons(direction)
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetRequireColons(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::RequireColons(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("require_colons").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::RequireColons(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("require_colons").build()
            }
        }
    }
    pub mod managed {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::ManagedEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Managed(direction)
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetManaged(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Managed(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("managed").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Managed(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("managed").build()
            }
        }
    }
    pub mod roles {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Vec<i64>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Vec<i64>) -> WhereParam {
            WhereParam::RolesEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Roles(direction)
        }
        pub fn has(value: i64) -> WhereParam {
            WhereParam::Roles(_prisma::read_filters::BigIntListFilter::Has(value))
        }
        pub fn has_every(value: Vec<i64>) -> WhereParam {
            WhereParam::Roles(_prisma::read_filters::BigIntListFilter::HasEvery(value))
        }
        pub fn has_some(value: Vec<i64>) -> WhereParam {
            WhereParam::Roles(_prisma::read_filters::BigIntListFilter::HasSome(value))
        }
        pub fn is_empty(value: bool) -> WhereParam {
            WhereParam::Roles(_prisma::read_filters::BigIntListFilter::IsEmpty(value))
        }
        pub fn push(value: Vec<i64>) -> SetParam {
            SetParam::PushRoles(value)
        }
        pub struct Set(pub Vec<i64>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetRoles(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Roles(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("roles").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Roles(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("roles").build()
            }
        }
    }
    pub mod deleted {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::DeletedEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Deleted(direction)
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDeleted(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Deleted(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("deleted").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Deleted(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("deleted").build()
            }
        }
    }
    pub fn create(
        emoji_id: i64,
        guild_id: i64,
        name: String,
        require_colons: bool,
        managed: bool,
        deleted: bool,
        _params: Vec<SetParam>,
    ) -> (i64, i64, String, bool, bool, bool, Vec<SetParam>) {
        (
            emoji_id,
            guild_id,
            name,
            require_colons,
            managed,
            deleted,
            _params,
        )
    }
    pub fn create_unchecked(
        emoji_id: i64,
        guild_id: i64,
        name: String,
        require_colons: bool,
        managed: bool,
        deleted: bool,
        _params: Vec<SetParam>,
    ) -> (i64, i64, String, bool, bool, bool, Vec<SetParam>) {
        (
            emoji_id,
            guild_id,
            name,
            require_colons,
            managed,
            deleted,
            _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_guild_emojis { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: guild_emojis :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: guild_emojis :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: guild_emojis :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: guild_emojis :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: guild_emojis :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: guild_emojis :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { emoji_id , guild_id , name , require_colons , managed , roles , deleted } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: guild_emojis :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: guild_emojis :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: guild_emojis :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: guild_emojis :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_emojis :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_emojis :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["emoji_id" , "guild_id" , "name" , "require_colons" , "managed" , "roles" , "deleted"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: guild_emojis :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; emoji_id) => { i64 } ; (@ field_type ; guild_id) => { i64 } ; (@ field_type ; name) => { String } ; (@ field_type ; require_colons) => { bool } ; (@ field_type ; managed) => { bool } ; (@ field_type ; roles) => { Vec < i64 > } ; (@ field_type ; deleted) => { bool } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "GuildEmojis" , available fields are "emoji_id, guild_id, name, require_colons, managed, roles, deleted")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; emoji_id) => { Into :: < $ crate :: prisma :: guild_emojis :: SelectParam > :: into ($ crate :: prisma :: guild_emojis :: emoji_id :: Select) } ; (@ selection_field_to_selection_param ; guild_id) => { Into :: < $ crate :: prisma :: guild_emojis :: SelectParam > :: into ($ crate :: prisma :: guild_emojis :: guild_id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < $ crate :: prisma :: guild_emojis :: SelectParam > :: into ($ crate :: prisma :: guild_emojis :: name :: Select) } ; (@ selection_field_to_selection_param ; require_colons) => { Into :: < $ crate :: prisma :: guild_emojis :: SelectParam > :: into ($ crate :: prisma :: guild_emojis :: require_colons :: Select) } ; (@ selection_field_to_selection_param ; managed) => { Into :: < $ crate :: prisma :: guild_emojis :: SelectParam > :: into ($ crate :: prisma :: guild_emojis :: managed :: Select) } ; (@ selection_field_to_selection_param ; roles) => { Into :: < $ crate :: prisma :: guild_emojis :: SelectParam > :: into ($ crate :: prisma :: guild_emojis :: roles :: Select) } ; (@ selection_field_to_selection_param ; deleted) => { Into :: < $ crate :: prisma :: guild_emojis :: SelectParam > :: into ($ crate :: prisma :: guild_emojis :: deleted :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: guild_emojis :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; emoji_id) => { "emoji_id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; require_colons) => { "require_colons" } ; (@ field_serde_name ; managed) => { "managed" } ; (@ field_serde_name ; roles) => { "roles" } ; (@ field_serde_name ; deleted) => { "deleted" } ; }
    pub use _select_guild_emojis as select;
    pub enum SelectParam {
        EmojiId(emoji_id::Select),
        GuildId(guild_id::Select),
        Name(name::Select),
        RequireColons(require_colons::Select),
        Managed(managed::Select),
        Roles(roles::Select),
        Deleted(deleted::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::EmojiId(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::RequireColons(data) => data.to_selection(),
                Self::Managed(data) => data.to_selection(),
                Self::Roles(data) => data.to_selection(),
                Self::Deleted(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_guild_emojis { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: guild_emojis :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: guild_emojis :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: guild_emojis :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: guild_emojis :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: guild_emojis :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: guild_emojis :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: guild_emojis :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: guild_emojis :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub emoji_id : i64 , pub guild_id : i64 , pub name : String , pub require_colons : bool , pub managed : bool , pub roles : Vec < i64 > , pub deleted : bool , $ (pub $ field : $ crate :: prisma :: guild_emojis :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (emoji_id) , stringify ! (guild_id) , stringify ! (name) , stringify ! (require_colons) , stringify ! (managed) , stringify ! (roles) , stringify ! (deleted)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; emoji_id) , & self . emoji_id) ? ; state . serialize_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; guild_id) , & self . guild_id) ? ; state . serialize_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; name) , & self . name) ? ; state . serialize_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; require_colons) , & self . require_colons) ? ; state . serialize_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; managed) , & self . managed) ? ; state . serialize_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; roles) , & self . roles) ? ; state . serialize_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; deleted) , & self . deleted) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , emoji_id , guild_id , name , require_colons , managed , roles , deleted } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; emoji_id) , ", " , $ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; guild_id) , ", " , $ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; name) , ", " , $ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; require_colons) , ", " , $ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; managed) , ", " , $ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; roles) , ", " , $ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; deleted) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; emoji_id) => Ok (Field :: emoji_id) , $ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; guild_id) => Ok (Field :: guild_id) , $ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; name) => Ok (Field :: name) , $ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; require_colons) => Ok (Field :: require_colons) , $ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; managed) => Ok (Field :: managed) , $ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; roles) => Ok (Field :: roles) , $ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; deleted) => Ok (Field :: deleted) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut emoji_id = None ; let mut guild_id = None ; let mut name = None ; let mut require_colons = None ; let mut managed = None ; let mut roles = None ; let mut deleted = None ; while let Some (key) = map . next_key () ? { match key { Field :: emoji_id => { if emoji_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; emoji_id))) ; } emoji_id = Some (map . next_value () ?) ; } Field :: guild_id => { if guild_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; guild_id))) ; } guild_id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; name))) ; } name = Some (map . next_value () ?) ; } Field :: require_colons => { if require_colons . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; require_colons))) ; } require_colons = Some (map . next_value () ?) ; } Field :: managed => { if managed . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; managed))) ; } managed = Some (map . next_value () ?) ; } Field :: roles => { if roles . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; roles))) ; } roles = Some (map . next_value () ?) ; } Field :: deleted => { if deleted . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; deleted))) ; } deleted = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; $ field))) ? ;) * let emoji_id = emoji_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; emoji_id))) ? ; let guild_id = guild_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; guild_id))) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; name))) ? ; let require_colons = require_colons . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; require_colons))) ? ; let managed = managed . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; managed))) ? ; let roles = roles . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; roles))) ? ; let deleted = deleted . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_emojis :: include ! (@ field_serde_name ; deleted))) ? ; Ok (Data { emoji_id , guild_id , name , require_colons , managed , roles , deleted , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["emoji_id" , "guild_id" , "name" , "require_colons" , "managed" , "roles" , "deleted"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: guild_emojis :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "GuildEmojis" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: guild_emojis :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; emoji_id) => { "emoji_id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; require_colons) => { "require_colons" } ; (@ field_serde_name ; managed) => { "managed" } ; (@ field_serde_name ; roles) => { "roles" } ; (@ field_serde_name ; deleted) => { "deleted" } ; }
    pub use _include_guild_emojis as include;
    pub enum IncludeParam {
        EmojiId(emoji_id::Include),
        GuildId(guild_id::Include),
        Name(name::Include),
        RequireColons(require_colons::Include),
        Managed(managed::Include),
        Roles(roles::Include),
        Deleted(deleted::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::EmojiId(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::RequireColons(data) => data.to_selection(),
                Self::Managed(data) => data.to_selection(),
                Self::Roles(data) => data.to_selection(),
                Self::Deleted(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "emoji_id")]
        pub emoji_id: i64,
        #[serde(rename = "guild_id")]
        pub guild_id: i64,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "require_colons")]
        pub require_colons: bool,
        #[serde(rename = "managed")]
        pub managed: bool,
        #[serde(rename = "roles")]
        pub roles: Vec<i64>,
        #[serde(rename = "deleted")]
        pub deleted: bool,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetEmojiId(i64),
        IncrementEmojiId(i64),
        DecrementEmojiId(i64),
        MultiplyEmojiId(i64),
        DivideEmojiId(i64),
        SetGuildId(i64),
        IncrementGuildId(i64),
        DecrementGuildId(i64),
        MultiplyGuildId(i64),
        DivideGuildId(i64),
        SetName(String),
        SetRequireColons(bool),
        SetManaged(bool),
        SetRoles(Vec<i64>),
        PushRoles(Vec<i64>),
        SetDeleted(bool),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetEmojiId(value) => (
                    "emoji_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementEmojiId(value) => (
                    "emoji_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementEmojiId(value) => (
                    "emoji_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyEmojiId(value) => (
                    "emoji_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideEmojiId(value) => (
                    "emoji_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetName(value) => (
                    "name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetRequireColons(value) => (
                    "require_colons".to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetManaged(value) => (
                    "managed".to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetRoles(value) => (
                    "roles".to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                            .collect(),
                    ),
                ),
                SetParam::PushRoles(value) => (
                    "roles".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetDeleted(value) => (
                    "deleted".to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        EmojiId(::prisma_client_rust::Direction),
        GuildId(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        RequireColons(::prisma_client_rust::Direction),
        Managed(::prisma_client_rust::Direction),
        Roles(::prisma_client_rust::Direction),
        Deleted(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::EmojiId(direction) => (
                    "emoji_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::GuildId(direction) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    "name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::RequireColons(direction) => (
                    "require_colons".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Managed(direction) => (
                    "managed".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Roles(direction) => (
                    "roles".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Deleted(direction) => (
                    "deleted".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        EmojiIdEquals(i64),
        EmojiId(_prisma::read_filters::BigIntFilter),
        GuildIdEquals(i64),
        GuildId(_prisma::read_filters::BigIntFilter),
        NameEquals(String),
        Name(_prisma::read_filters::StringFilter),
        RequireColonsEquals(bool),
        ManagedEquals(bool),
        RolesEquals(Vec<i64>),
        Roles(_prisma::read_filters::BigIntListFilter),
        DeletedEquals(bool),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::EmojiIdEquals(value) => (
                    "emoji_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::EmojiId(value) => ("emoji_id", value.into()),
                Self::GuildIdEquals(value) => (
                    "guild_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::GuildId(value) => ("guild_id", value.into()),
                Self::NameEquals(value) => (
                    "name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::Name(value) => ("name", value.into()),
                Self::RequireColonsEquals(value) => (
                    "require_colons",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                ),
                Self::ManagedEquals(value) => (
                    "managed",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                ),
                Self::RolesEquals(value) => (
                    "roles",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::Roles(value) => ("roles", value.into()),
                Self::DeletedEquals(value) => (
                    "deleted",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        EmojiIdEquals(i64),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::EmojiIdEquals(value) => Self::EmojiIdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "guild_emojis";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            [
                "emoji_id",
                "guild_id",
                "name",
                "require_colons",
                "managed",
                "roles",
                "deleted",
            ]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            emoji_id: i64,
            guild_id: i64,
            name: String,
            require_colons: bool,
            managed: bool,
            deleted: bool,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(emoji_id::set(emoji_id));
            _params.push(guild_id::set(guild_id));
            _params.push(name::set(name));
            _params.push(require_colons::set(require_colons));
            _params.push(managed::set(managed));
            _params.push(deleted::set(deleted));
            Create::new(self.client, _params)
        }
        pub fn create_many(
            self,
            data: Vec<(i64, i64, String, bool, bool, bool, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(emoji_id, guild_id, name, require_colons, managed, deleted, mut _params)| {
                        _params.push(emoji_id::set(emoji_id));
                        _params.push(guild_id::set(guild_id));
                        _params.push(name::set(name));
                        _params.push(require_colons::set(require_colons));
                        _params.push(managed::set(managed));
                        _params.push(deleted::set(deleted));
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (emoji_id, guild_id, name, require_colons, managed, deleted, mut _params): (
                i64,
                i64,
                String,
                bool,
                bool,
                bool,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(emoji_id::set(emoji_id));
            _params.push(guild_id::set(guild_id));
            _params.push(name::set(name));
            _params.push(require_colons::set(require_colons));
            _params.push(managed::set(managed));
            _params.push(deleted::set(deleted));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod guild_member_backups {
    use super::_prisma::*;
    use super::*;
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementUserId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementUserId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyUserId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideUserId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("user_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("user_id").build()
            }
        }
    }
    pub mod guild_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::GuildIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::GuildId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementGuildId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementGuildId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyGuildId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideGuildId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGuildId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GuildId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GuildId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
    }
    pub mod nick {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::NickEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Nick(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Nick(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Nick(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Nick(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Nick(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Nick(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Nick(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Nick(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Nick(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Nick(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Nick(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Nick(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetNick(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Nick(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("nick").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Nick(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("nick").build()
            }
        }
    }
    pub mod roles {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Vec<i64>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Vec<i64>) -> WhereParam {
            WhereParam::RolesEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Roles(direction)
        }
        pub fn has(value: i64) -> WhereParam {
            WhereParam::Roles(_prisma::read_filters::BigIntListFilter::Has(value))
        }
        pub fn has_every(value: Vec<i64>) -> WhereParam {
            WhereParam::Roles(_prisma::read_filters::BigIntListFilter::HasEvery(value))
        }
        pub fn has_some(value: Vec<i64>) -> WhereParam {
            WhereParam::Roles(_prisma::read_filters::BigIntListFilter::HasSome(value))
        }
        pub fn is_empty(value: bool) -> WhereParam {
            WhereParam::Roles(_prisma::read_filters::BigIntListFilter::IsEmpty(value))
        }
        pub fn push(value: Vec<i64>) -> SetParam {
            SetParam::PushRoles(value)
        }
        pub struct Set(pub Vec<i64>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetRoles(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Roles(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("roles").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Roles(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("roles").build()
            }
        }
    }
    pub mod mute {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<bool>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<bool>) -> WhereParam {
            WhereParam::MuteEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Mute(direction)
        }
        pub struct Set(pub Option<bool>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetMute(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Mute(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("mute").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Mute(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("mute").build()
            }
        }
    }
    pub mod deaf {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<bool>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<bool>) -> WhereParam {
            WhereParam::DeafEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Deaf(direction)
        }
        pub struct Set(pub Option<bool>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDeaf(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Deaf(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("deaf").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Deaf(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("deaf").build()
            }
        }
    }
    pub fn user_id_guild_id<T: From<UniqueWhereParam>>(user_id: i64, guild_id: i64) -> T {
        UniqueWhereParam::UserIdGuildIdEquals(user_id, guild_id).into()
    }
    pub fn create(
        user_id: i64,
        guild_id: i64,
        _params: Vec<SetParam>,
    ) -> (i64, i64, Vec<SetParam>) {
        (user_id, guild_id, _params)
    }
    pub fn create_unchecked(
        user_id: i64,
        guild_id: i64,
        _params: Vec<SetParam>,
    ) -> (i64, i64, Vec<SetParam>) {
        (user_id, guild_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_guild_member_backups { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: guild_member_backups :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: guild_member_backups :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: guild_member_backups :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: guild_member_backups :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: guild_member_backups :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: guild_member_backups :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { user_id , guild_id , nick , roles , mute , deaf } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: guild_member_backups :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: guild_member_backups :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: guild_member_backups :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: guild_member_backups :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_member_backups :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_member_backups :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["user_id" , "guild_id" , "nick" , "roles" , "mute" , "deaf"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: guild_member_backups :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; user_id) => { i64 } ; (@ field_type ; guild_id) => { i64 } ; (@ field_type ; nick) => { Option < String > } ; (@ field_type ; roles) => { Vec < i64 > } ; (@ field_type ; mute) => { Option < bool > } ; (@ field_type ; deaf) => { Option < bool > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "GuildMemberBackups" , available fields are "user_id, guild_id, nick, roles, mute, deaf")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < $ crate :: prisma :: guild_member_backups :: SelectParam > :: into ($ crate :: prisma :: guild_member_backups :: user_id :: Select) } ; (@ selection_field_to_selection_param ; guild_id) => { Into :: < $ crate :: prisma :: guild_member_backups :: SelectParam > :: into ($ crate :: prisma :: guild_member_backups :: guild_id :: Select) } ; (@ selection_field_to_selection_param ; nick) => { Into :: < $ crate :: prisma :: guild_member_backups :: SelectParam > :: into ($ crate :: prisma :: guild_member_backups :: nick :: Select) } ; (@ selection_field_to_selection_param ; roles) => { Into :: < $ crate :: prisma :: guild_member_backups :: SelectParam > :: into ($ crate :: prisma :: guild_member_backups :: roles :: Select) } ; (@ selection_field_to_selection_param ; mute) => { Into :: < $ crate :: prisma :: guild_member_backups :: SelectParam > :: into ($ crate :: prisma :: guild_member_backups :: mute :: Select) } ; (@ selection_field_to_selection_param ; deaf) => { Into :: < $ crate :: prisma :: guild_member_backups :: SelectParam > :: into ($ crate :: prisma :: guild_member_backups :: deaf :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: guild_member_backups :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; nick) => { "nick" } ; (@ field_serde_name ; roles) => { "roles" } ; (@ field_serde_name ; mute) => { "mute" } ; (@ field_serde_name ; deaf) => { "deaf" } ; }
    pub use _select_guild_member_backups as select;
    pub enum SelectParam {
        UserId(user_id::Select),
        GuildId(guild_id::Select),
        Nick(nick::Select),
        Roles(roles::Select),
        Mute(mute::Select),
        Deaf(deaf::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::UserId(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::Nick(data) => data.to_selection(),
                Self::Roles(data) => data.to_selection(),
                Self::Mute(data) => data.to_selection(),
                Self::Deaf(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_guild_member_backups { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: guild_member_backups :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: guild_member_backups :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: guild_member_backups :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: guild_member_backups :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: guild_member_backups :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: guild_member_backups :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: guild_member_backups :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: guild_member_backups :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub user_id : i64 , pub guild_id : i64 , pub nick : Option < String > , pub roles : Vec < i64 > , pub mute : Option < bool > , pub deaf : Option < bool > , $ (pub $ field : $ crate :: prisma :: guild_member_backups :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (user_id) , stringify ! (guild_id) , stringify ! (nick) , stringify ! (roles) , stringify ! (mute) , stringify ! (deaf)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; user_id) , & self . user_id) ? ; state . serialize_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; guild_id) , & self . guild_id) ? ; state . serialize_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; nick) , & self . nick) ? ; state . serialize_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; roles) , & self . roles) ? ; state . serialize_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; mute) , & self . mute) ? ; state . serialize_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; deaf) , & self . deaf) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , user_id , guild_id , nick , roles , mute , deaf } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; user_id) , ", " , $ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; guild_id) , ", " , $ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; nick) , ", " , $ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; roles) , ", " , $ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; mute) , ", " , $ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; deaf) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; user_id) => Ok (Field :: user_id) , $ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; guild_id) => Ok (Field :: guild_id) , $ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; nick) => Ok (Field :: nick) , $ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; roles) => Ok (Field :: roles) , $ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; mute) => Ok (Field :: mute) , $ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; deaf) => Ok (Field :: deaf) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut user_id = None ; let mut guild_id = None ; let mut nick = None ; let mut roles = None ; let mut mute = None ; let mut deaf = None ; while let Some (key) = map . next_key () ? { match key { Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; user_id))) ; } user_id = Some (map . next_value () ?) ; } Field :: guild_id => { if guild_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; guild_id))) ; } guild_id = Some (map . next_value () ?) ; } Field :: nick => { if nick . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; nick))) ; } nick = Some (map . next_value () ?) ; } Field :: roles => { if roles . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; roles))) ; } roles = Some (map . next_value () ?) ; } Field :: mute => { if mute . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; mute))) ; } mute = Some (map . next_value () ?) ; } Field :: deaf => { if deaf . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; deaf))) ; } deaf = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; $ field))) ? ;) * let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; user_id))) ? ; let guild_id = guild_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; guild_id))) ? ; let nick = nick . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; nick))) ? ; let roles = roles . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; roles))) ? ; let mute = mute . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; mute))) ? ; let deaf = deaf . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_member_backups :: include ! (@ field_serde_name ; deaf))) ? ; Ok (Data { user_id , guild_id , nick , roles , mute , deaf , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["user_id" , "guild_id" , "nick" , "roles" , "mute" , "deaf"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: guild_member_backups :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "GuildMemberBackups" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: guild_member_backups :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; nick) => { "nick" } ; (@ field_serde_name ; roles) => { "roles" } ; (@ field_serde_name ; mute) => { "mute" } ; (@ field_serde_name ; deaf) => { "deaf" } ; }
    pub use _include_guild_member_backups as include;
    pub enum IncludeParam {
        UserId(user_id::Include),
        GuildId(guild_id::Include),
        Nick(nick::Include),
        Roles(roles::Include),
        Mute(mute::Include),
        Deaf(deaf::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::UserId(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::Nick(data) => data.to_selection(),
                Self::Roles(data) => data.to_selection(),
                Self::Mute(data) => data.to_selection(),
                Self::Deaf(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "user_id")]
        pub user_id: i64,
        #[serde(rename = "guild_id")]
        pub guild_id: i64,
        #[serde(rename = "nick")]
        pub nick: Option<String>,
        #[serde(rename = "roles")]
        pub roles: Vec<i64>,
        #[serde(rename = "mute")]
        pub mute: Option<bool>,
        #[serde(rename = "deaf")]
        pub deaf: Option<bool>,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetUserId(i64),
        IncrementUserId(i64),
        DecrementUserId(i64),
        MultiplyUserId(i64),
        DivideUserId(i64),
        SetGuildId(i64),
        IncrementGuildId(i64),
        DecrementGuildId(i64),
        MultiplyGuildId(i64),
        DivideGuildId(i64),
        SetNick(Option<String>),
        SetRoles(Vec<i64>),
        PushRoles(Vec<i64>),
        SetMute(Option<bool>),
        SetDeaf(Option<bool>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetNick(value) => (
                    "nick".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetRoles(value) => (
                    "roles".to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                            .collect(),
                    ),
                ),
                SetParam::PushRoles(value) => (
                    "roles".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetMute(value) => (
                    "mute".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Boolean(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetDeaf(value) => (
                    "deaf".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Boolean(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        UserId(::prisma_client_rust::Direction),
        GuildId(::prisma_client_rust::Direction),
        Nick(::prisma_client_rust::Direction),
        Roles(::prisma_client_rust::Direction),
        Mute(::prisma_client_rust::Direction),
        Deaf(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::UserId(direction) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::GuildId(direction) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Nick(direction) => (
                    "nick".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Roles(direction) => (
                    "roles".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Mute(direction) => (
                    "mute".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Deaf(direction) => (
                    "deaf".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        UserIdGuildIdEquals(i64, i64),
        UserIdEquals(i64),
        UserId(_prisma::read_filters::BigIntFilter),
        GuildIdEquals(i64),
        GuildId(_prisma::read_filters::BigIntFilter),
        NickEquals(Option<String>),
        Nick(_prisma::read_filters::StringFilter),
        RolesEquals(Vec<i64>),
        Roles(_prisma::read_filters::BigIntListFilter),
        MuteEquals(Option<bool>),
        DeafEquals(Option<bool>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::UserIdGuildIdEquals(user_id, guild_id) => (
                    "user_id_guild_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            "user_id".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(user_id),
                        ),
                        (
                            "guild_id".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(guild_id),
                        ),
                    ]),
                ),
                Self::UserIdEquals(value) => (
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::UserId(value) => ("user_id", value.into()),
                Self::GuildIdEquals(value) => (
                    "guild_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::GuildId(value) => ("guild_id", value.into()),
                Self::NickEquals(value) => (
                    "nick",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::Nick(value) => ("nick", value.into()),
                Self::RolesEquals(value) => (
                    "roles",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::Roles(value) => ("roles", value.into()),
                Self::MuteEquals(value) => (
                    "mute",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::Boolean(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::DeafEquals(value) => (
                    "deaf",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::Boolean(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        UserIdGuildIdEquals(i64, i64),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::UserIdGuildIdEquals(user_id, guild_id) => {
                    Self::UserIdGuildIdEquals(user_id, guild_id)
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "guild_member_backups";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["user_id", "guild_id", "nick", "roles", "mute", "deaf"]
                .into_iter()
                .map(|o| {
                    let builder = ::prisma_client_rust::Selection::builder(o);
                    builder.build()
                })
                .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(self, user_id: i64, guild_id: i64, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.push(user_id::set(user_id));
            _params.push(guild_id::set(guild_id));
            Create::new(self.client, _params)
        }
        pub fn create_many(self, data: Vec<(i64, i64, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(user_id, guild_id, mut _params)| {
                    _params.push(user_id::set(user_id));
                    _params.push(guild_id::set(guild_id));
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (user_id, guild_id, mut _params): (i64, i64, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(user_id::set(user_id));
            _params.push(guild_id::set(guild_id));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod guild_voice_sessions {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::NotInVec(value))
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Lt(value))
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Lte(value))
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Gt(value))
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Gte(value))
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Not(value))
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod session_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::SessionIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::SessionId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::SessionId(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::SessionId(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::SessionId(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::SessionId(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::SessionId(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::SessionId(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::SessionId(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::SessionId(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::SessionId(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::SessionId(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::SessionId(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetSessionId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SessionId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("session_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SessionId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("session_id").build()
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementUserId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementUserId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyUserId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideUserId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("user_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("user_id").build()
            }
        }
    }
    pub mod guild_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::GuildIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::GuildId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementGuildId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementGuildId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyGuildId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideGuildId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGuildId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GuildId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GuildId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
    }
    pub mod channel_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::ChannelIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ChannelId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementChannelId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementChannelId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyChannelId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideChannelId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetChannelId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ChannelId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("channel_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ChannelId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("channel_id").build()
            }
        }
    }
    pub mod started_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::StartedAtEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::StartedAt(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::StartedAt(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::StartedAt(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::StartedAt(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::StartedAt(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::StartedAt(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::StartedAt(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::StartedAt(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetStartedAt(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::StartedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("started_at").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::StartedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("started_at").build()
            }
        }
    }
    pub mod ended_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::EndedAtEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::EndedAt(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::EndedAt(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::EndedAt(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::EndedAt(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::EndedAt(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::EndedAt(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::EndedAt(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::EndedAt(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(
            pub  Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEndedAt(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::EndedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("ended_at").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::EndedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("ended_at").build()
            }
        }
    }
    pub fn session_id_user_id_guild_id_channel_id_started_at_ended_at<T: From<UniqueWhereParam>>(
        session_id: String,
        user_id: i64,
        guild_id: i64,
        channel_id: i64,
        started_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        ended_at: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    ) -> T {
        UniqueWhereParam::SessionIdUserIdGuildIdChannelIdStartedAtEndedAtEquals(
            session_id, user_id, guild_id, channel_id, started_at, ended_at,
        )
        .into()
    }
    pub fn create(
        session_id: String,
        user_id: i64,
        guild_id: i64,
        channel_id: i64,
        started_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        _params: Vec<SetParam>,
    ) -> (
        String,
        i64,
        i64,
        i64,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        Vec<SetParam>,
    ) {
        (
            session_id, user_id, guild_id, channel_id, started_at, _params,
        )
    }
    pub fn create_unchecked(
        session_id: String,
        user_id: i64,
        guild_id: i64,
        channel_id: i64,
        started_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        _params: Vec<SetParam>,
    ) -> (
        String,
        i64,
        i64,
        i64,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        Vec<SetParam>,
    ) {
        (
            session_id, user_id, guild_id, channel_id, started_at, _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_guild_voice_sessions { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: guild_voice_sessions :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: guild_voice_sessions :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: guild_voice_sessions :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: guild_voice_sessions :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: guild_voice_sessions :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: guild_voice_sessions :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , session_id , user_id , guild_id , channel_id , started_at , ended_at } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: guild_voice_sessions :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: guild_voice_sessions :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: guild_voice_sessions :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: guild_voice_sessions :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_voice_sessions :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_voice_sessions :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "session_id" , "user_id" , "guild_id" , "channel_id" , "started_at" , "ended_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: guild_voice_sessions :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; session_id) => { String } ; (@ field_type ; user_id) => { i64 } ; (@ field_type ; guild_id) => { i64 } ; (@ field_type ; channel_id) => { i64 } ; (@ field_type ; started_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; ended_at) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "GuildVoiceSessions" , available fields are "id, session_id, user_id, guild_id, channel_id, started_at, ended_at")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: guild_voice_sessions :: SelectParam > :: into ($ crate :: prisma :: guild_voice_sessions :: id :: Select) } ; (@ selection_field_to_selection_param ; session_id) => { Into :: < $ crate :: prisma :: guild_voice_sessions :: SelectParam > :: into ($ crate :: prisma :: guild_voice_sessions :: session_id :: Select) } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < $ crate :: prisma :: guild_voice_sessions :: SelectParam > :: into ($ crate :: prisma :: guild_voice_sessions :: user_id :: Select) } ; (@ selection_field_to_selection_param ; guild_id) => { Into :: < $ crate :: prisma :: guild_voice_sessions :: SelectParam > :: into ($ crate :: prisma :: guild_voice_sessions :: guild_id :: Select) } ; (@ selection_field_to_selection_param ; channel_id) => { Into :: < $ crate :: prisma :: guild_voice_sessions :: SelectParam > :: into ($ crate :: prisma :: guild_voice_sessions :: channel_id :: Select) } ; (@ selection_field_to_selection_param ; started_at) => { Into :: < $ crate :: prisma :: guild_voice_sessions :: SelectParam > :: into ($ crate :: prisma :: guild_voice_sessions :: started_at :: Select) } ; (@ selection_field_to_selection_param ; ended_at) => { Into :: < $ crate :: prisma :: guild_voice_sessions :: SelectParam > :: into ($ crate :: prisma :: guild_voice_sessions :: ended_at :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: guild_voice_sessions :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; session_id) => { "session_id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; channel_id) => { "channel_id" } ; (@ field_serde_name ; started_at) => { "started_at" } ; (@ field_serde_name ; ended_at) => { "ended_at" } ; }
    pub use _select_guild_voice_sessions as select;
    pub enum SelectParam {
        Id(id::Select),
        SessionId(session_id::Select),
        UserId(user_id::Select),
        GuildId(guild_id::Select),
        ChannelId(channel_id::Select),
        StartedAt(started_at::Select),
        EndedAt(ended_at::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::SessionId(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::ChannelId(data) => data.to_selection(),
                Self::StartedAt(data) => data.to_selection(),
                Self::EndedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_guild_voice_sessions { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: guild_voice_sessions :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: guild_voice_sessions :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: guild_voice_sessions :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: guild_voice_sessions :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: guild_voice_sessions :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: guild_voice_sessions :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: guild_voice_sessions :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: guild_voice_sessions :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub session_id : String , pub user_id : i64 , pub guild_id : i64 , pub channel_id : i64 , pub started_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub ended_at : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , $ (pub $ field : $ crate :: prisma :: guild_voice_sessions :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (session_id) , stringify ! (user_id) , stringify ! (guild_id) , stringify ! (channel_id) , stringify ! (started_at) , stringify ! (ended_at)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; session_id) , & self . session_id) ? ; state . serialize_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; user_id) , & self . user_id) ? ; state . serialize_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; guild_id) , & self . guild_id) ? ; state . serialize_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; channel_id) , & self . channel_id) ? ; state . serialize_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; started_at) , & self . started_at) ? ; state . serialize_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; ended_at) , & self . ended_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , session_id , user_id , guild_id , channel_id , started_at , ended_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; session_id) , ", " , $ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; user_id) , ", " , $ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; guild_id) , ", " , $ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; channel_id) , ", " , $ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; started_at) , ", " , $ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; ended_at) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; session_id) => Ok (Field :: session_id) , $ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; user_id) => Ok (Field :: user_id) , $ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; guild_id) => Ok (Field :: guild_id) , $ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; channel_id) => Ok (Field :: channel_id) , $ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; started_at) => Ok (Field :: started_at) , $ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; ended_at) => Ok (Field :: ended_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut session_id = None ; let mut user_id = None ; let mut guild_id = None ; let mut channel_id = None ; let mut started_at = None ; let mut ended_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: session_id => { if session_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; session_id))) ; } session_id = Some (map . next_value () ?) ; } Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; user_id))) ; } user_id = Some (map . next_value () ?) ; } Field :: guild_id => { if guild_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; guild_id))) ; } guild_id = Some (map . next_value () ?) ; } Field :: channel_id => { if channel_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; channel_id))) ; } channel_id = Some (map . next_value () ?) ; } Field :: started_at => { if started_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; started_at))) ; } started_at = Some (map . next_value () ?) ; } Field :: ended_at => { if ended_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; ended_at))) ; } ended_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; id))) ? ; let session_id = session_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; session_id))) ? ; let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; user_id))) ? ; let guild_id = guild_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; guild_id))) ? ; let channel_id = channel_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; channel_id))) ? ; let started_at = started_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; started_at))) ? ; let ended_at = ended_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guild_voice_sessions :: include ! (@ field_serde_name ; ended_at))) ? ; Ok (Data { id , session_id , user_id , guild_id , channel_id , started_at , ended_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "session_id" , "user_id" , "guild_id" , "channel_id" , "started_at" , "ended_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: guild_voice_sessions :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "GuildVoiceSessions" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: guild_voice_sessions :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; session_id) => { "session_id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; channel_id) => { "channel_id" } ; (@ field_serde_name ; started_at) => { "started_at" } ; (@ field_serde_name ; ended_at) => { "ended_at" } ; }
    pub use _include_guild_voice_sessions as include;
    pub enum IncludeParam {
        Id(id::Include),
        SessionId(session_id::Include),
        UserId(user_id::Include),
        GuildId(guild_id::Include),
        ChannelId(channel_id::Include),
        StartedAt(started_at::Include),
        EndedAt(ended_at::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::SessionId(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::ChannelId(data) => data.to_selection(),
                Self::StartedAt(data) => data.to_selection(),
                Self::EndedAt(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "session_id")]
        pub session_id: String,
        #[serde(rename = "user_id")]
        pub user_id: i64,
        #[serde(rename = "guild_id")]
        pub guild_id: i64,
        #[serde(rename = "channel_id")]
        pub channel_id: i64,
        #[serde(rename = "started_at")]
        pub started_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "ended_at")]
        pub ended_at: Option<
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        >,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetSessionId(String),
        SetUserId(i64),
        IncrementUserId(i64),
        DecrementUserId(i64),
        MultiplyUserId(i64),
        DivideUserId(i64),
        SetGuildId(i64),
        IncrementGuildId(i64),
        DecrementGuildId(i64),
        MultiplyGuildId(i64),
        DivideGuildId(i64),
        SetChannelId(i64),
        IncrementChannelId(i64),
        DecrementChannelId(i64),
        MultiplyChannelId(i64),
        DivideChannelId(i64),
        SetStartedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetEndedAt(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetSessionId(value) => (
                    "session_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetChannelId(value) => (
                    "channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementChannelId(value) => (
                    "channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementChannelId(value) => (
                    "channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyChannelId(value) => (
                    "channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideChannelId(value) => (
                    "channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetStartedAt(value) => (
                    "started_at".to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetEndedAt(value) => (
                    "ended_at".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        SessionId(::prisma_client_rust::Direction),
        UserId(::prisma_client_rust::Direction),
        GuildId(::prisma_client_rust::Direction),
        ChannelId(::prisma_client_rust::Direction),
        StartedAt(::prisma_client_rust::Direction),
        EndedAt(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::SessionId(direction) => (
                    "session_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::GuildId(direction) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ChannelId(direction) => (
                    "channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::StartedAt(direction) => (
                    "started_at".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::EndedAt(direction) => (
                    "ended_at".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        SessionIdUserIdGuildIdChannelIdStartedAtEndedAtEquals(
            String,
            i64,
            i64,
            i64,
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        IdEquals(i32),
        Id(_prisma::read_filters::IntFilter),
        SessionIdEquals(String),
        SessionId(_prisma::read_filters::StringFilter),
        UserIdEquals(i64),
        UserId(_prisma::read_filters::BigIntFilter),
        GuildIdEquals(i64),
        GuildId(_prisma::read_filters::BigIntFilter),
        ChannelIdEquals(i64),
        ChannelId(_prisma::read_filters::BigIntFilter),
        StartedAtEquals(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        StartedAt(_prisma::read_filters::DateTimeFilter),
        EndedAtEquals(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
        EndedAt(_prisma::read_filters::DateTimeFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::SessionIdUserIdGuildIdChannelIdStartedAtEndedAtEquals(
                    session_id,
                    user_id,
                    guild_id,
                    channel_id,
                    started_at,
                    ended_at,
                ) => (
                    "session_id_user_id_guild_id_channel_id_started_at_ended_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            "session_id".to_string(),
                            ::prisma_client_rust::PrismaValue::String(session_id),
                        ),
                        (
                            "user_id".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(user_id),
                        ),
                        (
                            "guild_id".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(guild_id),
                        ),
                        (
                            "channel_id".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(channel_id),
                        ),
                        (
                            "started_at".to_string(),
                            ::prisma_client_rust::PrismaValue::DateTime(started_at),
                        ),
                        (
                            "ended_at".to_string(),
                            ::prisma_client_rust::PrismaValue::DateTime(ended_at),
                        ),
                    ]),
                ),
                Self::IdEquals(value) => (
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::Id(value) => ("id", value.into()),
                Self::SessionIdEquals(value) => (
                    "session_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::SessionId(value) => ("session_id", value.into()),
                Self::UserIdEquals(value) => (
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::UserId(value) => ("user_id", value.into()),
                Self::GuildIdEquals(value) => (
                    "guild_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::GuildId(value) => ("guild_id", value.into()),
                Self::ChannelIdEquals(value) => (
                    "channel_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::ChannelId(value) => ("channel_id", value.into()),
                Self::StartedAtEquals(value) => (
                    "started_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::StartedAt(value) => ("started_at", value.into()),
                Self::EndedAtEquals(value) => (
                    "ended_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::EndedAt(value) => ("ended_at", value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        SessionIdUserIdGuildIdChannelIdStartedAtEndedAtEquals(
            String,
            i64,
            i64,
            i64,
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::SessionIdUserIdGuildIdChannelIdStartedAtEndedAtEquals(
                    session_id,
                    user_id,
                    guild_id,
                    channel_id,
                    started_at,
                    ended_at,
                ) => Self::SessionIdUserIdGuildIdChannelIdStartedAtEndedAtEquals(
                    session_id, user_id, guild_id, channel_id, started_at, ended_at,
                ),
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "guild_voice_sessions";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            [
                "id",
                "session_id",
                "user_id",
                "guild_id",
                "channel_id",
                "started_at",
                "ended_at",
            ]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            session_id: String,
            user_id: i64,
            guild_id: i64,
            channel_id: i64,
            started_at: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(session_id::set(session_id));
            _params.push(user_id::set(user_id));
            _params.push(guild_id::set(guild_id));
            _params.push(channel_id::set(channel_id));
            _params.push(started_at::set(started_at));
            Create::new(self.client, _params)
        }
        pub fn create_many(
            self,
            data: Vec<(
                String,
                i64,
                i64,
                i64,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(session_id, user_id, guild_id, channel_id, started_at, mut _params)| {
                        _params.push(session_id::set(session_id));
                        _params.push(user_id::set(user_id));
                        _params.push(guild_id::set(guild_id));
                        _params.push(channel_id::set(channel_id));
                        _params.push(started_at::set(started_at));
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (session_id, user_id, guild_id, channel_id, started_at, mut _params): (
                String,
                i64,
                i64,
                i64,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(session_id::set(session_id));
            _params.push(user_id::set(user_id));
            _params.push(guild_id::set(guild_id));
            _params.push(channel_id::set(channel_id));
            _params.push(started_at::set(started_at));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod guilds {
    use super::_prisma::*;
    use super::*;
    pub mod guild_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i64) -> T {
            UniqueWhereParam::GuildIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::GuildId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementGuildId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementGuildId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyGuildId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideGuildId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGuildId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GuildId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GuildId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
    }
    pub mod owner_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i64>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i64>) -> WhereParam {
            WhereParam::OwnerIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::OwnerId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::OwnerId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::OwnerId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::OwnerId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::OwnerId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::OwnerId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::OwnerId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::OwnerId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementOwnerId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementOwnerId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyOwnerId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideOwnerId(value)
        }
        pub struct Set(pub Option<i64>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetOwnerId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::OwnerId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("owner_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::OwnerId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("owner_id").build()
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::NameEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetName(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("name").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("name").build()
            }
        }
    }
    pub mod icon {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::IconEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Icon(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Icon(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Icon(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Icon(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Icon(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Icon(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Icon(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Icon(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Icon(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Icon(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Icon(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Icon(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetIcon(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Icon(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("icon").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Icon(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("icon").build()
            }
        }
    }
    pub mod splash {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::SplashEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Splash(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Splash(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Splash(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Splash(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Splash(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Splash(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Splash(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Splash(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Splash(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Splash(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Splash(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Splash(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetSplash(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Splash(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("splash").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Splash(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("splash").build()
            }
        }
    }
    pub mod region {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::RegionEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Region(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Region(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Region(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Region(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Region(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Region(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Region(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Region(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Region(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Region(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Region(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Region(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetRegion(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Region(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("region").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Region(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("region").build()
            }
        }
    }
    pub mod last_ban_sync {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::LastBanSyncEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::LastBanSync(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::LastBanSync(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::LastBanSync(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::LastBanSync(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::LastBanSync(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::LastBanSync(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::LastBanSync(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::LastBanSync(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(
            pub  Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetLastBanSync(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::LastBanSync(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("last_ban_sync").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::LastBanSync(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("last_ban_sync").build()
            }
        }
    }
    pub mod config {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<::prisma_client_rust::serde_json::Value>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<::prisma_client_rust::serde_json::Value>) -> WhereParam {
            WhereParam::ConfigEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Config(direction)
        }
        pub fn path(value: Vec<String>) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::JsonFilter::Path(value))
        }
        pub fn string_contains(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::JsonFilter::StringContains(value))
        }
        pub fn string_starts_with(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::JsonFilter::StringStartsWith(value))
        }
        pub fn string_ends_with(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::JsonFilter::StringEndsWith(value))
        }
        pub fn array_contains(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::JsonFilter::ArrayContains(value))
        }
        pub fn array_starts_with(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::JsonFilter::ArrayStartsWith(value))
        }
        pub fn array_ends_with(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::JsonFilter::ArrayEndsWith(value))
        }
        pub fn lt(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::JsonFilter::Lt(value))
        }
        pub fn lte(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::JsonFilter::Lte(value))
        }
        pub fn gt(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::JsonFilter::Gt(value))
        }
        pub fn gte(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::JsonFilter::Gte(value))
        }
        pub fn not(value: JsonNullValueFilter) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::JsonFilter::Not(value))
        }
        pub struct Set(pub Option<::prisma_client_rust::serde_json::Value>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetConfig(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Config(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("config").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Config(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("config").build()
            }
        }
    }
    pub mod config_raw {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<Vec<u8>>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<Vec<u8>>) -> WhereParam {
            WhereParam::ConfigRawEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ConfigRaw(direction)
        }
        pub fn in_vec(value: Vec<Vec<u8>>) -> WhereParam {
            WhereParam::ConfigRaw(_prisma::read_filters::BytesFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<Vec<u8>>) -> WhereParam {
            WhereParam::ConfigRaw(_prisma::read_filters::BytesFilter::NotInVec(value))
        }
        pub fn not(value: Vec<u8>) -> WhereParam {
            WhereParam::ConfigRaw(_prisma::read_filters::BytesFilter::Not(value))
        }
        pub struct Set(pub Option<Vec<u8>>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetConfigRaw(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ConfigRaw(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("config_raw").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ConfigRaw(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("config_raw").build()
            }
        }
    }
    pub mod enabled {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::EnabledEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Enabled(direction)
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEnabled(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Enabled(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("enabled").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Enabled(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("enabled").build()
            }
        }
    }
    pub mod whitelist {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: ::prisma_client_rust::serde_json::Value) -> T {
            Set(value).into()
        }
        pub fn equals(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::WhitelistEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Whitelist(direction)
        }
        pub fn path(value: Vec<String>) -> WhereParam {
            WhereParam::Whitelist(_prisma::read_filters::JsonFilter::Path(value))
        }
        pub fn string_contains(value: String) -> WhereParam {
            WhereParam::Whitelist(_prisma::read_filters::JsonFilter::StringContains(value))
        }
        pub fn string_starts_with(value: String) -> WhereParam {
            WhereParam::Whitelist(_prisma::read_filters::JsonFilter::StringStartsWith(value))
        }
        pub fn string_ends_with(value: String) -> WhereParam {
            WhereParam::Whitelist(_prisma::read_filters::JsonFilter::StringEndsWith(value))
        }
        pub fn array_contains(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Whitelist(_prisma::read_filters::JsonFilter::ArrayContains(value))
        }
        pub fn array_starts_with(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Whitelist(_prisma::read_filters::JsonFilter::ArrayStartsWith(value))
        }
        pub fn array_ends_with(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Whitelist(_prisma::read_filters::JsonFilter::ArrayEndsWith(value))
        }
        pub fn lt(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Whitelist(_prisma::read_filters::JsonFilter::Lt(value))
        }
        pub fn lte(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Whitelist(_prisma::read_filters::JsonFilter::Lte(value))
        }
        pub fn gt(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Whitelist(_prisma::read_filters::JsonFilter::Gt(value))
        }
        pub fn gte(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Whitelist(_prisma::read_filters::JsonFilter::Gte(value))
        }
        pub fn not(value: JsonNullValueFilter) -> WhereParam {
            WhereParam::Whitelist(_prisma::read_filters::JsonFilter::Not(value))
        }
        pub struct Set(pub ::prisma_client_rust::serde_json::Value);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetWhitelist(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Whitelist(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("whitelist").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Whitelist(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("whitelist").build()
            }
        }
    }
    pub mod added_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::AddedAtEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::AddedAt(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::AddedAt(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::AddedAt(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::AddedAt(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::AddedAt(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::AddedAt(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::AddedAt(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::AddedAt(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAddedAt(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AddedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("added_at").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AddedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("added_at").build()
            }
        }
    }
    pub fn create(
        guild_id: i64,
        enabled: bool,
        whitelist: ::prisma_client_rust::serde_json::Value,
        added_at: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        _params: Vec<SetParam>,
    ) -> (
        i64,
        bool,
        ::prisma_client_rust::serde_json::Value,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        Vec<SetParam>,
    ) {
        (guild_id, enabled, whitelist, added_at, _params)
    }
    pub fn create_unchecked(
        guild_id: i64,
        enabled: bool,
        whitelist: ::prisma_client_rust::serde_json::Value,
        added_at: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        _params: Vec<SetParam>,
    ) -> (
        i64,
        bool,
        ::prisma_client_rust::serde_json::Value,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        Vec<SetParam>,
    ) {
        (guild_id, enabled, whitelist, added_at, _params)
    }
    #[macro_export]
    macro_rules ! _select_guilds { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: guilds :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: guilds :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: guilds :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: guilds :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: guilds :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: guilds :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { guild_id , owner_id , name , icon , splash , region , last_ban_sync , config , config_raw , enabled , whitelist , added_at } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: guilds :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: guilds :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: guilds :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: guilds :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guilds :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guilds :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["guild_id" , "owner_id" , "name" , "icon" , "splash" , "region" , "last_ban_sync" , "config" , "config_raw" , "enabled" , "whitelist" , "added_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: guilds :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; guild_id) => { i64 } ; (@ field_type ; owner_id) => { Option < i64 > } ; (@ field_type ; name) => { Option < String > } ; (@ field_type ; icon) => { Option < String > } ; (@ field_type ; splash) => { Option < String > } ; (@ field_type ; region) => { Option < String > } ; (@ field_type ; last_ban_sync) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; config) => { Option < :: prisma_client_rust :: serde_json :: Value > } ; (@ field_type ; config_raw) => { Option < Vec < u8 > > } ; (@ field_type ; enabled) => { bool } ; (@ field_type ; whitelist) => { :: prisma_client_rust :: serde_json :: Value } ; (@ field_type ; added_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Guilds" , available fields are "guild_id, owner_id, name, icon, splash, region, last_ban_sync, config, config_raw, enabled, whitelist, added_at")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; guild_id) => { Into :: < $ crate :: prisma :: guilds :: SelectParam > :: into ($ crate :: prisma :: guilds :: guild_id :: Select) } ; (@ selection_field_to_selection_param ; owner_id) => { Into :: < $ crate :: prisma :: guilds :: SelectParam > :: into ($ crate :: prisma :: guilds :: owner_id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < $ crate :: prisma :: guilds :: SelectParam > :: into ($ crate :: prisma :: guilds :: name :: Select) } ; (@ selection_field_to_selection_param ; icon) => { Into :: < $ crate :: prisma :: guilds :: SelectParam > :: into ($ crate :: prisma :: guilds :: icon :: Select) } ; (@ selection_field_to_selection_param ; splash) => { Into :: < $ crate :: prisma :: guilds :: SelectParam > :: into ($ crate :: prisma :: guilds :: splash :: Select) } ; (@ selection_field_to_selection_param ; region) => { Into :: < $ crate :: prisma :: guilds :: SelectParam > :: into ($ crate :: prisma :: guilds :: region :: Select) } ; (@ selection_field_to_selection_param ; last_ban_sync) => { Into :: < $ crate :: prisma :: guilds :: SelectParam > :: into ($ crate :: prisma :: guilds :: last_ban_sync :: Select) } ; (@ selection_field_to_selection_param ; config) => { Into :: < $ crate :: prisma :: guilds :: SelectParam > :: into ($ crate :: prisma :: guilds :: config :: Select) } ; (@ selection_field_to_selection_param ; config_raw) => { Into :: < $ crate :: prisma :: guilds :: SelectParam > :: into ($ crate :: prisma :: guilds :: config_raw :: Select) } ; (@ selection_field_to_selection_param ; enabled) => { Into :: < $ crate :: prisma :: guilds :: SelectParam > :: into ($ crate :: prisma :: guilds :: enabled :: Select) } ; (@ selection_field_to_selection_param ; whitelist) => { Into :: < $ crate :: prisma :: guilds :: SelectParam > :: into ($ crate :: prisma :: guilds :: whitelist :: Select) } ; (@ selection_field_to_selection_param ; added_at) => { Into :: < $ crate :: prisma :: guilds :: SelectParam > :: into ($ crate :: prisma :: guilds :: added_at :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: guilds :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; owner_id) => { "owner_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; icon) => { "icon" } ; (@ field_serde_name ; splash) => { "splash" } ; (@ field_serde_name ; region) => { "region" } ; (@ field_serde_name ; last_ban_sync) => { "last_ban_sync" } ; (@ field_serde_name ; config) => { "config" } ; (@ field_serde_name ; config_raw) => { "config_raw" } ; (@ field_serde_name ; enabled) => { "enabled" } ; (@ field_serde_name ; whitelist) => { "whitelist" } ; (@ field_serde_name ; added_at) => { "added_at" } ; }
    pub use _select_guilds as select;
    pub enum SelectParam {
        GuildId(guild_id::Select),
        OwnerId(owner_id::Select),
        Name(name::Select),
        Icon(icon::Select),
        Splash(splash::Select),
        Region(region::Select),
        LastBanSync(last_ban_sync::Select),
        Config(config::Select),
        ConfigRaw(config_raw::Select),
        Enabled(enabled::Select),
        Whitelist(whitelist::Select),
        AddedAt(added_at::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::GuildId(data) => data.to_selection(),
                Self::OwnerId(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Icon(data) => data.to_selection(),
                Self::Splash(data) => data.to_selection(),
                Self::Region(data) => data.to_selection(),
                Self::LastBanSync(data) => data.to_selection(),
                Self::Config(data) => data.to_selection(),
                Self::ConfigRaw(data) => data.to_selection(),
                Self::Enabled(data) => data.to_selection(),
                Self::Whitelist(data) => data.to_selection(),
                Self::AddedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_guilds { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: guilds :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: guilds :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: guilds :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: guilds :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: guilds :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: guilds :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: guilds :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: guilds :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub guild_id : i64 , pub owner_id : Option < i64 > , pub name : Option < String > , pub icon : Option < String > , pub splash : Option < String > , pub region : Option < String > , pub last_ban_sync : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , pub config : Option < :: prisma_client_rust :: serde_json :: Value > , pub config_raw : Option < Vec < u8 > > , pub enabled : bool , pub whitelist : :: prisma_client_rust :: serde_json :: Value , pub added_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : $ crate :: prisma :: guilds :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (guild_id) , stringify ! (owner_id) , stringify ! (name) , stringify ! (icon) , stringify ! (splash) , stringify ! (region) , stringify ! (last_ban_sync) , stringify ! (config) , stringify ! (config_raw) , stringify ! (enabled) , stringify ! (whitelist) , stringify ! (added_at)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; guild_id) , & self . guild_id) ? ; state . serialize_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; owner_id) , & self . owner_id) ? ; state . serialize_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; name) , & self . name) ? ; state . serialize_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; icon) , & self . icon) ? ; state . serialize_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; splash) , & self . splash) ? ; state . serialize_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; region) , & self . region) ? ; state . serialize_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; last_ban_sync) , & self . last_ban_sync) ? ; state . serialize_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; config) , & self . config) ? ; state . serialize_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; config_raw) , & self . config_raw) ? ; state . serialize_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; enabled) , & self . enabled) ? ; state . serialize_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; whitelist) , & self . whitelist) ? ; state . serialize_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; added_at) , & self . added_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , guild_id , owner_id , name , icon , splash , region , last_ban_sync , config , config_raw , enabled , whitelist , added_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; guild_id) , ", " , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; owner_id) , ", " , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; name) , ", " , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; icon) , ", " , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; splash) , ", " , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; region) , ", " , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; last_ban_sync) , ", " , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; config) , ", " , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; config_raw) , ", " , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; enabled) , ", " , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; whitelist) , ", " , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; added_at) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; guild_id) => Ok (Field :: guild_id) , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; owner_id) => Ok (Field :: owner_id) , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; name) => Ok (Field :: name) , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; icon) => Ok (Field :: icon) , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; splash) => Ok (Field :: splash) , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; region) => Ok (Field :: region) , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; last_ban_sync) => Ok (Field :: last_ban_sync) , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; config) => Ok (Field :: config) , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; config_raw) => Ok (Field :: config_raw) , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; enabled) => Ok (Field :: enabled) , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; whitelist) => Ok (Field :: whitelist) , $ crate :: prisma :: guilds :: include ! (@ field_serde_name ; added_at) => Ok (Field :: added_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut guild_id = None ; let mut owner_id = None ; let mut name = None ; let mut icon = None ; let mut splash = None ; let mut region = None ; let mut last_ban_sync = None ; let mut config = None ; let mut config_raw = None ; let mut enabled = None ; let mut whitelist = None ; let mut added_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: guild_id => { if guild_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; guild_id))) ; } guild_id = Some (map . next_value () ?) ; } Field :: owner_id => { if owner_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; owner_id))) ; } owner_id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; name))) ; } name = Some (map . next_value () ?) ; } Field :: icon => { if icon . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; icon))) ; } icon = Some (map . next_value () ?) ; } Field :: splash => { if splash . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; splash))) ; } splash = Some (map . next_value () ?) ; } Field :: region => { if region . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; region))) ; } region = Some (map . next_value () ?) ; } Field :: last_ban_sync => { if last_ban_sync . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; last_ban_sync))) ; } last_ban_sync = Some (map . next_value () ?) ; } Field :: config => { if config . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; config))) ; } config = Some (map . next_value () ?) ; } Field :: config_raw => { if config_raw . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; config_raw))) ; } config_raw = Some (map . next_value () ?) ; } Field :: enabled => { if enabled . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; enabled))) ; } enabled = Some (map . next_value () ?) ; } Field :: whitelist => { if whitelist . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; whitelist))) ; } whitelist = Some (map . next_value () ?) ; } Field :: added_at => { if added_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; added_at))) ; } added_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; $ field))) ? ;) * let guild_id = guild_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; guild_id))) ? ; let owner_id = owner_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; owner_id))) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; name))) ? ; let icon = icon . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; icon))) ? ; let splash = splash . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; splash))) ? ; let region = region . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; region))) ? ; let last_ban_sync = last_ban_sync . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; last_ban_sync))) ? ; let config = config . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; config))) ? ; let config_raw = config_raw . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; config_raw))) ? ; let enabled = enabled . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; enabled))) ? ; let whitelist = whitelist . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; whitelist))) ? ; let added_at = added_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: guilds :: include ! (@ field_serde_name ; added_at))) ? ; Ok (Data { guild_id , owner_id , name , icon , splash , region , last_ban_sync , config , config_raw , enabled , whitelist , added_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["guild_id" , "owner_id" , "name" , "icon" , "splash" , "region" , "last_ban_sync" , "config" , "config_raw" , "enabled" , "whitelist" , "added_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: guilds :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Guilds" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: guilds :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; owner_id) => { "owner_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; icon) => { "icon" } ; (@ field_serde_name ; splash) => { "splash" } ; (@ field_serde_name ; region) => { "region" } ; (@ field_serde_name ; last_ban_sync) => { "last_ban_sync" } ; (@ field_serde_name ; config) => { "config" } ; (@ field_serde_name ; config_raw) => { "config_raw" } ; (@ field_serde_name ; enabled) => { "enabled" } ; (@ field_serde_name ; whitelist) => { "whitelist" } ; (@ field_serde_name ; added_at) => { "added_at" } ; }
    pub use _include_guilds as include;
    pub enum IncludeParam {
        GuildId(guild_id::Include),
        OwnerId(owner_id::Include),
        Name(name::Include),
        Icon(icon::Include),
        Splash(splash::Include),
        Region(region::Include),
        LastBanSync(last_ban_sync::Include),
        Config(config::Include),
        ConfigRaw(config_raw::Include),
        Enabled(enabled::Include),
        Whitelist(whitelist::Include),
        AddedAt(added_at::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::GuildId(data) => data.to_selection(),
                Self::OwnerId(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Icon(data) => data.to_selection(),
                Self::Splash(data) => data.to_selection(),
                Self::Region(data) => data.to_selection(),
                Self::LastBanSync(data) => data.to_selection(),
                Self::Config(data) => data.to_selection(),
                Self::ConfigRaw(data) => data.to_selection(),
                Self::Enabled(data) => data.to_selection(),
                Self::Whitelist(data) => data.to_selection(),
                Self::AddedAt(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "guild_id")]
        pub guild_id: i64,
        #[serde(rename = "owner_id")]
        pub owner_id: Option<i64>,
        #[serde(rename = "name")]
        pub name: Option<String>,
        #[serde(rename = "icon")]
        pub icon: Option<String>,
        #[serde(rename = "splash")]
        pub splash: Option<String>,
        #[serde(rename = "region")]
        pub region: Option<String>,
        #[serde(rename = "last_ban_sync")]
        pub last_ban_sync: Option<
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        >,
        #[serde(rename = "config")]
        pub config: Option<::prisma_client_rust::serde_json::Value>,
        #[serde(rename = "config_raw")]
        pub config_raw: Option<Vec<u8>>,
        #[serde(rename = "enabled")]
        pub enabled: bool,
        #[serde(rename = "whitelist")]
        pub whitelist: ::prisma_client_rust::serde_json::Value,
        #[serde(rename = "added_at")]
        pub added_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetGuildId(i64),
        IncrementGuildId(i64),
        DecrementGuildId(i64),
        MultiplyGuildId(i64),
        DivideGuildId(i64),
        SetOwnerId(Option<i64>),
        IncrementOwnerId(i64),
        DecrementOwnerId(i64),
        MultiplyOwnerId(i64),
        DivideOwnerId(i64),
        SetName(Option<String>),
        SetIcon(Option<String>),
        SetSplash(Option<String>),
        SetRegion(Option<String>),
        SetLastBanSync(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
        SetConfig(Option<::prisma_client_rust::serde_json::Value>),
        SetConfigRaw(Option<Vec<u8>>),
        SetEnabled(bool),
        SetWhitelist(::prisma_client_rust::serde_json::Value),
        SetAddedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetOwnerId(value) => (
                    "owner_id".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementOwnerId(value) => (
                    "owner_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementOwnerId(value) => (
                    "owner_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyOwnerId(value) => (
                    "owner_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideOwnerId(value) => (
                    "owner_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetName(value) => (
                    "name".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetIcon(value) => (
                    "icon".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetSplash(value) => (
                    "splash".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetRegion(value) => (
                    "region".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetLastBanSync(value) => (
                    "last_ban_sync".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetConfig(value) => (
                    "config".to_string(),
                    value
                        .map(|value| {
                            ::prisma_client_rust::PrismaValue::Json(
                                serde_json::to_string(&value).unwrap(),
                            )
                        })
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetConfigRaw(value) => (
                    "config_raw".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetEnabled(value) => (
                    "enabled".to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetWhitelist(value) => (
                    "whitelist".to_string(),
                    ::prisma_client_rust::PrismaValue::Json(serde_json::to_string(&value).unwrap()),
                ),
                SetParam::SetAddedAt(value) => (
                    "added_at".to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        GuildId(::prisma_client_rust::Direction),
        OwnerId(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        Icon(::prisma_client_rust::Direction),
        Splash(::prisma_client_rust::Direction),
        Region(::prisma_client_rust::Direction),
        LastBanSync(::prisma_client_rust::Direction),
        Config(::prisma_client_rust::Direction),
        ConfigRaw(::prisma_client_rust::Direction),
        Enabled(::prisma_client_rust::Direction),
        Whitelist(::prisma_client_rust::Direction),
        AddedAt(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::GuildId(direction) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::OwnerId(direction) => (
                    "owner_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    "name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Icon(direction) => (
                    "icon".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Splash(direction) => (
                    "splash".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Region(direction) => (
                    "region".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::LastBanSync(direction) => (
                    "last_ban_sync".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Config(direction) => (
                    "config".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ConfigRaw(direction) => (
                    "config_raw".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Enabled(direction) => (
                    "enabled".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Whitelist(direction) => (
                    "whitelist".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::AddedAt(direction) => (
                    "added_at".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        GuildIdEquals(i64),
        GuildId(_prisma::read_filters::BigIntFilter),
        OwnerIdEquals(Option<i64>),
        OwnerId(_prisma::read_filters::BigIntFilter),
        NameEquals(Option<String>),
        Name(_prisma::read_filters::StringFilter),
        IconEquals(Option<String>),
        Icon(_prisma::read_filters::StringFilter),
        SplashEquals(Option<String>),
        Splash(_prisma::read_filters::StringFilter),
        RegionEquals(Option<String>),
        Region(_prisma::read_filters::StringFilter),
        LastBanSyncEquals(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
        LastBanSync(_prisma::read_filters::DateTimeFilter),
        ConfigEquals(Option<::prisma_client_rust::serde_json::Value>),
        Config(_prisma::read_filters::JsonFilter),
        ConfigRawEquals(Option<Vec<u8>>),
        ConfigRaw(_prisma::read_filters::BytesFilter),
        EnabledEquals(bool),
        WhitelistEquals(::prisma_client_rust::serde_json::Value),
        Whitelist(_prisma::read_filters::JsonFilter),
        AddedAtEquals(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        AddedAt(_prisma::read_filters::DateTimeFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::GuildIdEquals(value) => (
                    "guild_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::GuildId(value) => ("guild_id", value.into()),
                Self::OwnerIdEquals(value) => (
                    "owner_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::OwnerId(value) => ("owner_id", value.into()),
                Self::NameEquals(value) => (
                    "name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::Name(value) => ("name", value.into()),
                Self::IconEquals(value) => (
                    "icon",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::Icon(value) => ("icon", value.into()),
                Self::SplashEquals(value) => (
                    "splash",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::Splash(value) => ("splash", value.into()),
                Self::RegionEquals(value) => (
                    "region",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::Region(value) => ("region", value.into()),
                Self::LastBanSyncEquals(value) => (
                    "last_ban_sync",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::LastBanSync(value) => ("last_ban_sync", value.into()),
                Self::ConfigEquals(value) => (
                    "config",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| {
                                ::prisma_client_rust::PrismaValue::Json(
                                    serde_json::to_string(&value).unwrap(),
                                )
                            })
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::Config(value) => ("config", value.into()),
                Self::ConfigRawEquals(value) => (
                    "config_raw",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::ConfigRaw(value) => ("config_raw", value.into()),
                Self::EnabledEquals(value) => (
                    "enabled",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                ),
                Self::WhitelistEquals(value) => (
                    "whitelist",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Json(
                            serde_json::to_string(&value).unwrap(),
                        ),
                    )]),
                ),
                Self::Whitelist(value) => ("whitelist", value.into()),
                Self::AddedAtEquals(value) => (
                    "added_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::AddedAt(value) => ("added_at", value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        GuildIdEquals(i64),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::GuildIdEquals(value) => Self::GuildIdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "Guilds";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            [
                "guild_id",
                "owner_id",
                "name",
                "icon",
                "splash",
                "region",
                "last_ban_sync",
                "config",
                "config_raw",
                "enabled",
                "whitelist",
                "added_at",
            ]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            guild_id: i64,
            enabled: bool,
            whitelist: ::prisma_client_rust::serde_json::Value,
            added_at: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(guild_id::set(guild_id));
            _params.push(enabled::set(enabled));
            _params.push(whitelist::set(whitelist));
            _params.push(added_at::set(added_at));
            Create::new(self.client, _params)
        }
        pub fn create_many(
            self,
            data: Vec<(
                i64,
                bool,
                ::prisma_client_rust::serde_json::Value,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(guild_id, enabled, whitelist, added_at, mut _params)| {
                    _params.push(guild_id::set(guild_id));
                    _params.push(enabled::set(enabled));
                    _params.push(whitelist::set(whitelist));
                    _params.push(added_at::set(added_at));
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (guild_id, enabled, whitelist, added_at, mut _params): (
                i64,
                bool,
                ::prisma_client_rust::serde_json::Value,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(guild_id::set(guild_id));
            _params.push(enabled::set(enabled));
            _params.push(whitelist::set(whitelist));
            _params.push(added_at::set(added_at));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod infractions {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::NotInVec(value))
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Lt(value))
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Lte(value))
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Gt(value))
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Gte(value))
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Not(value))
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod guild_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::GuildIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::GuildId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementGuildId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementGuildId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyGuildId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideGuildId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGuildId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GuildId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GuildId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementUserId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementUserId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyUserId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideUserId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("user_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("user_id").build()
            }
        }
    }
    pub mod actor_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i64>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i64>) -> WhereParam {
            WhereParam::ActorIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ActorId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementActorId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementActorId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyActorId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideActorId(value)
        }
        pub struct Set(pub Option<i64>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetActorId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ActorId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("actor_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ActorId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("actor_id").build()
            }
        }
    }
    pub mod kind {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::KindEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Kind(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::IntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::IntFilter::NotInVec(value))
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::IntFilter::Lt(value))
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::IntFilter::Lte(value))
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::IntFilter::Gt(value))
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::IntFilter::Gte(value))
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::IntFilter::Not(value))
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementKind(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementKind(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyKind(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideKind(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetKind(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Kind(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("kind").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Kind(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("kind").build()
            }
        }
    }
    pub mod reason {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::ReasonEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Reason(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Reason(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetReason(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Reason(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("reason").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Reason(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("reason").build()
            }
        }
    }
    pub mod metadata {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: ::prisma_client_rust::serde_json::Value) -> T {
            Set(value).into()
        }
        pub fn equals(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::MetadataEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Metadata(direction)
        }
        pub fn path(value: Vec<String>) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::Path(value))
        }
        pub fn string_contains(value: String) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::StringContains(value))
        }
        pub fn string_starts_with(value: String) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::StringStartsWith(value))
        }
        pub fn string_ends_with(value: String) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::StringEndsWith(value))
        }
        pub fn array_contains(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::ArrayContains(value))
        }
        pub fn array_starts_with(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::ArrayStartsWith(value))
        }
        pub fn array_ends_with(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::ArrayEndsWith(value))
        }
        pub fn lt(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::Lt(value))
        }
        pub fn lte(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::Lte(value))
        }
        pub fn gt(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::Gt(value))
        }
        pub fn gte(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::Gte(value))
        }
        pub fn not(value: JsonNullValueFilter) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::Not(value))
        }
        pub struct Set(pub ::prisma_client_rust::serde_json::Value);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetMetadata(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Metadata(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("metadata").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Metadata(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("metadata").build()
            }
        }
    }
    pub mod expires_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::ExpiresAtEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ExpiresAt(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::ExpiresAt(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::ExpiresAt(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::ExpiresAt(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::ExpiresAt(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::ExpiresAt(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::ExpiresAt(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::ExpiresAt(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(
            pub  Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetExpiresAt(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ExpiresAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("expires_at").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ExpiresAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("expires_at").build()
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_at").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_at").build()
            }
        }
    }
    pub mod active {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::ActiveEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Active(direction)
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetActive(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Active(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("active").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Active(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("active").build()
            }
        }
    }
    pub mod messaged {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<bool>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<bool>) -> WhereParam {
            WhereParam::MessagedEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Messaged(direction)
        }
        pub struct Set(pub Option<bool>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetMessaged(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Messaged(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("messaged").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Messaged(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("messaged").build()
            }
        }
    }
    pub fn create(
        guild_id: i64,
        user_id: i64,
        kind: i32,
        metadata: ::prisma_client_rust::serde_json::Value,
        created_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        active: bool,
        _params: Vec<SetParam>,
    ) -> (
        i64,
        i64,
        i32,
        ::prisma_client_rust::serde_json::Value,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        bool,
        Vec<SetParam>,
    ) {
        (
            guild_id, user_id, kind, metadata, created_at, active, _params,
        )
    }
    pub fn create_unchecked(
        guild_id: i64,
        user_id: i64,
        kind: i32,
        metadata: ::prisma_client_rust::serde_json::Value,
        created_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        active: bool,
        _params: Vec<SetParam>,
    ) -> (
        i64,
        i64,
        i32,
        ::prisma_client_rust::serde_json::Value,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        bool,
        Vec<SetParam>,
    ) {
        (
            guild_id, user_id, kind, metadata, created_at, active, _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_infractions { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: infractions :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: infractions :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: infractions :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: infractions :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: infractions :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: infractions :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , guild_id , user_id , actor_id , kind , reason , metadata , expires_at , created_at , active , messaged } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: infractions :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: infractions :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: infractions :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: infractions :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: infractions :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: infractions :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "guild_id" , "user_id" , "actor_id" , "kind" , "reason" , "metadata" , "expires_at" , "created_at" , "active" , "messaged"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: infractions :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; guild_id) => { i64 } ; (@ field_type ; user_id) => { i64 } ; (@ field_type ; actor_id) => { Option < i64 > } ; (@ field_type ; kind) => { i32 } ; (@ field_type ; reason) => { Option < String > } ; (@ field_type ; metadata) => { :: prisma_client_rust :: serde_json :: Value } ; (@ field_type ; expires_at) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; active) => { bool } ; (@ field_type ; messaged) => { Option < bool > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Infractions" , available fields are "id, guild_id, user_id, actor_id, kind, reason, metadata, expires_at, created_at, active, messaged")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: infractions :: SelectParam > :: into ($ crate :: prisma :: infractions :: id :: Select) } ; (@ selection_field_to_selection_param ; guild_id) => { Into :: < $ crate :: prisma :: infractions :: SelectParam > :: into ($ crate :: prisma :: infractions :: guild_id :: Select) } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < $ crate :: prisma :: infractions :: SelectParam > :: into ($ crate :: prisma :: infractions :: user_id :: Select) } ; (@ selection_field_to_selection_param ; actor_id) => { Into :: < $ crate :: prisma :: infractions :: SelectParam > :: into ($ crate :: prisma :: infractions :: actor_id :: Select) } ; (@ selection_field_to_selection_param ; kind) => { Into :: < $ crate :: prisma :: infractions :: SelectParam > :: into ($ crate :: prisma :: infractions :: kind :: Select) } ; (@ selection_field_to_selection_param ; reason) => { Into :: < $ crate :: prisma :: infractions :: SelectParam > :: into ($ crate :: prisma :: infractions :: reason :: Select) } ; (@ selection_field_to_selection_param ; metadata) => { Into :: < $ crate :: prisma :: infractions :: SelectParam > :: into ($ crate :: prisma :: infractions :: metadata :: Select) } ; (@ selection_field_to_selection_param ; expires_at) => { Into :: < $ crate :: prisma :: infractions :: SelectParam > :: into ($ crate :: prisma :: infractions :: expires_at :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < $ crate :: prisma :: infractions :: SelectParam > :: into ($ crate :: prisma :: infractions :: created_at :: Select) } ; (@ selection_field_to_selection_param ; active) => { Into :: < $ crate :: prisma :: infractions :: SelectParam > :: into ($ crate :: prisma :: infractions :: active :: Select) } ; (@ selection_field_to_selection_param ; messaged) => { Into :: < $ crate :: prisma :: infractions :: SelectParam > :: into ($ crate :: prisma :: infractions :: messaged :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: infractions :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; actor_id) => { "actor_id" } ; (@ field_serde_name ; kind) => { "kind" } ; (@ field_serde_name ; reason) => { "reason" } ; (@ field_serde_name ; metadata) => { "metadata" } ; (@ field_serde_name ; expires_at) => { "expires_at" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; active) => { "active" } ; (@ field_serde_name ; messaged) => { "messaged" } ; }
    pub use _select_infractions as select;
    pub enum SelectParam {
        Id(id::Select),
        GuildId(guild_id::Select),
        UserId(user_id::Select),
        ActorId(actor_id::Select),
        Kind(kind::Select),
        Reason(reason::Select),
        Metadata(metadata::Select),
        ExpiresAt(expires_at::Select),
        CreatedAt(created_at::Select),
        Active(active::Select),
        Messaged(messaged::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::ActorId(data) => data.to_selection(),
                Self::Kind(data) => data.to_selection(),
                Self::Reason(data) => data.to_selection(),
                Self::Metadata(data) => data.to_selection(),
                Self::ExpiresAt(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Active(data) => data.to_selection(),
                Self::Messaged(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_infractions { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: infractions :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: infractions :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: infractions :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: infractions :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: infractions :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: infractions :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: infractions :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: infractions :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub guild_id : i64 , pub user_id : i64 , pub actor_id : Option < i64 > , pub kind : i32 , pub reason : Option < String > , pub metadata : :: prisma_client_rust :: serde_json :: Value , pub expires_at : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub active : bool , pub messaged : Option < bool > , $ (pub $ field : $ crate :: prisma :: infractions :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (guild_id) , stringify ! (user_id) , stringify ! (actor_id) , stringify ! (kind) , stringify ! (reason) , stringify ! (metadata) , stringify ! (expires_at) , stringify ! (created_at) , stringify ! (active) , stringify ! (messaged)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; guild_id) , & self . guild_id) ? ; state . serialize_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; user_id) , & self . user_id) ? ; state . serialize_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; actor_id) , & self . actor_id) ? ; state . serialize_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; kind) , & self . kind) ? ; state . serialize_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; reason) , & self . reason) ? ; state . serialize_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; metadata) , & self . metadata) ? ; state . serialize_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; expires_at) , & self . expires_at) ? ; state . serialize_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; created_at) , & self . created_at) ? ; state . serialize_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; active) , & self . active) ? ; state . serialize_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; messaged) , & self . messaged) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , guild_id , user_id , actor_id , kind , reason , metadata , expires_at , created_at , active , messaged } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; guild_id) , ", " , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; user_id) , ", " , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; actor_id) , ", " , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; kind) , ", " , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; reason) , ", " , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; metadata) , ", " , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; expires_at) , ", " , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; created_at) , ", " , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; active) , ", " , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; messaged) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; guild_id) => Ok (Field :: guild_id) , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; user_id) => Ok (Field :: user_id) , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; actor_id) => Ok (Field :: actor_id) , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; kind) => Ok (Field :: kind) , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; reason) => Ok (Field :: reason) , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; metadata) => Ok (Field :: metadata) , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; expires_at) => Ok (Field :: expires_at) , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; created_at) => Ok (Field :: created_at) , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; active) => Ok (Field :: active) , $ crate :: prisma :: infractions :: include ! (@ field_serde_name ; messaged) => Ok (Field :: messaged) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut guild_id = None ; let mut user_id = None ; let mut actor_id = None ; let mut kind = None ; let mut reason = None ; let mut metadata = None ; let mut expires_at = None ; let mut created_at = None ; let mut active = None ; let mut messaged = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: guild_id => { if guild_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; guild_id))) ; } guild_id = Some (map . next_value () ?) ; } Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; user_id))) ; } user_id = Some (map . next_value () ?) ; } Field :: actor_id => { if actor_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; actor_id))) ; } actor_id = Some (map . next_value () ?) ; } Field :: kind => { if kind . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; kind))) ; } kind = Some (map . next_value () ?) ; } Field :: reason => { if reason . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; reason))) ; } reason = Some (map . next_value () ?) ; } Field :: metadata => { if metadata . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; metadata))) ; } metadata = Some (map . next_value () ?) ; } Field :: expires_at => { if expires_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; expires_at))) ; } expires_at = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; created_at))) ; } created_at = Some (map . next_value () ?) ; } Field :: active => { if active . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; active))) ; } active = Some (map . next_value () ?) ; } Field :: messaged => { if messaged . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; messaged))) ; } messaged = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; id))) ? ; let guild_id = guild_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; guild_id))) ? ; let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; user_id))) ? ; let actor_id = actor_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; actor_id))) ? ; let kind = kind . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; kind))) ? ; let reason = reason . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; reason))) ? ; let metadata = metadata . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; metadata))) ? ; let expires_at = expires_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; expires_at))) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; created_at))) ? ; let active = active . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; active))) ? ; let messaged = messaged . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: infractions :: include ! (@ field_serde_name ; messaged))) ? ; Ok (Data { id , guild_id , user_id , actor_id , kind , reason , metadata , expires_at , created_at , active , messaged , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "guild_id" , "user_id" , "actor_id" , "kind" , "reason" , "metadata" , "expires_at" , "created_at" , "active" , "messaged"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: infractions :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Infractions" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: infractions :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; actor_id) => { "actor_id" } ; (@ field_serde_name ; kind) => { "kind" } ; (@ field_serde_name ; reason) => { "reason" } ; (@ field_serde_name ; metadata) => { "metadata" } ; (@ field_serde_name ; expires_at) => { "expires_at" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; active) => { "active" } ; (@ field_serde_name ; messaged) => { "messaged" } ; }
    pub use _include_infractions as include;
    pub enum IncludeParam {
        Id(id::Include),
        GuildId(guild_id::Include),
        UserId(user_id::Include),
        ActorId(actor_id::Include),
        Kind(kind::Include),
        Reason(reason::Include),
        Metadata(metadata::Include),
        ExpiresAt(expires_at::Include),
        CreatedAt(created_at::Include),
        Active(active::Include),
        Messaged(messaged::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::ActorId(data) => data.to_selection(),
                Self::Kind(data) => data.to_selection(),
                Self::Reason(data) => data.to_selection(),
                Self::Metadata(data) => data.to_selection(),
                Self::ExpiresAt(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Active(data) => data.to_selection(),
                Self::Messaged(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "guild_id")]
        pub guild_id: i64,
        #[serde(rename = "user_id")]
        pub user_id: i64,
        #[serde(rename = "actor_id")]
        pub actor_id: Option<i64>,
        #[serde(rename = "kind")]
        pub kind: i32,
        #[serde(rename = "reason")]
        pub reason: Option<String>,
        #[serde(rename = "metadata")]
        pub metadata: ::prisma_client_rust::serde_json::Value,
        #[serde(rename = "expires_at")]
        pub expires_at: Option<
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        >,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "active")]
        pub active: bool,
        #[serde(rename = "messaged")]
        pub messaged: Option<bool>,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetGuildId(i64),
        IncrementGuildId(i64),
        DecrementGuildId(i64),
        MultiplyGuildId(i64),
        DivideGuildId(i64),
        SetUserId(i64),
        IncrementUserId(i64),
        DecrementUserId(i64),
        MultiplyUserId(i64),
        DivideUserId(i64),
        SetActorId(Option<i64>),
        IncrementActorId(i64),
        DecrementActorId(i64),
        MultiplyActorId(i64),
        DivideActorId(i64),
        SetKind(i32),
        IncrementKind(i32),
        DecrementKind(i32),
        MultiplyKind(i32),
        DivideKind(i32),
        SetReason(Option<String>),
        SetMetadata(::prisma_client_rust::serde_json::Value),
        SetExpiresAt(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetActive(bool),
        SetMessaged(Option<bool>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetActorId(value) => (
                    "actor_id".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementActorId(value) => (
                    "actor_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementActorId(value) => (
                    "actor_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyActorId(value) => (
                    "actor_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideActorId(value) => (
                    "actor_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetKind(value) => (
                    "kind".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementKind(value) => (
                    "kind".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementKind(value) => (
                    "kind".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyKind(value) => (
                    "kind".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideKind(value) => (
                    "kind".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetReason(value) => (
                    "reason".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetMetadata(value) => (
                    "metadata".to_string(),
                    ::prisma_client_rust::PrismaValue::Json(serde_json::to_string(&value).unwrap()),
                ),
                SetParam::SetExpiresAt(value) => (
                    "expires_at".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetCreatedAt(value) => (
                    "created_at".to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetActive(value) => (
                    "active".to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetMessaged(value) => (
                    "messaged".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Boolean(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        GuildId(::prisma_client_rust::Direction),
        UserId(::prisma_client_rust::Direction),
        ActorId(::prisma_client_rust::Direction),
        Kind(::prisma_client_rust::Direction),
        Reason(::prisma_client_rust::Direction),
        Metadata(::prisma_client_rust::Direction),
        ExpiresAt(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        Active(::prisma_client_rust::Direction),
        Messaged(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::GuildId(direction) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ActorId(direction) => (
                    "actor_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Kind(direction) => (
                    "kind".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Reason(direction) => (
                    "reason".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Metadata(direction) => (
                    "metadata".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ExpiresAt(direction) => (
                    "expires_at".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    "created_at".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Active(direction) => (
                    "active".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Messaged(direction) => (
                    "messaged".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(i32),
        Id(_prisma::read_filters::IntFilter),
        GuildIdEquals(i64),
        GuildId(_prisma::read_filters::BigIntFilter),
        UserIdEquals(i64),
        UserId(_prisma::read_filters::BigIntFilter),
        ActorIdEquals(Option<i64>),
        ActorId(_prisma::read_filters::BigIntFilter),
        KindEquals(i32),
        Kind(_prisma::read_filters::IntFilter),
        ReasonEquals(Option<String>),
        Reason(_prisma::read_filters::StringFilter),
        MetadataEquals(::prisma_client_rust::serde_json::Value),
        Metadata(_prisma::read_filters::JsonFilter),
        ExpiresAtEquals(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
        ExpiresAt(_prisma::read_filters::DateTimeFilter),
        CreatedAtEquals(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        ActiveEquals(bool),
        MessagedEquals(Option<bool>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::Id(value) => ("id", value.into()),
                Self::GuildIdEquals(value) => (
                    "guild_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::GuildId(value) => ("guild_id", value.into()),
                Self::UserIdEquals(value) => (
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::UserId(value) => ("user_id", value.into()),
                Self::ActorIdEquals(value) => (
                    "actor_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::ActorId(value) => ("actor_id", value.into()),
                Self::KindEquals(value) => (
                    "kind",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::Kind(value) => ("kind", value.into()),
                Self::ReasonEquals(value) => (
                    "reason",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::Reason(value) => ("reason", value.into()),
                Self::MetadataEquals(value) => (
                    "metadata",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Json(
                            serde_json::to_string(&value).unwrap(),
                        ),
                    )]),
                ),
                Self::Metadata(value) => ("metadata", value.into()),
                Self::ExpiresAtEquals(value) => (
                    "expires_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::ExpiresAt(value) => ("expires_at", value.into()),
                Self::CreatedAtEquals(value) => (
                    "created_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAt(value) => ("created_at", value.into()),
                Self::ActiveEquals(value) => (
                    "active",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                ),
                Self::MessagedEquals(value) => (
                    "messaged",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::Boolean(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "infractions";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            [
                "id",
                "guild_id",
                "user_id",
                "actor_id",
                "kind",
                "reason",
                "metadata",
                "expires_at",
                "created_at",
                "active",
                "messaged",
            ]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            guild_id: i64,
            user_id: i64,
            kind: i32,
            metadata: ::prisma_client_rust::serde_json::Value,
            created_at: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            active: bool,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(guild_id::set(guild_id));
            _params.push(user_id::set(user_id));
            _params.push(kind::set(kind));
            _params.push(metadata::set(metadata));
            _params.push(created_at::set(created_at));
            _params.push(active::set(active));
            Create::new(self.client, _params)
        }
        pub fn create_many(
            self,
            data: Vec<(
                i64,
                i64,
                i32,
                ::prisma_client_rust::serde_json::Value,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                bool,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(guild_id, user_id, kind, metadata, created_at, active, mut _params)| {
                        _params.push(guild_id::set(guild_id));
                        _params.push(user_id::set(user_id));
                        _params.push(kind::set(kind));
                        _params.push(metadata::set(metadata));
                        _params.push(created_at::set(created_at));
                        _params.push(active::set(active));
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (guild_id, user_id, kind, metadata, created_at, active, mut _params): (
                i64,
                i64,
                i32,
                ::prisma_client_rust::serde_json::Value,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                bool,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(guild_id::set(guild_id));
            _params.push(user_id::set(user_id));
            _params.push(kind::set(kind));
            _params.push(metadata::set(metadata));
            _params.push(created_at::set(created_at));
            _params.push(active::set(active));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod message_archives {
    use super::_prisma::*;
    use super::*;
    pub mod archive_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::ArchiveIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ArchiveId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ArchiveId(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ArchiveId(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ArchiveId(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ArchiveId(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ArchiveId(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ArchiveId(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ArchiveId(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ArchiveId(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ArchiveId(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::ArchiveId(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ArchiveId(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetArchiveId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ArchiveId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("archive_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ArchiveId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("archive_id").build()
            }
        }
    }
    pub mod message_ids {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: ::prisma_client_rust::serde_json::Value) -> T {
            Set(value).into()
        }
        pub fn equals(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::MessageIdsEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::MessageIds(direction)
        }
        pub fn path(value: Vec<String>) -> WhereParam {
            WhereParam::MessageIds(_prisma::read_filters::JsonFilter::Path(value))
        }
        pub fn string_contains(value: String) -> WhereParam {
            WhereParam::MessageIds(_prisma::read_filters::JsonFilter::StringContains(value))
        }
        pub fn string_starts_with(value: String) -> WhereParam {
            WhereParam::MessageIds(_prisma::read_filters::JsonFilter::StringStartsWith(value))
        }
        pub fn string_ends_with(value: String) -> WhereParam {
            WhereParam::MessageIds(_prisma::read_filters::JsonFilter::StringEndsWith(value))
        }
        pub fn array_contains(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::MessageIds(_prisma::read_filters::JsonFilter::ArrayContains(value))
        }
        pub fn array_starts_with(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::MessageIds(_prisma::read_filters::JsonFilter::ArrayStartsWith(value))
        }
        pub fn array_ends_with(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::MessageIds(_prisma::read_filters::JsonFilter::ArrayEndsWith(value))
        }
        pub fn lt(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::MessageIds(_prisma::read_filters::JsonFilter::Lt(value))
        }
        pub fn lte(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::MessageIds(_prisma::read_filters::JsonFilter::Lte(value))
        }
        pub fn gt(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::MessageIds(_prisma::read_filters::JsonFilter::Gt(value))
        }
        pub fn gte(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::MessageIds(_prisma::read_filters::JsonFilter::Gte(value))
        }
        pub fn not(value: JsonNullValueFilter) -> WhereParam {
            WhereParam::MessageIds(_prisma::read_filters::JsonFilter::Not(value))
        }
        pub struct Set(pub ::prisma_client_rust::serde_json::Value);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetMessageIds(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MessageIds(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("message_ids").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MessageIds(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("message_ids").build()
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_at").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_at").build()
            }
        }
    }
    pub mod expires_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::ExpiresAtEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ExpiresAt(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::ExpiresAt(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::ExpiresAt(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::ExpiresAt(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::ExpiresAt(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::ExpiresAt(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::ExpiresAt(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::ExpiresAt(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetExpiresAt(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ExpiresAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("expires_at").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ExpiresAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("expires_at").build()
            }
        }
    }
    pub fn create(
        archive_id: String,
        message_ids: ::prisma_client_rust::serde_json::Value,
        created_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        expires_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        _params: Vec<SetParam>,
    ) -> (
        String,
        ::prisma_client_rust::serde_json::Value,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        Vec<SetParam>,
    ) {
        (archive_id, message_ids, created_at, expires_at, _params)
    }
    pub fn create_unchecked(
        archive_id: String,
        message_ids: ::prisma_client_rust::serde_json::Value,
        created_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        expires_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        _params: Vec<SetParam>,
    ) -> (
        String,
        ::prisma_client_rust::serde_json::Value,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        Vec<SetParam>,
    ) {
        (archive_id, message_ids, created_at, expires_at, _params)
    }
    #[macro_export]
    macro_rules ! _select_message_archives { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: message_archives :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: message_archives :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: message_archives :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: message_archives :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: message_archives :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: message_archives :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { archive_id , message_ids , created_at , expires_at } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: message_archives :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: message_archives :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: message_archives :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: message_archives :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: message_archives :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: message_archives :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["archive_id" , "message_ids" , "created_at" , "expires_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: message_archives :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; archive_id) => { String } ; (@ field_type ; message_ids) => { :: prisma_client_rust :: serde_json :: Value } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; expires_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "MessageArchives" , available fields are "archive_id, message_ids, created_at, expires_at")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; archive_id) => { Into :: < $ crate :: prisma :: message_archives :: SelectParam > :: into ($ crate :: prisma :: message_archives :: archive_id :: Select) } ; (@ selection_field_to_selection_param ; message_ids) => { Into :: < $ crate :: prisma :: message_archives :: SelectParam > :: into ($ crate :: prisma :: message_archives :: message_ids :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < $ crate :: prisma :: message_archives :: SelectParam > :: into ($ crate :: prisma :: message_archives :: created_at :: Select) } ; (@ selection_field_to_selection_param ; expires_at) => { Into :: < $ crate :: prisma :: message_archives :: SelectParam > :: into ($ crate :: prisma :: message_archives :: expires_at :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: message_archives :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; archive_id) => { "archive_id" } ; (@ field_serde_name ; message_ids) => { "message_ids" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; expires_at) => { "expires_at" } ; }
    pub use _select_message_archives as select;
    pub enum SelectParam {
        ArchiveId(archive_id::Select),
        MessageIds(message_ids::Select),
        CreatedAt(created_at::Select),
        ExpiresAt(expires_at::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::ArchiveId(data) => data.to_selection(),
                Self::MessageIds(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::ExpiresAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_message_archives { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: message_archives :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: message_archives :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: message_archives :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: message_archives :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: message_archives :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: message_archives :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: message_archives :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: message_archives :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub archive_id : String , pub message_ids : :: prisma_client_rust :: serde_json :: Value , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub expires_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : $ crate :: prisma :: message_archives :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (archive_id) , stringify ! (message_ids) , stringify ! (created_at) , stringify ! (expires_at)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; archive_id) , & self . archive_id) ? ; state . serialize_field ($ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; message_ids) , & self . message_ids) ? ; state . serialize_field ($ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; created_at) , & self . created_at) ? ; state . serialize_field ($ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; expires_at) , & self . expires_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , archive_id , message_ids , created_at , expires_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; archive_id) , ", " , $ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; message_ids) , ", " , $ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; created_at) , ", " , $ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; expires_at) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; archive_id) => Ok (Field :: archive_id) , $ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; message_ids) => Ok (Field :: message_ids) , $ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; created_at) => Ok (Field :: created_at) , $ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; expires_at) => Ok (Field :: expires_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut archive_id = None ; let mut message_ids = None ; let mut created_at = None ; let mut expires_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: archive_id => { if archive_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; archive_id))) ; } archive_id = Some (map . next_value () ?) ; } Field :: message_ids => { if message_ids . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; message_ids))) ; } message_ids = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; created_at))) ; } created_at = Some (map . next_value () ?) ; } Field :: expires_at => { if expires_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; expires_at))) ; } expires_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; $ field))) ? ;) * let archive_id = archive_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; archive_id))) ? ; let message_ids = message_ids . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; message_ids))) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; created_at))) ? ; let expires_at = expires_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: message_archives :: include ! (@ field_serde_name ; expires_at))) ? ; Ok (Data { archive_id , message_ids , created_at , expires_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["archive_id" , "message_ids" , "created_at" , "expires_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: message_archives :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "MessageArchives" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: message_archives :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; archive_id) => { "archive_id" } ; (@ field_serde_name ; message_ids) => { "message_ids" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; expires_at) => { "expires_at" } ; }
    pub use _include_message_archives as include;
    pub enum IncludeParam {
        ArchiveId(archive_id::Include),
        MessageIds(message_ids::Include),
        CreatedAt(created_at::Include),
        ExpiresAt(expires_at::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::ArchiveId(data) => data.to_selection(),
                Self::MessageIds(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::ExpiresAt(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "archive_id")]
        pub archive_id: String,
        #[serde(rename = "message_ids")]
        pub message_ids: ::prisma_client_rust::serde_json::Value,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "expires_at")]
        pub expires_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetArchiveId(String),
        SetMessageIds(::prisma_client_rust::serde_json::Value),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetExpiresAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetArchiveId(value) => (
                    "archive_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetMessageIds(value) => (
                    "message_ids".to_string(),
                    ::prisma_client_rust::PrismaValue::Json(serde_json::to_string(&value).unwrap()),
                ),
                SetParam::SetCreatedAt(value) => (
                    "created_at".to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetExpiresAt(value) => (
                    "expires_at".to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        ArchiveId(::prisma_client_rust::Direction),
        MessageIds(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        ExpiresAt(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::ArchiveId(direction) => (
                    "archive_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::MessageIds(direction) => (
                    "message_ids".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    "created_at".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ExpiresAt(direction) => (
                    "expires_at".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        ArchiveIdEquals(String),
        ArchiveId(_prisma::read_filters::StringFilter),
        MessageIdsEquals(::prisma_client_rust::serde_json::Value),
        MessageIds(_prisma::read_filters::JsonFilter),
        CreatedAtEquals(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        ExpiresAtEquals(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        ExpiresAt(_prisma::read_filters::DateTimeFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::ArchiveIdEquals(value) => (
                    "archive_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::ArchiveId(value) => ("archive_id", value.into()),
                Self::MessageIdsEquals(value) => (
                    "message_ids",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Json(
                            serde_json::to_string(&value).unwrap(),
                        ),
                    )]),
                ),
                Self::MessageIds(value) => ("message_ids", value.into()),
                Self::CreatedAtEquals(value) => (
                    "created_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAt(value) => ("created_at", value.into()),
                Self::ExpiresAtEquals(value) => (
                    "expires_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::ExpiresAt(value) => ("expires_at", value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        ArchiveIdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::ArchiveIdEquals(value) => Self::ArchiveIdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "message_archives";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["archive_id", "message_ids", "created_at", "expires_at"]
                .into_iter()
                .map(|o| {
                    let builder = ::prisma_client_rust::Selection::builder(o);
                    builder.build()
                })
                .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            archive_id: String,
            message_ids: ::prisma_client_rust::serde_json::Value,
            created_at: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            expires_at: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(archive_id::set(archive_id));
            _params.push(message_ids::set(message_ids));
            _params.push(created_at::set(created_at));
            _params.push(expires_at::set(expires_at));
            Create::new(self.client, _params)
        }
        pub fn create_many(
            self,
            data: Vec<(
                String,
                ::prisma_client_rust::serde_json::Value,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(archive_id, message_ids, created_at, expires_at, mut _params)| {
                        _params.push(archive_id::set(archive_id));
                        _params.push(message_ids::set(message_ids));
                        _params.push(created_at::set(created_at));
                        _params.push(expires_at::set(expires_at));
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (archive_id, message_ids, created_at, expires_at, mut _params): (
                String,
                ::prisma_client_rust::serde_json::Value,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(archive_id::set(archive_id));
            _params.push(message_ids::set(message_ids));
            _params.push(created_at::set(created_at));
            _params.push(expires_at::set(expires_at));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod messages {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i64) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod channel_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::ChannelIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ChannelId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::ChannelId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementChannelId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementChannelId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyChannelId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideChannelId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetChannelId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ChannelId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("channel_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ChannelId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("channel_id").build()
            }
        }
    }
    pub mod guild_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i64>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i64>) -> WhereParam {
            WhereParam::GuildIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::GuildId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementGuildId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementGuildId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyGuildId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideGuildId(value)
        }
        pub struct Set(pub Option<i64>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGuildId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GuildId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GuildId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
    }
    pub mod author_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::AuthorIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::AuthorId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAuthorId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AuthorId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("author_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AuthorId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("author_id").build()
            }
        }
    }
    pub mod content {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ContentEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Content(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetContent(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Content(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("content").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Content(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("content").build()
            }
        }
    }
    pub mod timestamp {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::TimestampEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Timestamp(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::Timestamp(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::Timestamp(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Timestamp(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Timestamp(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Timestamp(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Timestamp(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Timestamp(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTimestamp(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Timestamp(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("timestamp").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Timestamp(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("timestamp").build()
            }
        }
    }
    pub mod edited_timestamp {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::EditedTimestampEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::EditedTimestamp(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::EditedTimestamp(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::EditedTimestamp(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::EditedTimestamp(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::EditedTimestamp(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::EditedTimestamp(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::EditedTimestamp(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::EditedTimestamp(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(
            pub  Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEditedTimestamp(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::EditedTimestamp(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("edited_timestamp").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::EditedTimestamp(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("edited_timestamp").build()
            }
        }
    }
    pub mod deleted {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::DeletedEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Deleted(direction)
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDeleted(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Deleted(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("deleted").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Deleted(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("deleted").build()
            }
        }
    }
    pub mod num_edits {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::NumEditsEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::NumEdits(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::NumEdits(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::NumEdits(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::NumEdits(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::NumEdits(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::NumEdits(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::NumEdits(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::NumEdits(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementNumEdits(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementNumEdits(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyNumEdits(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideNumEdits(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetNumEdits(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::NumEdits(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("num_edits").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::NumEdits(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("num_edits").build()
            }
        }
    }
    pub mod command {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::CommandEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Command(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Command(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCommand(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Command(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("command").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Command(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("command").build()
            }
        }
    }
    pub mod mentions {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Vec<i64>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Vec<i64>) -> WhereParam {
            WhereParam::MentionsEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Mentions(direction)
        }
        pub fn has(value: i64) -> WhereParam {
            WhereParam::Mentions(_prisma::read_filters::BigIntListFilter::Has(value))
        }
        pub fn has_every(value: Vec<i64>) -> WhereParam {
            WhereParam::Mentions(_prisma::read_filters::BigIntListFilter::HasEvery(value))
        }
        pub fn has_some(value: Vec<i64>) -> WhereParam {
            WhereParam::Mentions(_prisma::read_filters::BigIntListFilter::HasSome(value))
        }
        pub fn is_empty(value: bool) -> WhereParam {
            WhereParam::Mentions(_prisma::read_filters::BigIntListFilter::IsEmpty(value))
        }
        pub fn push(value: Vec<i64>) -> SetParam {
            SetParam::PushMentions(value)
        }
        pub struct Set(pub Vec<i64>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetMentions(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Mentions(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("mentions").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Mentions(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("mentions").build()
            }
        }
    }
    pub mod emojis {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Vec<i64>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Vec<i64>) -> WhereParam {
            WhereParam::EmojisEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Emojis(direction)
        }
        pub fn has(value: i64) -> WhereParam {
            WhereParam::Emojis(_prisma::read_filters::BigIntListFilter::Has(value))
        }
        pub fn has_every(value: Vec<i64>) -> WhereParam {
            WhereParam::Emojis(_prisma::read_filters::BigIntListFilter::HasEvery(value))
        }
        pub fn has_some(value: Vec<i64>) -> WhereParam {
            WhereParam::Emojis(_prisma::read_filters::BigIntListFilter::HasSome(value))
        }
        pub fn is_empty(value: bool) -> WhereParam {
            WhereParam::Emojis(_prisma::read_filters::BigIntListFilter::IsEmpty(value))
        }
        pub fn push(value: Vec<i64>) -> SetParam {
            SetParam::PushEmojis(value)
        }
        pub struct Set(pub Vec<i64>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEmojis(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Emojis(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("emojis").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Emojis(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("emojis").build()
            }
        }
    }
    pub mod attachments {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Vec<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Vec<String>) -> WhereParam {
            WhereParam::AttachmentsEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Attachments(direction)
        }
        pub fn has(value: String) -> WhereParam {
            WhereParam::Attachments(_prisma::read_filters::StringListFilter::Has(value))
        }
        pub fn has_every(value: Vec<String>) -> WhereParam {
            WhereParam::Attachments(_prisma::read_filters::StringListFilter::HasEvery(value))
        }
        pub fn has_some(value: Vec<String>) -> WhereParam {
            WhereParam::Attachments(_prisma::read_filters::StringListFilter::HasSome(value))
        }
        pub fn is_empty(value: bool) -> WhereParam {
            WhereParam::Attachments(_prisma::read_filters::StringListFilter::IsEmpty(value))
        }
        pub fn push(value: Vec<String>) -> SetParam {
            SetParam::PushAttachments(value)
        }
        pub struct Set(pub Vec<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAttachments(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Attachments(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("attachments").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Attachments(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("attachments").build()
            }
        }
    }
    pub mod embeds {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<::prisma_client_rust::serde_json::Value>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<::prisma_client_rust::serde_json::Value>) -> WhereParam {
            WhereParam::EmbedsEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Embeds(direction)
        }
        pub fn path(value: Vec<String>) -> WhereParam {
            WhereParam::Embeds(_prisma::read_filters::JsonFilter::Path(value))
        }
        pub fn string_contains(value: String) -> WhereParam {
            WhereParam::Embeds(_prisma::read_filters::JsonFilter::StringContains(value))
        }
        pub fn string_starts_with(value: String) -> WhereParam {
            WhereParam::Embeds(_prisma::read_filters::JsonFilter::StringStartsWith(value))
        }
        pub fn string_ends_with(value: String) -> WhereParam {
            WhereParam::Embeds(_prisma::read_filters::JsonFilter::StringEndsWith(value))
        }
        pub fn array_contains(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Embeds(_prisma::read_filters::JsonFilter::ArrayContains(value))
        }
        pub fn array_starts_with(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Embeds(_prisma::read_filters::JsonFilter::ArrayStartsWith(value))
        }
        pub fn array_ends_with(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Embeds(_prisma::read_filters::JsonFilter::ArrayEndsWith(value))
        }
        pub fn lt(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Embeds(_prisma::read_filters::JsonFilter::Lt(value))
        }
        pub fn lte(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Embeds(_prisma::read_filters::JsonFilter::Lte(value))
        }
        pub fn gt(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Embeds(_prisma::read_filters::JsonFilter::Gt(value))
        }
        pub fn gte(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Embeds(_prisma::read_filters::JsonFilter::Gte(value))
        }
        pub fn not(value: JsonNullValueFilter) -> WhereParam {
            WhereParam::Embeds(_prisma::read_filters::JsonFilter::Not(value))
        }
        pub struct Set(pub Option<::prisma_client_rust::serde_json::Value>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEmbeds(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Embeds(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("embeds").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Embeds(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("embeds").build()
            }
        }
    }
    pub mod starboard_entries {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<starboard_entries::WhereParam>) -> WhereParam {
            WhereParam::StarboardEntriesIs(value)
        }
        pub fn is_not(value: Vec<starboard_entries::WhereParam>) -> WhereParam {
            WhereParam::StarboardEntriesIsNot(value)
        }
        pub struct Fetch(pub starboard_entries::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<starboard_entries::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::StarboardEntries(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(starboard_entries::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: starboard_entries::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectStarboardEntries
        }
        pub struct Connect(starboard_entries::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectStarboardEntries(value.0)
            }
        }
        pub enum Include {
            Select(Vec<starboard_entries::SelectParam>),
            Include(Vec<starboard_entries::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::StarboardEntries(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("starboard_entries");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < starboard_entries :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection . nested_selections (< starboard_entries :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<starboard_entries::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<starboard_entries::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<starboard_entries::SelectParam>),
            Include(Vec<starboard_entries::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::StarboardEntries(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("starboard_entries");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch => {
                        selection . nested_selections (< starboard_entries :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<starboard_entries::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<starboard_entries::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        id: i64,
        channel_id: i64,
        author_id: String,
        content: String,
        timestamp: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        deleted: bool,
        num_edits: i64,
        _params: Vec<SetParam>,
    ) -> (
        i64,
        i64,
        String,
        String,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        bool,
        i64,
        Vec<SetParam>,
    ) {
        (
            id, channel_id, author_id, content, timestamp, deleted, num_edits, _params,
        )
    }
    pub fn create_unchecked(
        id: i64,
        channel_id: i64,
        author_id: String,
        content: String,
        timestamp: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        deleted: bool,
        num_edits: i64,
        _params: Vec<SetParam>,
    ) -> (
        i64,
        i64,
        String,
        String,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        bool,
        i64,
        Vec<SetParam>,
    ) {
        (
            id, channel_id, author_id, content, timestamp, deleted, num_edits, _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_messages { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: messages :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: messages :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: messages :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: messages :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: messages :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: messages :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , channel_id , guild_id , author_id , content , timestamp , edited_timestamp , deleted , num_edits , command , mentions , emojis , attachments , embeds , starboard_entries } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: messages :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: messages :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: messages :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: messages :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: messages :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: messages :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "channel_id" , "guild_id" , "author_id" , "content" , "timestamp" , "edited_timestamp" , "deleted" , "num_edits" , "command" , "mentions" , "emojis" , "attachments" , "embeds" , "starboard_entries"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: messages :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i64 } ; (@ field_type ; channel_id) => { i64 } ; (@ field_type ; guild_id) => { Option < i64 > } ; (@ field_type ; author_id) => { String } ; (@ field_type ; content) => { String } ; (@ field_type ; timestamp) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; edited_timestamp) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; deleted) => { bool } ; (@ field_type ; num_edits) => { i64 } ; (@ field_type ; command) => { Option < String > } ; (@ field_type ; mentions) => { Vec < i64 > } ; (@ field_type ; emojis) => { Vec < i64 > } ; (@ field_type ; attachments) => { Vec < String > } ; (@ field_type ; embeds) => { Option < :: prisma_client_rust :: serde_json :: Value > } ; (@ field_type ; starboard_entries : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < starboard_entries :: Data > } ; (@ field_type ; starboard_entries) => { Option < crate :: prisma :: starboard_entries :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Messages" , available fields are "id, channel_id, guild_id, author_id, content, timestamp, edited_timestamp, deleted, num_edits, command, mentions, emojis, attachments, embeds, starboard_entries")) } ; (@ field_module ; starboard_entries : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: starboard_entries :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: messages :: SelectParam > :: into ($ crate :: prisma :: messages :: id :: Select) } ; (@ selection_field_to_selection_param ; channel_id) => { Into :: < $ crate :: prisma :: messages :: SelectParam > :: into ($ crate :: prisma :: messages :: channel_id :: Select) } ; (@ selection_field_to_selection_param ; guild_id) => { Into :: < $ crate :: prisma :: messages :: SelectParam > :: into ($ crate :: prisma :: messages :: guild_id :: Select) } ; (@ selection_field_to_selection_param ; author_id) => { Into :: < $ crate :: prisma :: messages :: SelectParam > :: into ($ crate :: prisma :: messages :: author_id :: Select) } ; (@ selection_field_to_selection_param ; content) => { Into :: < $ crate :: prisma :: messages :: SelectParam > :: into ($ crate :: prisma :: messages :: content :: Select) } ; (@ selection_field_to_selection_param ; timestamp) => { Into :: < $ crate :: prisma :: messages :: SelectParam > :: into ($ crate :: prisma :: messages :: timestamp :: Select) } ; (@ selection_field_to_selection_param ; edited_timestamp) => { Into :: < $ crate :: prisma :: messages :: SelectParam > :: into ($ crate :: prisma :: messages :: edited_timestamp :: Select) } ; (@ selection_field_to_selection_param ; deleted) => { Into :: < $ crate :: prisma :: messages :: SelectParam > :: into ($ crate :: prisma :: messages :: deleted :: Select) } ; (@ selection_field_to_selection_param ; num_edits) => { Into :: < $ crate :: prisma :: messages :: SelectParam > :: into ($ crate :: prisma :: messages :: num_edits :: Select) } ; (@ selection_field_to_selection_param ; command) => { Into :: < $ crate :: prisma :: messages :: SelectParam > :: into ($ crate :: prisma :: messages :: command :: Select) } ; (@ selection_field_to_selection_param ; mentions) => { Into :: < $ crate :: prisma :: messages :: SelectParam > :: into ($ crate :: prisma :: messages :: mentions :: Select) } ; (@ selection_field_to_selection_param ; emojis) => { Into :: < $ crate :: prisma :: messages :: SelectParam > :: into ($ crate :: prisma :: messages :: emojis :: Select) } ; (@ selection_field_to_selection_param ; attachments) => { Into :: < $ crate :: prisma :: messages :: SelectParam > :: into ($ crate :: prisma :: messages :: attachments :: Select) } ; (@ selection_field_to_selection_param ; embeds) => { Into :: < $ crate :: prisma :: messages :: SelectParam > :: into ($ crate :: prisma :: messages :: embeds :: Select) } ; (@ selection_field_to_selection_param ; starboard_entries $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: messages :: SelectParam > :: into ($ crate :: prisma :: messages :: starboard_entries :: Select :: $ selection_mode ($ crate :: prisma :: starboard_entries :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; starboard_entries $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: messages :: SelectParam > :: into ($ crate :: prisma :: messages :: starboard_entries :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: messages :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; channel_id) => { "channel_id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; author_id) => { "author_id" } ; (@ field_serde_name ; content) => { "content" } ; (@ field_serde_name ; timestamp) => { "timestamp" } ; (@ field_serde_name ; edited_timestamp) => { "edited_timestamp" } ; (@ field_serde_name ; deleted) => { "deleted" } ; (@ field_serde_name ; num_edits) => { "num_edits" } ; (@ field_serde_name ; command) => { "command" } ; (@ field_serde_name ; mentions) => { "mentions" } ; (@ field_serde_name ; emojis) => { "emojis" } ; (@ field_serde_name ; attachments) => { "attachments" } ; (@ field_serde_name ; embeds) => { "embeds" } ; (@ field_serde_name ; starboard_entries) => { "starboard_entries" } ; }
    pub use _select_messages as select;
    pub enum SelectParam {
        Id(id::Select),
        ChannelId(channel_id::Select),
        GuildId(guild_id::Select),
        AuthorId(author_id::Select),
        Content(content::Select),
        Timestamp(timestamp::Select),
        EditedTimestamp(edited_timestamp::Select),
        Deleted(deleted::Select),
        NumEdits(num_edits::Select),
        Command(command::Select),
        Mentions(mentions::Select),
        Emojis(emojis::Select),
        Attachments(attachments::Select),
        Embeds(embeds::Select),
        StarboardEntries(starboard_entries::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::ChannelId(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::AuthorId(data) => data.to_selection(),
                Self::Content(data) => data.to_selection(),
                Self::Timestamp(data) => data.to_selection(),
                Self::EditedTimestamp(data) => data.to_selection(),
                Self::Deleted(data) => data.to_selection(),
                Self::NumEdits(data) => data.to_selection(),
                Self::Command(data) => data.to_selection(),
                Self::Mentions(data) => data.to_selection(),
                Self::Emojis(data) => data.to_selection(),
                Self::Attachments(data) => data.to_selection(),
                Self::Embeds(data) => data.to_selection(),
                Self::StarboardEntries(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_messages { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: messages :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: messages :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: messages :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: messages :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: messages :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: messages :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: messages :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: messages :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { starboard_entries } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i64 , pub channel_id : i64 , pub guild_id : Option < i64 > , pub author_id : String , pub content : String , pub timestamp : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub edited_timestamp : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , pub deleted : bool , pub num_edits : i64 , pub command : Option < String > , pub mentions : Vec < i64 > , pub emojis : Vec < i64 > , pub attachments : Vec < String > , pub embeds : Option < :: prisma_client_rust :: serde_json :: Value > , $ (pub $ field : $ crate :: prisma :: messages :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (channel_id) , stringify ! (guild_id) , stringify ! (author_id) , stringify ! (content) , stringify ! (timestamp) , stringify ! (edited_timestamp) , stringify ! (deleted) , stringify ! (num_edits) , stringify ! (command) , stringify ! (mentions) , stringify ! (emojis) , stringify ! (attachments) , stringify ! (embeds)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; channel_id) , & self . channel_id) ? ; state . serialize_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; guild_id) , & self . guild_id) ? ; state . serialize_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; author_id) , & self . author_id) ? ; state . serialize_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; content) , & self . content) ? ; state . serialize_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; timestamp) , & self . timestamp) ? ; state . serialize_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; edited_timestamp) , & self . edited_timestamp) ? ; state . serialize_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; deleted) , & self . deleted) ? ; state . serialize_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; num_edits) , & self . num_edits) ? ; state . serialize_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; command) , & self . command) ? ; state . serialize_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; mentions) , & self . mentions) ? ; state . serialize_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; emojis) , & self . emojis) ? ; state . serialize_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; attachments) , & self . attachments) ? ; state . serialize_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; embeds) , & self . embeds) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , channel_id , guild_id , author_id , content , timestamp , edited_timestamp , deleted , num_edits , command , mentions , emojis , attachments , embeds } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; channel_id) , ", " , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; guild_id) , ", " , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; author_id) , ", " , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; content) , ", " , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; timestamp) , ", " , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; edited_timestamp) , ", " , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; deleted) , ", " , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; num_edits) , ", " , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; command) , ", " , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; mentions) , ", " , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; emojis) , ", " , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; attachments) , ", " , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; embeds) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; channel_id) => Ok (Field :: channel_id) , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; guild_id) => Ok (Field :: guild_id) , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; author_id) => Ok (Field :: author_id) , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; content) => Ok (Field :: content) , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; timestamp) => Ok (Field :: timestamp) , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; edited_timestamp) => Ok (Field :: edited_timestamp) , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; deleted) => Ok (Field :: deleted) , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; num_edits) => Ok (Field :: num_edits) , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; command) => Ok (Field :: command) , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; mentions) => Ok (Field :: mentions) , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; emojis) => Ok (Field :: emojis) , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; attachments) => Ok (Field :: attachments) , $ crate :: prisma :: messages :: include ! (@ field_serde_name ; embeds) => Ok (Field :: embeds) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut channel_id = None ; let mut guild_id = None ; let mut author_id = None ; let mut content = None ; let mut timestamp = None ; let mut edited_timestamp = None ; let mut deleted = None ; let mut num_edits = None ; let mut command = None ; let mut mentions = None ; let mut emojis = None ; let mut attachments = None ; let mut embeds = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: channel_id => { if channel_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; channel_id))) ; } channel_id = Some (map . next_value () ?) ; } Field :: guild_id => { if guild_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; guild_id))) ; } guild_id = Some (map . next_value () ?) ; } Field :: author_id => { if author_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; author_id))) ; } author_id = Some (map . next_value () ?) ; } Field :: content => { if content . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; content))) ; } content = Some (map . next_value () ?) ; } Field :: timestamp => { if timestamp . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; timestamp))) ; } timestamp = Some (map . next_value () ?) ; } Field :: edited_timestamp => { if edited_timestamp . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; edited_timestamp))) ; } edited_timestamp = Some (map . next_value () ?) ; } Field :: deleted => { if deleted . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; deleted))) ; } deleted = Some (map . next_value () ?) ; } Field :: num_edits => { if num_edits . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; num_edits))) ; } num_edits = Some (map . next_value () ?) ; } Field :: command => { if command . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; command))) ; } command = Some (map . next_value () ?) ; } Field :: mentions => { if mentions . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; mentions))) ; } mentions = Some (map . next_value () ?) ; } Field :: emojis => { if emojis . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; emojis))) ; } emojis = Some (map . next_value () ?) ; } Field :: attachments => { if attachments . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; attachments))) ; } attachments = Some (map . next_value () ?) ; } Field :: embeds => { if embeds . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; embeds))) ; } embeds = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; id))) ? ; let channel_id = channel_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; channel_id))) ? ; let guild_id = guild_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; guild_id))) ? ; let author_id = author_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; author_id))) ? ; let content = content . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; content))) ? ; let timestamp = timestamp . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; timestamp))) ? ; let edited_timestamp = edited_timestamp . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; edited_timestamp))) ? ; let deleted = deleted . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; deleted))) ? ; let num_edits = num_edits . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; num_edits))) ? ; let command = command . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; command))) ? ; let mentions = mentions . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; mentions))) ? ; let emojis = emojis . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; emojis))) ? ; let attachments = attachments . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; attachments))) ? ; let embeds = embeds . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: messages :: include ! (@ field_serde_name ; embeds))) ? ; Ok (Data { id , channel_id , guild_id , author_id , content , timestamp , edited_timestamp , deleted , num_edits , command , mentions , emojis , attachments , embeds , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "channel_id" , "guild_id" , "author_id" , "content" , "timestamp" , "edited_timestamp" , "deleted" , "num_edits" , "command" , "mentions" , "emojis" , "attachments" , "embeds" , "starboard_entries"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: messages :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; starboard_entries : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < starboard_entries :: Data > } ; (@ field_type ; starboard_entries) => { Option < crate :: prisma :: starboard_entries :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Messages" , available relations are "starboard_entries")) } ; (@ field_module ; starboard_entries : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: starboard_entries :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; starboard_entries $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: messages :: IncludeParam > :: into ($ crate :: prisma :: messages :: starboard_entries :: Include :: $ selection_mode ($ crate :: prisma :: starboard_entries :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; starboard_entries $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: messages :: IncludeParam > :: into ($ crate :: prisma :: messages :: starboard_entries :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: messages :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; channel_id) => { "channel_id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; author_id) => { "author_id" } ; (@ field_serde_name ; content) => { "content" } ; (@ field_serde_name ; timestamp) => { "timestamp" } ; (@ field_serde_name ; edited_timestamp) => { "edited_timestamp" } ; (@ field_serde_name ; deleted) => { "deleted" } ; (@ field_serde_name ; num_edits) => { "num_edits" } ; (@ field_serde_name ; command) => { "command" } ; (@ field_serde_name ; mentions) => { "mentions" } ; (@ field_serde_name ; emojis) => { "emojis" } ; (@ field_serde_name ; attachments) => { "attachments" } ; (@ field_serde_name ; embeds) => { "embeds" } ; (@ field_serde_name ; starboard_entries) => { "starboard_entries" } ; }
    pub use _include_messages as include;
    pub enum IncludeParam {
        Id(id::Include),
        ChannelId(channel_id::Include),
        GuildId(guild_id::Include),
        AuthorId(author_id::Include),
        Content(content::Include),
        Timestamp(timestamp::Include),
        EditedTimestamp(edited_timestamp::Include),
        Deleted(deleted::Include),
        NumEdits(num_edits::Include),
        Command(command::Include),
        Mentions(mentions::Include),
        Emojis(emojis::Include),
        Attachments(attachments::Include),
        Embeds(embeds::Include),
        StarboardEntries(starboard_entries::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::ChannelId(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::AuthorId(data) => data.to_selection(),
                Self::Content(data) => data.to_selection(),
                Self::Timestamp(data) => data.to_selection(),
                Self::EditedTimestamp(data) => data.to_selection(),
                Self::Deleted(data) => data.to_selection(),
                Self::NumEdits(data) => data.to_selection(),
                Self::Command(data) => data.to_selection(),
                Self::Mentions(data) => data.to_selection(),
                Self::Emojis(data) => data.to_selection(),
                Self::Attachments(data) => data.to_selection(),
                Self::Embeds(data) => data.to_selection(),
                Self::StarboardEntries(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i64,
        #[serde(rename = "channel_id")]
        pub channel_id: i64,
        #[serde(rename = "guild_id")]
        pub guild_id: Option<i64>,
        #[serde(rename = "author_id")]
        pub author_id: String,
        #[serde(rename = "content")]
        pub content: String,
        #[serde(rename = "timestamp")]
        pub timestamp:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "edited_timestamp")]
        pub edited_timestamp: Option<
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        >,
        #[serde(rename = "deleted")]
        pub deleted: bool,
        #[serde(rename = "num_edits")]
        pub num_edits: i64,
        #[serde(rename = "command")]
        pub command: Option<String>,
        #[serde(rename = "mentions")]
        pub mentions: Vec<i64>,
        #[serde(rename = "emojis")]
        pub emojis: Vec<i64>,
        #[serde(rename = "attachments")]
        pub attachments: Vec<String>,
        #[serde(rename = "embeds")]
        pub embeds: Option<::prisma_client_rust::serde_json::Value>,
        #[serde(
            rename = "starboard_entries",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub starboard_entries: Option<Option<Box<super::starboard_entries::Data>>>,
    }
    impl Data {
        pub fn starboard_entries(
            &self,
        ) -> Result<
            Option<&super::starboard_entries::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.starboard_entries
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(starboard_entries),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        StarboardEntries(super::starboard_entries::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::StarboardEntries(args) => {
                    let mut selections = < super :: starboard_entries :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    let mut builder = ::prisma_client_rust::Selection::builder("starboard_entries");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i64),
        IncrementId(i64),
        DecrementId(i64),
        MultiplyId(i64),
        DivideId(i64),
        SetChannelId(i64),
        IncrementChannelId(i64),
        DecrementChannelId(i64),
        MultiplyChannelId(i64),
        DivideChannelId(i64),
        SetGuildId(Option<i64>),
        IncrementGuildId(i64),
        DecrementGuildId(i64),
        MultiplyGuildId(i64),
        DivideGuildId(i64),
        SetAuthorId(String),
        SetContent(String),
        SetTimestamp(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetEditedTimestamp(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
        SetDeleted(bool),
        SetNumEdits(i64),
        IncrementNumEdits(i64),
        DecrementNumEdits(i64),
        MultiplyNumEdits(i64),
        DivideNumEdits(i64),
        SetCommand(Option<String>),
        SetMentions(Vec<i64>),
        PushMentions(Vec<i64>),
        SetEmojis(Vec<i64>),
        PushEmojis(Vec<i64>),
        SetAttachments(Vec<String>),
        PushAttachments(Vec<String>),
        SetEmbeds(Option<::prisma_client_rust::serde_json::Value>),
        ConnectStarboardEntries(super::starboard_entries::UniqueWhereParam),
        DisconnectStarboardEntries,
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetChannelId(value) => (
                    "channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementChannelId(value) => (
                    "channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementChannelId(value) => (
                    "channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyChannelId(value) => (
                    "channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideChannelId(value) => (
                    "channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetGuildId(value) => (
                    "guild_id".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetAuthorId(value) => (
                    "author_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetContent(value) => (
                    "content".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetTimestamp(value) => (
                    "timestamp".to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetEditedTimestamp(value) => (
                    "edited_timestamp".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetDeleted(value) => (
                    "deleted".to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetNumEdits(value) => (
                    "num_edits".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementNumEdits(value) => (
                    "num_edits".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementNumEdits(value) => (
                    "num_edits".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyNumEdits(value) => (
                    "num_edits".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideNumEdits(value) => (
                    "num_edits".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetCommand(value) => (
                    "command".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetMentions(value) => (
                    "mentions".to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                            .collect(),
                    ),
                ),
                SetParam::PushMentions(value) => (
                    "mentions".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetEmojis(value) => (
                    "emojis".to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                            .collect(),
                    ),
                ),
                SetParam::PushEmojis(value) => (
                    "emojis".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetAttachments(value) => (
                    "attachments".to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                            .collect(),
                    ),
                ),
                SetParam::PushAttachments(value) => (
                    "attachments".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetEmbeds(value) => (
                    "embeds".to_string(),
                    value
                        .map(|value| {
                            ::prisma_client_rust::PrismaValue::Json(
                                serde_json::to_string(&value).unwrap(),
                            )
                        })
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::ConnectStarboardEntries(where_param) => (
                    "starboard_entries".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::starboard_entries::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectStarboardEntries => (
                    "starboard_entries".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        ChannelId(::prisma_client_rust::Direction),
        GuildId(::prisma_client_rust::Direction),
        AuthorId(::prisma_client_rust::Direction),
        Content(::prisma_client_rust::Direction),
        Timestamp(::prisma_client_rust::Direction),
        EditedTimestamp(::prisma_client_rust::Direction),
        Deleted(::prisma_client_rust::Direction),
        NumEdits(::prisma_client_rust::Direction),
        Command(::prisma_client_rust::Direction),
        Mentions(::prisma_client_rust::Direction),
        Emojis(::prisma_client_rust::Direction),
        Attachments(::prisma_client_rust::Direction),
        Embeds(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ChannelId(direction) => (
                    "channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::GuildId(direction) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::AuthorId(direction) => (
                    "author_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Content(direction) => (
                    "content".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Timestamp(direction) => (
                    "timestamp".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::EditedTimestamp(direction) => (
                    "edited_timestamp".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Deleted(direction) => (
                    "deleted".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::NumEdits(direction) => (
                    "num_edits".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Command(direction) => (
                    "command".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Mentions(direction) => (
                    "mentions".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Emojis(direction) => (
                    "emojis".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Attachments(direction) => (
                    "attachments".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Embeds(direction) => (
                    "embeds".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(i64),
        Id(_prisma::read_filters::BigIntFilter),
        ChannelIdEquals(i64),
        ChannelId(_prisma::read_filters::BigIntFilter),
        GuildIdEquals(Option<i64>),
        GuildId(_prisma::read_filters::BigIntFilter),
        AuthorIdEquals(String),
        AuthorId(_prisma::read_filters::StringFilter),
        ContentEquals(String),
        Content(_prisma::read_filters::StringFilter),
        TimestampEquals(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        Timestamp(_prisma::read_filters::DateTimeFilter),
        EditedTimestampEquals(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
        EditedTimestamp(_prisma::read_filters::DateTimeFilter),
        DeletedEquals(bool),
        NumEditsEquals(i64),
        NumEdits(_prisma::read_filters::BigIntFilter),
        CommandEquals(Option<String>),
        Command(_prisma::read_filters::StringFilter),
        MentionsEquals(Vec<i64>),
        Mentions(_prisma::read_filters::BigIntListFilter),
        EmojisEquals(Vec<i64>),
        Emojis(_prisma::read_filters::BigIntListFilter),
        AttachmentsEquals(Vec<String>),
        Attachments(_prisma::read_filters::StringListFilter),
        EmbedsEquals(Option<::prisma_client_rust::serde_json::Value>),
        Embeds(_prisma::read_filters::JsonFilter),
        StarboardEntriesIs(Vec<super::starboard_entries::WhereParam>),
        StarboardEntriesIsNot(Vec<super::starboard_entries::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::Id(value) => ("id", value.into()),
                Self::ChannelIdEquals(value) => (
                    "channel_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::ChannelId(value) => ("channel_id", value.into()),
                Self::GuildIdEquals(value) => (
                    "guild_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::GuildId(value) => ("guild_id", value.into()),
                Self::AuthorIdEquals(value) => (
                    "author_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::AuthorId(value) => ("author_id", value.into()),
                Self::ContentEquals(value) => (
                    "content",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::Content(value) => ("content", value.into()),
                Self::TimestampEquals(value) => (
                    "timestamp",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::Timestamp(value) => ("timestamp", value.into()),
                Self::EditedTimestampEquals(value) => (
                    "edited_timestamp",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::EditedTimestamp(value) => ("edited_timestamp", value.into()),
                Self::DeletedEquals(value) => (
                    "deleted",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                ),
                Self::NumEditsEquals(value) => (
                    "num_edits",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::NumEdits(value) => ("num_edits", value.into()),
                Self::CommandEquals(value) => (
                    "command",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::Command(value) => ("command", value.into()),
                Self::MentionsEquals(value) => (
                    "mentions",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::Mentions(value) => ("mentions", value.into()),
                Self::EmojisEquals(value) => (
                    "emojis",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::Emojis(value) => ("emojis", value.into()),
                Self::AttachmentsEquals(value) => (
                    "attachments",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::Attachments(value) => ("attachments", value.into()),
                Self::EmbedsEquals(value) => (
                    "embeds",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| {
                                ::prisma_client_rust::PrismaValue::Json(
                                    serde_json::to_string(&value).unwrap(),
                                )
                            })
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::Embeds(value) => ("embeds", value.into()),
                Self::StarboardEntriesIs(where_params) => (
                    "starboard_entries",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::StarboardEntriesIsNot(where_params) => (
                    "starboard_entries",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i64),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "messages";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            [
                "id",
                "channel_id",
                "guild_id",
                "author_id",
                "content",
                "timestamp",
                "edited_timestamp",
                "deleted",
                "num_edits",
                "command",
                "mentions",
                "emojis",
                "attachments",
                "embeds",
            ]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            id: i64,
            channel_id: i64,
            author_id: String,
            content: String,
            timestamp: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            deleted: bool,
            num_edits: i64,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(id::set(id));
            _params.push(channel_id::set(channel_id));
            _params.push(author_id::set(author_id));
            _params.push(content::set(content));
            _params.push(timestamp::set(timestamp));
            _params.push(deleted::set(deleted));
            _params.push(num_edits::set(num_edits));
            Create::new(self.client, _params)
        }
        pub fn create_many(
            self,
            data: Vec<(
                i64,
                i64,
                String,
                String,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                bool,
                i64,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(
                        id,
                        channel_id,
                        author_id,
                        content,
                        timestamp,
                        deleted,
                        num_edits,
                        mut _params,
                    )| {
                        _params.push(id::set(id));
                        _params.push(channel_id::set(channel_id));
                        _params.push(author_id::set(author_id));
                        _params.push(content::set(content));
                        _params.push(timestamp::set(timestamp));
                        _params.push(deleted::set(deleted));
                        _params.push(num_edits::set(num_edits));
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (id, channel_id, author_id, content, timestamp, deleted, num_edits, mut _params): (
                i64,
                i64,
                String,
                String,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                bool,
                i64,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(channel_id::set(channel_id));
            _params.push(author_id::set(author_id));
            _params.push(content::set(content));
            _params.push(timestamp::set(timestamp));
            _params.push(deleted::set(deleted));
            _params.push(num_edits::set(num_edits));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod notifications {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::NotInVec(value))
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Lt(value))
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Lte(value))
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Gt(value))
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Gte(value))
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Not(value))
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod kind {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::KindEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Kind(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::IntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::IntFilter::NotInVec(value))
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::IntFilter::Lt(value))
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::IntFilter::Lte(value))
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::IntFilter::Gt(value))
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::IntFilter::Gte(value))
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::IntFilter::Not(value))
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementKind(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementKind(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyKind(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideKind(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetKind(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Kind(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("kind").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Kind(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("kind").build()
            }
        }
    }
    pub mod metadata {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: ::prisma_client_rust::serde_json::Value) -> T {
            Set(value).into()
        }
        pub fn equals(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::MetadataEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Metadata(direction)
        }
        pub fn path(value: Vec<String>) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::Path(value))
        }
        pub fn string_contains(value: String) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::StringContains(value))
        }
        pub fn string_starts_with(value: String) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::StringStartsWith(value))
        }
        pub fn string_ends_with(value: String) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::StringEndsWith(value))
        }
        pub fn array_contains(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::ArrayContains(value))
        }
        pub fn array_starts_with(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::ArrayStartsWith(value))
        }
        pub fn array_ends_with(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::ArrayEndsWith(value))
        }
        pub fn lt(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::Lt(value))
        }
        pub fn lte(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::Lte(value))
        }
        pub fn gt(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::Gt(value))
        }
        pub fn gte(value: ::prisma_client_rust::serde_json::Value) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::Gte(value))
        }
        pub fn not(value: JsonNullValueFilter) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::JsonFilter::Not(value))
        }
        pub struct Set(pub ::prisma_client_rust::serde_json::Value);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetMetadata(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Metadata(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("metadata").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Metadata(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("metadata").build()
            }
        }
    }
    pub mod read {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::ReadEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Read(direction)
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetRead(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Read(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("read").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Read(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("read").build()
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_at").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_at").build()
            }
        }
    }
    pub fn create(
        kind: i32,
        metadata: ::prisma_client_rust::serde_json::Value,
        read: bool,
        created_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        _params: Vec<SetParam>,
    ) -> (
        i32,
        ::prisma_client_rust::serde_json::Value,
        bool,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        Vec<SetParam>,
    ) {
        (kind, metadata, read, created_at, _params)
    }
    pub fn create_unchecked(
        kind: i32,
        metadata: ::prisma_client_rust::serde_json::Value,
        read: bool,
        created_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        _params: Vec<SetParam>,
    ) -> (
        i32,
        ::prisma_client_rust::serde_json::Value,
        bool,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        Vec<SetParam>,
    ) {
        (kind, metadata, read, created_at, _params)
    }
    #[macro_export]
    macro_rules ! _select_notifications { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: notifications :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: notifications :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: notifications :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: notifications :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: notifications :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: notifications :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , kind , metadata , read , created_at } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: notifications :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: notifications :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: notifications :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: notifications :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: notifications :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: notifications :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "kind" , "metadata" , "read" , "created_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: notifications :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; kind) => { i32 } ; (@ field_type ; metadata) => { :: prisma_client_rust :: serde_json :: Value } ; (@ field_type ; read) => { bool } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Notifications" , available fields are "id, kind, metadata, read, created_at")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: notifications :: SelectParam > :: into ($ crate :: prisma :: notifications :: id :: Select) } ; (@ selection_field_to_selection_param ; kind) => { Into :: < $ crate :: prisma :: notifications :: SelectParam > :: into ($ crate :: prisma :: notifications :: kind :: Select) } ; (@ selection_field_to_selection_param ; metadata) => { Into :: < $ crate :: prisma :: notifications :: SelectParam > :: into ($ crate :: prisma :: notifications :: metadata :: Select) } ; (@ selection_field_to_selection_param ; read) => { Into :: < $ crate :: prisma :: notifications :: SelectParam > :: into ($ crate :: prisma :: notifications :: read :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < $ crate :: prisma :: notifications :: SelectParam > :: into ($ crate :: prisma :: notifications :: created_at :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: notifications :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; kind) => { "kind" } ; (@ field_serde_name ; metadata) => { "metadata" } ; (@ field_serde_name ; read) => { "read" } ; (@ field_serde_name ; created_at) => { "created_at" } ; }
    pub use _select_notifications as select;
    pub enum SelectParam {
        Id(id::Select),
        Kind(kind::Select),
        Metadata(metadata::Select),
        Read(read::Select),
        CreatedAt(created_at::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Kind(data) => data.to_selection(),
                Self::Metadata(data) => data.to_selection(),
                Self::Read(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_notifications { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: notifications :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: notifications :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: notifications :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: notifications :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: notifications :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: notifications :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: notifications :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: notifications :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub kind : i32 , pub metadata : :: prisma_client_rust :: serde_json :: Value , pub read : bool , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : $ crate :: prisma :: notifications :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (kind) , stringify ! (metadata) , stringify ! (read) , stringify ! (created_at)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: notifications :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: notifications :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: notifications :: include ! (@ field_serde_name ; kind) , & self . kind) ? ; state . serialize_field ($ crate :: prisma :: notifications :: include ! (@ field_serde_name ; metadata) , & self . metadata) ? ; state . serialize_field ($ crate :: prisma :: notifications :: include ! (@ field_serde_name ; read) , & self . read) ? ; state . serialize_field ($ crate :: prisma :: notifications :: include ! (@ field_serde_name ; created_at) , & self . created_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , kind , metadata , read , created_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: notifications :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: notifications :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: notifications :: include ! (@ field_serde_name ; kind) , ", " , $ crate :: prisma :: notifications :: include ! (@ field_serde_name ; metadata) , ", " , $ crate :: prisma :: notifications :: include ! (@ field_serde_name ; read) , ", " , $ crate :: prisma :: notifications :: include ! (@ field_serde_name ; created_at) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: notifications :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: notifications :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: notifications :: include ! (@ field_serde_name ; kind) => Ok (Field :: kind) , $ crate :: prisma :: notifications :: include ! (@ field_serde_name ; metadata) => Ok (Field :: metadata) , $ crate :: prisma :: notifications :: include ! (@ field_serde_name ; read) => Ok (Field :: read) , $ crate :: prisma :: notifications :: include ! (@ field_serde_name ; created_at) => Ok (Field :: created_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut kind = None ; let mut metadata = None ; let mut read = None ; let mut created_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: notifications :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: kind => { if kind . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: notifications :: include ! (@ field_serde_name ; kind))) ; } kind = Some (map . next_value () ?) ; } Field :: metadata => { if metadata . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: notifications :: include ! (@ field_serde_name ; metadata))) ; } metadata = Some (map . next_value () ?) ; } Field :: read => { if read . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: notifications :: include ! (@ field_serde_name ; read))) ; } read = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: notifications :: include ! (@ field_serde_name ; created_at))) ; } created_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: notifications :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: notifications :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: notifications :: include ! (@ field_serde_name ; id))) ? ; let kind = kind . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: notifications :: include ! (@ field_serde_name ; kind))) ? ; let metadata = metadata . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: notifications :: include ! (@ field_serde_name ; metadata))) ? ; let read = read . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: notifications :: include ! (@ field_serde_name ; read))) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: notifications :: include ! (@ field_serde_name ; created_at))) ? ; Ok (Data { id , kind , metadata , read , created_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "kind" , "metadata" , "read" , "created_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: notifications :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Notifications" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: notifications :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; kind) => { "kind" } ; (@ field_serde_name ; metadata) => { "metadata" } ; (@ field_serde_name ; read) => { "read" } ; (@ field_serde_name ; created_at) => { "created_at" } ; }
    pub use _include_notifications as include;
    pub enum IncludeParam {
        Id(id::Include),
        Kind(kind::Include),
        Metadata(metadata::Include),
        Read(read::Include),
        CreatedAt(created_at::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Kind(data) => data.to_selection(),
                Self::Metadata(data) => data.to_selection(),
                Self::Read(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "kind")]
        pub kind: i32,
        #[serde(rename = "metadata")]
        pub metadata: ::prisma_client_rust::serde_json::Value,
        #[serde(rename = "read")]
        pub read: bool,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetKind(i32),
        IncrementKind(i32),
        DecrementKind(i32),
        MultiplyKind(i32),
        DivideKind(i32),
        SetMetadata(::prisma_client_rust::serde_json::Value),
        SetRead(bool),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetKind(value) => (
                    "kind".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementKind(value) => (
                    "kind".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementKind(value) => (
                    "kind".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyKind(value) => (
                    "kind".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideKind(value) => (
                    "kind".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetMetadata(value) => (
                    "metadata".to_string(),
                    ::prisma_client_rust::PrismaValue::Json(serde_json::to_string(&value).unwrap()),
                ),
                SetParam::SetRead(value) => (
                    "read".to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetCreatedAt(value) => (
                    "created_at".to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Kind(::prisma_client_rust::Direction),
        Metadata(::prisma_client_rust::Direction),
        Read(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Kind(direction) => (
                    "kind".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Metadata(direction) => (
                    "metadata".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Read(direction) => (
                    "read".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    "created_at".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(i32),
        Id(_prisma::read_filters::IntFilter),
        KindEquals(i32),
        Kind(_prisma::read_filters::IntFilter),
        MetadataEquals(::prisma_client_rust::serde_json::Value),
        Metadata(_prisma::read_filters::JsonFilter),
        ReadEquals(bool),
        CreatedAtEquals(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::Id(value) => ("id", value.into()),
                Self::KindEquals(value) => (
                    "kind",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::Kind(value) => ("kind", value.into()),
                Self::MetadataEquals(value) => (
                    "metadata",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Json(
                            serde_json::to_string(&value).unwrap(),
                        ),
                    )]),
                ),
                Self::Metadata(value) => ("metadata", value.into()),
                Self::ReadEquals(value) => (
                    "read",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => (
                    "created_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAt(value) => ("created_at", value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "notifications";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["id", "kind", "metadata", "read", "created_at"]
                .into_iter()
                .map(|o| {
                    let builder = ::prisma_client_rust::Selection::builder(o);
                    builder.build()
                })
                .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            kind: i32,
            metadata: ::prisma_client_rust::serde_json::Value,
            read: bool,
            created_at: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(kind::set(kind));
            _params.push(metadata::set(metadata));
            _params.push(read::set(read));
            _params.push(created_at::set(created_at));
            Create::new(self.client, _params)
        }
        pub fn create_many(
            self,
            data: Vec<(
                i32,
                ::prisma_client_rust::serde_json::Value,
                bool,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(kind, metadata, read, created_at, mut _params)| {
                    _params.push(kind::set(kind));
                    _params.push(metadata::set(metadata));
                    _params.push(read::set(read));
                    _params.push(created_at::set(created_at));
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (kind, metadata, read, created_at, mut _params): (
                i32,
                ::prisma_client_rust::serde_json::Value,
                bool,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(kind::set(kind));
            _params.push(metadata::set(metadata));
            _params.push(read::set(read));
            _params.push(created_at::set(created_at));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod reactions {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::NotInVec(value))
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Lt(value))
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Lte(value))
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Gt(value))
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Gte(value))
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Not(value))
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod message_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::MessageIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::MessageId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementMessageId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementMessageId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyMessageId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideMessageId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetMessageId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MessageId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("message_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MessageId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("message_id").build()
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementUserId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementUserId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyUserId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideUserId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("user_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("user_id").build()
            }
        }
    }
    pub mod emoji_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i64>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i64>) -> WhereParam {
            WhereParam::EmojiIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::EmojiId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::EmojiId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::EmojiId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::EmojiId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::EmojiId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::EmojiId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::EmojiId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::EmojiId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementEmojiId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementEmojiId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyEmojiId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideEmojiId(value)
        }
        pub struct Set(pub Option<i64>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEmojiId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::EmojiId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("emoji_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::EmojiId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("emoji_id").build()
            }
        }
    }
    pub mod emoji_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::EmojiNameEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::EmojiName(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EmojiName(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EmojiName(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::EmojiName(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::EmojiName(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::EmojiName(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::EmojiName(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::EmojiName(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::EmojiName(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::EmojiName(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::EmojiName(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::EmojiName(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEmojiName(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::EmojiName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("emoji_name").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::EmojiName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("emoji_name").build()
            }
        }
    }
    pub fn message_id_user_id_emoji_id_emoji_name<T: From<UniqueWhereParam>>(
        message_id: i64,
        user_id: i64,
        emoji_id: i64,
        emoji_name: String,
    ) -> T {
        UniqueWhereParam::MessageIdUserIdEmojiIdEmojiNameEquals(
            message_id, user_id, emoji_id, emoji_name,
        )
        .into()
    }
    pub fn create(
        message_id: i64,
        user_id: i64,
        emoji_name: String,
        _params: Vec<SetParam>,
    ) -> (i64, i64, String, Vec<SetParam>) {
        (message_id, user_id, emoji_name, _params)
    }
    pub fn create_unchecked(
        message_id: i64,
        user_id: i64,
        emoji_name: String,
        _params: Vec<SetParam>,
    ) -> (i64, i64, String, Vec<SetParam>) {
        (message_id, user_id, emoji_name, _params)
    }
    #[macro_export]
    macro_rules ! _select_reactions { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: reactions :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: reactions :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: reactions :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: reactions :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: reactions :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: reactions :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , message_id , user_id , emoji_id , emoji_name } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: reactions :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: reactions :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: reactions :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: reactions :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: reactions :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: reactions :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "message_id" , "user_id" , "emoji_id" , "emoji_name"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: reactions :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; message_id) => { i64 } ; (@ field_type ; user_id) => { i64 } ; (@ field_type ; emoji_id) => { Option < i64 > } ; (@ field_type ; emoji_name) => { String } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Reactions" , available fields are "id, message_id, user_id, emoji_id, emoji_name")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: reactions :: SelectParam > :: into ($ crate :: prisma :: reactions :: id :: Select) } ; (@ selection_field_to_selection_param ; message_id) => { Into :: < $ crate :: prisma :: reactions :: SelectParam > :: into ($ crate :: prisma :: reactions :: message_id :: Select) } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < $ crate :: prisma :: reactions :: SelectParam > :: into ($ crate :: prisma :: reactions :: user_id :: Select) } ; (@ selection_field_to_selection_param ; emoji_id) => { Into :: < $ crate :: prisma :: reactions :: SelectParam > :: into ($ crate :: prisma :: reactions :: emoji_id :: Select) } ; (@ selection_field_to_selection_param ; emoji_name) => { Into :: < $ crate :: prisma :: reactions :: SelectParam > :: into ($ crate :: prisma :: reactions :: emoji_name :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: reactions :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; message_id) => { "message_id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; emoji_id) => { "emoji_id" } ; (@ field_serde_name ; emoji_name) => { "emoji_name" } ; }
    pub use _select_reactions as select;
    pub enum SelectParam {
        Id(id::Select),
        MessageId(message_id::Select),
        UserId(user_id::Select),
        EmojiId(emoji_id::Select),
        EmojiName(emoji_name::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::MessageId(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::EmojiId(data) => data.to_selection(),
                Self::EmojiName(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_reactions { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: reactions :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: reactions :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: reactions :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: reactions :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: reactions :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: reactions :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: reactions :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: reactions :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub message_id : i64 , pub user_id : i64 , pub emoji_id : Option < i64 > , pub emoji_name : String , $ (pub $ field : $ crate :: prisma :: reactions :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (message_id) , stringify ! (user_id) , stringify ! (emoji_id) , stringify ! (emoji_name)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: reactions :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: reactions :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: reactions :: include ! (@ field_serde_name ; message_id) , & self . message_id) ? ; state . serialize_field ($ crate :: prisma :: reactions :: include ! (@ field_serde_name ; user_id) , & self . user_id) ? ; state . serialize_field ($ crate :: prisma :: reactions :: include ! (@ field_serde_name ; emoji_id) , & self . emoji_id) ? ; state . serialize_field ($ crate :: prisma :: reactions :: include ! (@ field_serde_name ; emoji_name) , & self . emoji_name) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , message_id , user_id , emoji_id , emoji_name } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: reactions :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: reactions :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: reactions :: include ! (@ field_serde_name ; message_id) , ", " , $ crate :: prisma :: reactions :: include ! (@ field_serde_name ; user_id) , ", " , $ crate :: prisma :: reactions :: include ! (@ field_serde_name ; emoji_id) , ", " , $ crate :: prisma :: reactions :: include ! (@ field_serde_name ; emoji_name) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: reactions :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: reactions :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: reactions :: include ! (@ field_serde_name ; message_id) => Ok (Field :: message_id) , $ crate :: prisma :: reactions :: include ! (@ field_serde_name ; user_id) => Ok (Field :: user_id) , $ crate :: prisma :: reactions :: include ! (@ field_serde_name ; emoji_id) => Ok (Field :: emoji_id) , $ crate :: prisma :: reactions :: include ! (@ field_serde_name ; emoji_name) => Ok (Field :: emoji_name) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut message_id = None ; let mut user_id = None ; let mut emoji_id = None ; let mut emoji_name = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: reactions :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: message_id => { if message_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: reactions :: include ! (@ field_serde_name ; message_id))) ; } message_id = Some (map . next_value () ?) ; } Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: reactions :: include ! (@ field_serde_name ; user_id))) ; } user_id = Some (map . next_value () ?) ; } Field :: emoji_id => { if emoji_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: reactions :: include ! (@ field_serde_name ; emoji_id))) ; } emoji_id = Some (map . next_value () ?) ; } Field :: emoji_name => { if emoji_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: reactions :: include ! (@ field_serde_name ; emoji_name))) ; } emoji_name = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: reactions :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: reactions :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: reactions :: include ! (@ field_serde_name ; id))) ? ; let message_id = message_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: reactions :: include ! (@ field_serde_name ; message_id))) ? ; let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: reactions :: include ! (@ field_serde_name ; user_id))) ? ; let emoji_id = emoji_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: reactions :: include ! (@ field_serde_name ; emoji_id))) ? ; let emoji_name = emoji_name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: reactions :: include ! (@ field_serde_name ; emoji_name))) ? ; Ok (Data { id , message_id , user_id , emoji_id , emoji_name , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "message_id" , "user_id" , "emoji_id" , "emoji_name"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: reactions :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Reactions" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: reactions :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; message_id) => { "message_id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; emoji_id) => { "emoji_id" } ; (@ field_serde_name ; emoji_name) => { "emoji_name" } ; }
    pub use _include_reactions as include;
    pub enum IncludeParam {
        Id(id::Include),
        MessageId(message_id::Include),
        UserId(user_id::Include),
        EmojiId(emoji_id::Include),
        EmojiName(emoji_name::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::MessageId(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::EmojiId(data) => data.to_selection(),
                Self::EmojiName(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "message_id")]
        pub message_id: i64,
        #[serde(rename = "user_id")]
        pub user_id: i64,
        #[serde(rename = "emoji_id")]
        pub emoji_id: Option<i64>,
        #[serde(rename = "emoji_name")]
        pub emoji_name: String,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetMessageId(i64),
        IncrementMessageId(i64),
        DecrementMessageId(i64),
        MultiplyMessageId(i64),
        DivideMessageId(i64),
        SetUserId(i64),
        IncrementUserId(i64),
        DecrementUserId(i64),
        MultiplyUserId(i64),
        DivideUserId(i64),
        SetEmojiId(Option<i64>),
        IncrementEmojiId(i64),
        DecrementEmojiId(i64),
        MultiplyEmojiId(i64),
        DivideEmojiId(i64),
        SetEmojiName(String),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetMessageId(value) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementMessageId(value) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementMessageId(value) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyMessageId(value) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideMessageId(value) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetEmojiId(value) => (
                    "emoji_id".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementEmojiId(value) => (
                    "emoji_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementEmojiId(value) => (
                    "emoji_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyEmojiId(value) => (
                    "emoji_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideEmojiId(value) => (
                    "emoji_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetEmojiName(value) => (
                    "emoji_name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        MessageId(::prisma_client_rust::Direction),
        UserId(::prisma_client_rust::Direction),
        EmojiId(::prisma_client_rust::Direction),
        EmojiName(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::MessageId(direction) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::EmojiId(direction) => (
                    "emoji_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::EmojiName(direction) => (
                    "emoji_name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        MessageIdUserIdEmojiIdEmojiNameEquals(i64, i64, i64, String),
        IdEquals(i32),
        Id(_prisma::read_filters::IntFilter),
        MessageIdEquals(i64),
        MessageId(_prisma::read_filters::BigIntFilter),
        UserIdEquals(i64),
        UserId(_prisma::read_filters::BigIntFilter),
        EmojiIdEquals(Option<i64>),
        EmojiId(_prisma::read_filters::BigIntFilter),
        EmojiNameEquals(String),
        EmojiName(_prisma::read_filters::StringFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::MessageIdUserIdEmojiIdEmojiNameEquals(
                    message_id,
                    user_id,
                    emoji_id,
                    emoji_name,
                ) => (
                    "message_id_user_id_emoji_id_emoji_name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            "message_id".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(message_id),
                        ),
                        (
                            "user_id".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(user_id),
                        ),
                        (
                            "emoji_id".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(emoji_id),
                        ),
                        (
                            "emoji_name".to_string(),
                            ::prisma_client_rust::PrismaValue::String(emoji_name),
                        ),
                    ]),
                ),
                Self::IdEquals(value) => (
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::Id(value) => ("id", value.into()),
                Self::MessageIdEquals(value) => (
                    "message_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::MessageId(value) => ("message_id", value.into()),
                Self::UserIdEquals(value) => (
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::UserId(value) => ("user_id", value.into()),
                Self::EmojiIdEquals(value) => (
                    "emoji_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::EmojiId(value) => ("emoji_id", value.into()),
                Self::EmojiNameEquals(value) => (
                    "emoji_name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::EmojiName(value) => ("emoji_name", value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        MessageIdUserIdEmojiIdEmojiNameEquals(i64, i64, i64, String),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::MessageIdUserIdEmojiIdEmojiNameEquals(
                    message_id,
                    user_id,
                    emoji_id,
                    emoji_name,
                ) => Self::MessageIdUserIdEmojiIdEmojiNameEquals(
                    message_id, user_id, emoji_id, emoji_name,
                ),
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "reactions";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["id", "message_id", "user_id", "emoji_id", "emoji_name"]
                .into_iter()
                .map(|o| {
                    let builder = ::prisma_client_rust::Selection::builder(o);
                    builder.build()
                })
                .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            message_id: i64,
            user_id: i64,
            emoji_name: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(message_id::set(message_id));
            _params.push(user_id::set(user_id));
            _params.push(emoji_name::set(emoji_name));
            Create::new(self.client, _params)
        }
        pub fn create_many(self, data: Vec<(i64, i64, String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(message_id, user_id, emoji_name, mut _params)| {
                    _params.push(message_id::set(message_id));
                    _params.push(user_id::set(user_id));
                    _params.push(emoji_name::set(emoji_name));
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (message_id, user_id, emoji_name, mut _params): (i64, i64, String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(message_id::set(message_id));
            _params.push(user_id::set(user_id));
            _params.push(emoji_name::set(emoji_name));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod reminders {
    use super::_prisma::*;
    use super::*;
    pub mod message_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i64) -> T {
            UniqueWhereParam::MessageIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::MessageId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementMessageId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementMessageId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyMessageId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideMessageId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetMessageId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MessageId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("message_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MessageId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("message_id").build()
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_at").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_at").build()
            }
        }
    }
    pub mod remind_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::RemindAtEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::RemindAt(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::RemindAt(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::RemindAt(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::RemindAt(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::RemindAt(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::RemindAt(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::RemindAt(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::RemindAt(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetRemindAt(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::RemindAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("remind_at").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::RemindAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("remind_at").build()
            }
        }
    }
    pub mod content {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ContentEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Content(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetContent(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Content(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("content").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Content(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("content").build()
            }
        }
    }
    pub fn create(
        message_id: i64,
        created_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        remind_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        content: String,
        _params: Vec<SetParam>,
    ) -> (
        i64,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        String,
        Vec<SetParam>,
    ) {
        (message_id, created_at, remind_at, content, _params)
    }
    pub fn create_unchecked(
        message_id: i64,
        created_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        remind_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        content: String,
        _params: Vec<SetParam>,
    ) -> (
        i64,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        String,
        Vec<SetParam>,
    ) {
        (message_id, created_at, remind_at, content, _params)
    }
    #[macro_export]
    macro_rules ! _select_reminders { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: reminders :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: reminders :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: reminders :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: reminders :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: reminders :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: reminders :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { message_id , created_at , remind_at , content } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: reminders :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: reminders :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: reminders :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: reminders :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: reminders :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: reminders :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["message_id" , "created_at" , "remind_at" , "content"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: reminders :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; message_id) => { i64 } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; remind_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; content) => { String } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Reminders" , available fields are "message_id, created_at, remind_at, content")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; message_id) => { Into :: < $ crate :: prisma :: reminders :: SelectParam > :: into ($ crate :: prisma :: reminders :: message_id :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < $ crate :: prisma :: reminders :: SelectParam > :: into ($ crate :: prisma :: reminders :: created_at :: Select) } ; (@ selection_field_to_selection_param ; remind_at) => { Into :: < $ crate :: prisma :: reminders :: SelectParam > :: into ($ crate :: prisma :: reminders :: remind_at :: Select) } ; (@ selection_field_to_selection_param ; content) => { Into :: < $ crate :: prisma :: reminders :: SelectParam > :: into ($ crate :: prisma :: reminders :: content :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: reminders :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; message_id) => { "message_id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; remind_at) => { "remind_at" } ; (@ field_serde_name ; content) => { "content" } ; }
    pub use _select_reminders as select;
    pub enum SelectParam {
        MessageId(message_id::Select),
        CreatedAt(created_at::Select),
        RemindAt(remind_at::Select),
        Content(content::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::MessageId(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::RemindAt(data) => data.to_selection(),
                Self::Content(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_reminders { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: reminders :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: reminders :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: reminders :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: reminders :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: reminders :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: reminders :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: reminders :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: reminders :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub message_id : i64 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub remind_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub content : String , $ (pub $ field : $ crate :: prisma :: reminders :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (message_id) , stringify ! (created_at) , stringify ! (remind_at) , stringify ! (content)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: reminders :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: reminders :: include ! (@ field_serde_name ; message_id) , & self . message_id) ? ; state . serialize_field ($ crate :: prisma :: reminders :: include ! (@ field_serde_name ; created_at) , & self . created_at) ? ; state . serialize_field ($ crate :: prisma :: reminders :: include ! (@ field_serde_name ; remind_at) , & self . remind_at) ? ; state . serialize_field ($ crate :: prisma :: reminders :: include ! (@ field_serde_name ; content) , & self . content) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , message_id , created_at , remind_at , content } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: reminders :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: reminders :: include ! (@ field_serde_name ; message_id) , ", " , $ crate :: prisma :: reminders :: include ! (@ field_serde_name ; created_at) , ", " , $ crate :: prisma :: reminders :: include ! (@ field_serde_name ; remind_at) , ", " , $ crate :: prisma :: reminders :: include ! (@ field_serde_name ; content) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: reminders :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: reminders :: include ! (@ field_serde_name ; message_id) => Ok (Field :: message_id) , $ crate :: prisma :: reminders :: include ! (@ field_serde_name ; created_at) => Ok (Field :: created_at) , $ crate :: prisma :: reminders :: include ! (@ field_serde_name ; remind_at) => Ok (Field :: remind_at) , $ crate :: prisma :: reminders :: include ! (@ field_serde_name ; content) => Ok (Field :: content) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut message_id = None ; let mut created_at = None ; let mut remind_at = None ; let mut content = None ; while let Some (key) = map . next_key () ? { match key { Field :: message_id => { if message_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: reminders :: include ! (@ field_serde_name ; message_id))) ; } message_id = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: reminders :: include ! (@ field_serde_name ; created_at))) ; } created_at = Some (map . next_value () ?) ; } Field :: remind_at => { if remind_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: reminders :: include ! (@ field_serde_name ; remind_at))) ; } remind_at = Some (map . next_value () ?) ; } Field :: content => { if content . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: reminders :: include ! (@ field_serde_name ; content))) ; } content = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: reminders :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: reminders :: include ! (@ field_serde_name ; $ field))) ? ;) * let message_id = message_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: reminders :: include ! (@ field_serde_name ; message_id))) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: reminders :: include ! (@ field_serde_name ; created_at))) ? ; let remind_at = remind_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: reminders :: include ! (@ field_serde_name ; remind_at))) ? ; let content = content . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: reminders :: include ! (@ field_serde_name ; content))) ? ; Ok (Data { message_id , created_at , remind_at , content , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["message_id" , "created_at" , "remind_at" , "content"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: reminders :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Reminders" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: reminders :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; message_id) => { "message_id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; remind_at) => { "remind_at" } ; (@ field_serde_name ; content) => { "content" } ; }
    pub use _include_reminders as include;
    pub enum IncludeParam {
        MessageId(message_id::Include),
        CreatedAt(created_at::Include),
        RemindAt(remind_at::Include),
        Content(content::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::MessageId(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::RemindAt(data) => data.to_selection(),
                Self::Content(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "message_id")]
        pub message_id: i64,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "remind_at")]
        pub remind_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "content")]
        pub content: String,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetMessageId(i64),
        IncrementMessageId(i64),
        DecrementMessageId(i64),
        MultiplyMessageId(i64),
        DivideMessageId(i64),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetRemindAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetContent(String),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetMessageId(value) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementMessageId(value) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementMessageId(value) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyMessageId(value) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideMessageId(value) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    "created_at".to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetRemindAt(value) => (
                    "remind_at".to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetContent(value) => (
                    "content".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        MessageId(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        RemindAt(::prisma_client_rust::Direction),
        Content(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::MessageId(direction) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    "created_at".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::RemindAt(direction) => (
                    "remind_at".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Content(direction) => (
                    "content".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        MessageIdEquals(i64),
        MessageId(_prisma::read_filters::BigIntFilter),
        CreatedAtEquals(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        RemindAtEquals(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        RemindAt(_prisma::read_filters::DateTimeFilter),
        ContentEquals(String),
        Content(_prisma::read_filters::StringFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::MessageIdEquals(value) => (
                    "message_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::MessageId(value) => ("message_id", value.into()),
                Self::CreatedAtEquals(value) => (
                    "created_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAt(value) => ("created_at", value.into()),
                Self::RemindAtEquals(value) => (
                    "remind_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::RemindAt(value) => ("remind_at", value.into()),
                Self::ContentEquals(value) => (
                    "content",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::Content(value) => ("content", value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        MessageIdEquals(i64),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::MessageIdEquals(value) => Self::MessageIdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "reminders";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["message_id", "created_at", "remind_at", "content"]
                .into_iter()
                .map(|o| {
                    let builder = ::prisma_client_rust::Selection::builder(o);
                    builder.build()
                })
                .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            message_id: i64,
            created_at: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            remind_at: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            content: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(message_id::set(message_id));
            _params.push(created_at::set(created_at));
            _params.push(remind_at::set(remind_at));
            _params.push(content::set(content));
            Create::new(self.client, _params)
        }
        pub fn create_many(
            self,
            data: Vec<(
                i64,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                String,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(message_id, created_at, remind_at, content, mut _params)| {
                        _params.push(message_id::set(message_id));
                        _params.push(created_at::set(created_at));
                        _params.push(remind_at::set(remind_at));
                        _params.push(content::set(content));
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (message_id, created_at, remind_at, content, mut _params): (
                i64,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                String,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(message_id::set(message_id));
            _params.push(created_at::set(created_at));
            _params.push(remind_at::set(remind_at));
            _params.push(content::set(content));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod starboard_entries {
    use super::_prisma::*;
    use super::*;
    pub mod message_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i64) -> T {
            UniqueWhereParam::MessageIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::MessageId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::MessageId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementMessageId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementMessageId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyMessageId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideMessageId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetMessageId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MessageId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("message_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MessageId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("message_id").build()
            }
        }
    }
    pub mod star_channel_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i64>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i64>) -> WhereParam {
            WhereParam::StarChannelIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::StarChannelId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::StarChannelId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::StarChannelId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::StarChannelId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::StarChannelId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::StarChannelId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::StarChannelId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::StarChannelId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementStarChannelId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementStarChannelId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyStarChannelId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideStarChannelId(value)
        }
        pub struct Set(pub Option<i64>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetStarChannelId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::StarChannelId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("star_channel_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::StarChannelId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("star_channel_id").build()
            }
        }
    }
    pub mod star_message_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i64>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i64>) -> WhereParam {
            WhereParam::StarMessageIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::StarMessageId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::StarMessageId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::StarMessageId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::StarMessageId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::StarMessageId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::StarMessageId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::StarMessageId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::StarMessageId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementStarMessageId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementStarMessageId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyStarMessageId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideStarMessageId(value)
        }
        pub struct Set(pub Option<i64>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetStarMessageId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::StarMessageId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("star_message_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::StarMessageId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("star_message_id").build()
            }
        }
    }
    pub mod stars {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Vec<i64>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Vec<i64>) -> WhereParam {
            WhereParam::StarsEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Stars(direction)
        }
        pub fn has(value: i64) -> WhereParam {
            WhereParam::Stars(_prisma::read_filters::BigIntListFilter::Has(value))
        }
        pub fn has_every(value: Vec<i64>) -> WhereParam {
            WhereParam::Stars(_prisma::read_filters::BigIntListFilter::HasEvery(value))
        }
        pub fn has_some(value: Vec<i64>) -> WhereParam {
            WhereParam::Stars(_prisma::read_filters::BigIntListFilter::HasSome(value))
        }
        pub fn is_empty(value: bool) -> WhereParam {
            WhereParam::Stars(_prisma::read_filters::BigIntListFilter::IsEmpty(value))
        }
        pub fn push(value: Vec<i64>) -> SetParam {
            SetParam::PushStars(value)
        }
        pub struct Set(pub Vec<i64>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetStars(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Stars(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("stars").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Stars(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("stars").build()
            }
        }
    }
    pub mod blocked_stars {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Vec<i64>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Vec<i64>) -> WhereParam {
            WhereParam::BlockedStarsEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::BlockedStars(direction)
        }
        pub fn has(value: i64) -> WhereParam {
            WhereParam::BlockedStars(_prisma::read_filters::BigIntListFilter::Has(value))
        }
        pub fn has_every(value: Vec<i64>) -> WhereParam {
            WhereParam::BlockedStars(_prisma::read_filters::BigIntListFilter::HasEvery(value))
        }
        pub fn has_some(value: Vec<i64>) -> WhereParam {
            WhereParam::BlockedStars(_prisma::read_filters::BigIntListFilter::HasSome(value))
        }
        pub fn is_empty(value: bool) -> WhereParam {
            WhereParam::BlockedStars(_prisma::read_filters::BigIntListFilter::IsEmpty(value))
        }
        pub fn push(value: Vec<i64>) -> SetParam {
            SetParam::PushBlockedStars(value)
        }
        pub struct Set(pub Vec<i64>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetBlockedStars(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::BlockedStars(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("blocked_stars").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::BlockedStars(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("blocked_stars").build()
            }
        }
    }
    pub mod blocked {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::BlockedEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Blocked(direction)
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetBlocked(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Blocked(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("blocked").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Blocked(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("blocked").build()
            }
        }
    }
    pub mod dirty {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::DirtyEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Dirty(direction)
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDirty(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Dirty(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("dirty").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Dirty(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("dirty").build()
            }
        }
    }
    pub mod messages {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<messages::WhereParam>) -> WhereParam {
            WhereParam::MessagesIs(value)
        }
        pub fn is_not(value: Vec<messages::WhereParam>) -> WhereParam {
            WhereParam::MessagesIsNot(value)
        }
        pub struct Fetch(pub messages::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<messages::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Messages(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(messages::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: messages::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub struct Connect(messages::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectMessages(value.0)
            }
        }
        pub enum Include {
            Select(Vec<messages::SelectParam>),
            Include(Vec<messages::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Messages(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("messages");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < messages :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection . nested_selections (< messages :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<messages::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<messages::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<messages::SelectParam>),
            Include(Vec<messages::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Messages(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("messages");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(
                            selections.into_iter().map(|s| s.to_selection()).collect(),
                        );
                    }
                    Self::Fetch => {
                        selection . nested_selections (< messages :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<messages::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<messages::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn star_channel_id_star_message_id<T: From<UniqueWhereParam>>(
        star_channel_id: i64,
        star_message_id: i64,
    ) -> T {
        UniqueWhereParam::StarChannelIdStarMessageIdEquals(star_channel_id, star_message_id).into()
    }
    pub fn create(
        blocked: bool,
        dirty: bool,
        messages: super::messages::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (bool, bool, super::messages::UniqueWhereParam, Vec<SetParam>) {
        (blocked, dirty, messages, _params)
    }
    pub fn create_unchecked(
        message_id: i64,
        blocked: bool,
        dirty: bool,
        _params: Vec<SetParam>,
    ) -> (i64, bool, bool, Vec<SetParam>) {
        (message_id, blocked, dirty, _params)
    }
    #[macro_export]
    macro_rules ! _select_starboard_entries { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: starboard_entries :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: starboard_entries :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: starboard_entries :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: starboard_entries :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: starboard_entries :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: starboard_entries :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { message_id , star_channel_id , star_message_id , stars , blocked_stars , blocked , dirty , messages } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: starboard_entries :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: starboard_entries :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: starboard_entries :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: starboard_entries :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: starboard_entries :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: starboard_entries :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["message_id" , "star_channel_id" , "star_message_id" , "stars" , "blocked_stars" , "blocked" , "dirty" , "messages"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: starboard_entries :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; message_id) => { i64 } ; (@ field_type ; star_channel_id) => { Option < i64 > } ; (@ field_type ; star_message_id) => { Option < i64 > } ; (@ field_type ; stars) => { Vec < i64 > } ; (@ field_type ; blocked_stars) => { Vec < i64 > } ; (@ field_type ; blocked) => { bool } ; (@ field_type ; dirty) => { bool } ; (@ field_type ; messages : $ selection_mode : ident { $ ($ selections : tt) + }) => { messages :: Data } ; (@ field_type ; messages) => { crate :: prisma :: messages :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "StarboardEntries" , available fields are "message_id, star_channel_id, star_message_id, stars, blocked_stars, blocked, dirty, messages")) } ; (@ field_module ; messages : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: messages :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; message_id) => { Into :: < $ crate :: prisma :: starboard_entries :: SelectParam > :: into ($ crate :: prisma :: starboard_entries :: message_id :: Select) } ; (@ selection_field_to_selection_param ; star_channel_id) => { Into :: < $ crate :: prisma :: starboard_entries :: SelectParam > :: into ($ crate :: prisma :: starboard_entries :: star_channel_id :: Select) } ; (@ selection_field_to_selection_param ; star_message_id) => { Into :: < $ crate :: prisma :: starboard_entries :: SelectParam > :: into ($ crate :: prisma :: starboard_entries :: star_message_id :: Select) } ; (@ selection_field_to_selection_param ; stars) => { Into :: < $ crate :: prisma :: starboard_entries :: SelectParam > :: into ($ crate :: prisma :: starboard_entries :: stars :: Select) } ; (@ selection_field_to_selection_param ; blocked_stars) => { Into :: < $ crate :: prisma :: starboard_entries :: SelectParam > :: into ($ crate :: prisma :: starboard_entries :: blocked_stars :: Select) } ; (@ selection_field_to_selection_param ; blocked) => { Into :: < $ crate :: prisma :: starboard_entries :: SelectParam > :: into ($ crate :: prisma :: starboard_entries :: blocked :: Select) } ; (@ selection_field_to_selection_param ; dirty) => { Into :: < $ crate :: prisma :: starboard_entries :: SelectParam > :: into ($ crate :: prisma :: starboard_entries :: dirty :: Select) } ; (@ selection_field_to_selection_param ; messages $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: starboard_entries :: SelectParam > :: into ($ crate :: prisma :: starboard_entries :: messages :: Select :: $ selection_mode ($ crate :: prisma :: messages :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; messages $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: starboard_entries :: SelectParam > :: into ($ crate :: prisma :: starboard_entries :: messages :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: starboard_entries :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; message_id) => { "message_id" } ; (@ field_serde_name ; star_channel_id) => { "star_channel_id" } ; (@ field_serde_name ; star_message_id) => { "star_message_id" } ; (@ field_serde_name ; stars) => { "stars" } ; (@ field_serde_name ; blocked_stars) => { "blocked_stars" } ; (@ field_serde_name ; blocked) => { "blocked" } ; (@ field_serde_name ; dirty) => { "dirty" } ; (@ field_serde_name ; messages) => { "messages" } ; }
    pub use _select_starboard_entries as select;
    pub enum SelectParam {
        MessageId(message_id::Select),
        StarChannelId(star_channel_id::Select),
        StarMessageId(star_message_id::Select),
        Stars(stars::Select),
        BlockedStars(blocked_stars::Select),
        Blocked(blocked::Select),
        Dirty(dirty::Select),
        Messages(messages::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::MessageId(data) => data.to_selection(),
                Self::StarChannelId(data) => data.to_selection(),
                Self::StarMessageId(data) => data.to_selection(),
                Self::Stars(data) => data.to_selection(),
                Self::BlockedStars(data) => data.to_selection(),
                Self::Blocked(data) => data.to_selection(),
                Self::Dirty(data) => data.to_selection(),
                Self::Messages(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_starboard_entries { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: starboard_entries :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: starboard_entries :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: starboard_entries :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: starboard_entries :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: starboard_entries :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: starboard_entries :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: starboard_entries :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: starboard_entries :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { messages } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub message_id : i64 , pub star_channel_id : Option < i64 > , pub star_message_id : Option < i64 > , pub stars : Vec < i64 > , pub blocked_stars : Vec < i64 > , pub blocked : bool , pub dirty : bool , $ (pub $ field : $ crate :: prisma :: starboard_entries :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (message_id) , stringify ! (star_channel_id) , stringify ! (star_message_id) , stringify ! (stars) , stringify ! (blocked_stars) , stringify ! (blocked) , stringify ! (dirty)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; message_id) , & self . message_id) ? ; state . serialize_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; star_channel_id) , & self . star_channel_id) ? ; state . serialize_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; star_message_id) , & self . star_message_id) ? ; state . serialize_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; stars) , & self . stars) ? ; state . serialize_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; blocked_stars) , & self . blocked_stars) ? ; state . serialize_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; blocked) , & self . blocked) ? ; state . serialize_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; dirty) , & self . dirty) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , message_id , star_channel_id , star_message_id , stars , blocked_stars , blocked , dirty } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; message_id) , ", " , $ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; star_channel_id) , ", " , $ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; star_message_id) , ", " , $ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; stars) , ", " , $ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; blocked_stars) , ", " , $ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; blocked) , ", " , $ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; dirty) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; message_id) => Ok (Field :: message_id) , $ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; star_channel_id) => Ok (Field :: star_channel_id) , $ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; star_message_id) => Ok (Field :: star_message_id) , $ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; stars) => Ok (Field :: stars) , $ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; blocked_stars) => Ok (Field :: blocked_stars) , $ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; blocked) => Ok (Field :: blocked) , $ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; dirty) => Ok (Field :: dirty) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut message_id = None ; let mut star_channel_id = None ; let mut star_message_id = None ; let mut stars = None ; let mut blocked_stars = None ; let mut blocked = None ; let mut dirty = None ; while let Some (key) = map . next_key () ? { match key { Field :: message_id => { if message_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; message_id))) ; } message_id = Some (map . next_value () ?) ; } Field :: star_channel_id => { if star_channel_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; star_channel_id))) ; } star_channel_id = Some (map . next_value () ?) ; } Field :: star_message_id => { if star_message_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; star_message_id))) ; } star_message_id = Some (map . next_value () ?) ; } Field :: stars => { if stars . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; stars))) ; } stars = Some (map . next_value () ?) ; } Field :: blocked_stars => { if blocked_stars . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; blocked_stars))) ; } blocked_stars = Some (map . next_value () ?) ; } Field :: blocked => { if blocked . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; blocked))) ; } blocked = Some (map . next_value () ?) ; } Field :: dirty => { if dirty . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; dirty))) ; } dirty = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; $ field))) ? ;) * let message_id = message_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; message_id))) ? ; let star_channel_id = star_channel_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; star_channel_id))) ? ; let star_message_id = star_message_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; star_message_id))) ? ; let stars = stars . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; stars))) ? ; let blocked_stars = blocked_stars . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; blocked_stars))) ? ; let blocked = blocked . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; blocked))) ? ; let dirty = dirty . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: starboard_entries :: include ! (@ field_serde_name ; dirty))) ? ; Ok (Data { message_id , star_channel_id , star_message_id , stars , blocked_stars , blocked , dirty , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["message_id" , "star_channel_id" , "star_message_id" , "stars" , "blocked_stars" , "blocked" , "dirty" , "messages"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: starboard_entries :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; messages : $ selection_mode : ident { $ ($ selections : tt) + }) => { messages :: Data } ; (@ field_type ; messages) => { crate :: prisma :: messages :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "StarboardEntries" , available relations are "messages")) } ; (@ field_module ; messages : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: messages :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; messages $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: starboard_entries :: IncludeParam > :: into ($ crate :: prisma :: starboard_entries :: messages :: Include :: $ selection_mode ($ crate :: prisma :: messages :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; messages $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: starboard_entries :: IncludeParam > :: into ($ crate :: prisma :: starboard_entries :: messages :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: starboard_entries :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; message_id) => { "message_id" } ; (@ field_serde_name ; star_channel_id) => { "star_channel_id" } ; (@ field_serde_name ; star_message_id) => { "star_message_id" } ; (@ field_serde_name ; stars) => { "stars" } ; (@ field_serde_name ; blocked_stars) => { "blocked_stars" } ; (@ field_serde_name ; blocked) => { "blocked" } ; (@ field_serde_name ; dirty) => { "dirty" } ; (@ field_serde_name ; messages) => { "messages" } ; }
    pub use _include_starboard_entries as include;
    pub enum IncludeParam {
        MessageId(message_id::Include),
        StarChannelId(star_channel_id::Include),
        StarMessageId(star_message_id::Include),
        Stars(stars::Include),
        BlockedStars(blocked_stars::Include),
        Blocked(blocked::Include),
        Dirty(dirty::Include),
        Messages(messages::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::MessageId(data) => data.to_selection(),
                Self::StarChannelId(data) => data.to_selection(),
                Self::StarMessageId(data) => data.to_selection(),
                Self::Stars(data) => data.to_selection(),
                Self::BlockedStars(data) => data.to_selection(),
                Self::Blocked(data) => data.to_selection(),
                Self::Dirty(data) => data.to_selection(),
                Self::Messages(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "message_id")]
        pub message_id: i64,
        #[serde(rename = "star_channel_id")]
        pub star_channel_id: Option<i64>,
        #[serde(rename = "star_message_id")]
        pub star_message_id: Option<i64>,
        #[serde(rename = "stars")]
        pub stars: Vec<i64>,
        #[serde(rename = "blocked_stars")]
        pub blocked_stars: Vec<i64>,
        #[serde(rename = "blocked")]
        pub blocked: bool,
        #[serde(rename = "dirty")]
        pub dirty: bool,
        #[serde(rename = "messages")]
        pub messages: Option<Box<super::messages::Data>>,
    }
    impl Data {
        pub fn messages(
            &self,
        ) -> Result<&super::messages::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.messages
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(messages),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Messages(super::messages::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Messages(args) => {
                    let mut selections = < super :: messages :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    let mut builder = ::prisma_client_rust::Selection::builder("messages");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetMessageId(i64),
        IncrementMessageId(i64),
        DecrementMessageId(i64),
        MultiplyMessageId(i64),
        DivideMessageId(i64),
        SetStarChannelId(Option<i64>),
        IncrementStarChannelId(i64),
        DecrementStarChannelId(i64),
        MultiplyStarChannelId(i64),
        DivideStarChannelId(i64),
        SetStarMessageId(Option<i64>),
        IncrementStarMessageId(i64),
        DecrementStarMessageId(i64),
        MultiplyStarMessageId(i64),
        DivideStarMessageId(i64),
        SetStars(Vec<i64>),
        PushStars(Vec<i64>),
        SetBlockedStars(Vec<i64>),
        PushBlockedStars(Vec<i64>),
        SetBlocked(bool),
        SetDirty(bool),
        ConnectMessages(super::messages::UniqueWhereParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetMessageId(value) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementMessageId(value) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementMessageId(value) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyMessageId(value) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideMessageId(value) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetStarChannelId(value) => (
                    "star_channel_id".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementStarChannelId(value) => (
                    "star_channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementStarChannelId(value) => (
                    "star_channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyStarChannelId(value) => (
                    "star_channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideStarChannelId(value) => (
                    "star_channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetStarMessageId(value) => (
                    "star_message_id".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementStarMessageId(value) => (
                    "star_message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementStarMessageId(value) => (
                    "star_message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyStarMessageId(value) => (
                    "star_message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideStarMessageId(value) => (
                    "star_message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetStars(value) => (
                    "stars".to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                            .collect(),
                    ),
                ),
                SetParam::PushStars(value) => (
                    "stars".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetBlockedStars(value) => (
                    "blocked_stars".to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                            .collect(),
                    ),
                ),
                SetParam::PushBlockedStars(value) => (
                    "blocked_stars".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetBlocked(value) => (
                    "blocked".to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetDirty(value) => (
                    "dirty".to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::ConnectMessages(where_param) => (
                    "messages".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::messages::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        MessageId(::prisma_client_rust::Direction),
        StarChannelId(::prisma_client_rust::Direction),
        StarMessageId(::prisma_client_rust::Direction),
        Stars(::prisma_client_rust::Direction),
        BlockedStars(::prisma_client_rust::Direction),
        Blocked(::prisma_client_rust::Direction),
        Dirty(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::MessageId(direction) => (
                    "message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::StarChannelId(direction) => (
                    "star_channel_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::StarMessageId(direction) => (
                    "star_message_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Stars(direction) => (
                    "stars".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::BlockedStars(direction) => (
                    "blocked_stars".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Blocked(direction) => (
                    "blocked".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Dirty(direction) => (
                    "dirty".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        StarChannelIdStarMessageIdEquals(i64, i64),
        MessageIdEquals(i64),
        MessageId(_prisma::read_filters::BigIntFilter),
        StarChannelIdEquals(Option<i64>),
        StarChannelId(_prisma::read_filters::BigIntFilter),
        StarMessageIdEquals(Option<i64>),
        StarMessageId(_prisma::read_filters::BigIntFilter),
        StarsEquals(Vec<i64>),
        Stars(_prisma::read_filters::BigIntListFilter),
        BlockedStarsEquals(Vec<i64>),
        BlockedStars(_prisma::read_filters::BigIntListFilter),
        BlockedEquals(bool),
        DirtyEquals(bool),
        MessagesIs(Vec<super::messages::WhereParam>),
        MessagesIsNot(Vec<super::messages::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::StarChannelIdStarMessageIdEquals(star_channel_id, star_message_id) => (
                    "star_channel_id_star_message_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            "star_channel_id".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(star_channel_id),
                        ),
                        (
                            "star_message_id".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(star_message_id),
                        ),
                    ]),
                ),
                Self::MessageIdEquals(value) => (
                    "message_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::MessageId(value) => ("message_id", value.into()),
                Self::StarChannelIdEquals(value) => (
                    "star_channel_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::StarChannelId(value) => ("star_channel_id", value.into()),
                Self::StarMessageIdEquals(value) => (
                    "star_message_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::StarMessageId(value) => ("star_message_id", value.into()),
                Self::StarsEquals(value) => (
                    "stars",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::Stars(value) => ("stars", value.into()),
                Self::BlockedStarsEquals(value) => (
                    "blocked_stars",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                                .collect(),
                        ),
                    )]),
                ),
                Self::BlockedStars(value) => ("blocked_stars", value.into()),
                Self::BlockedEquals(value) => (
                    "blocked",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                ),
                Self::DirtyEquals(value) => (
                    "dirty",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                ),
                Self::MessagesIs(where_params) => (
                    "messages",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MessagesIsNot(where_params) => (
                    "messages",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        StarChannelIdStarMessageIdEquals(i64, i64),
        MessageIdEquals(i64),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::StarChannelIdStarMessageIdEquals(
                    star_channel_id,
                    star_message_id,
                ) => Self::StarChannelIdStarMessageIdEquals(star_channel_id, star_message_id),
                UniqueWhereParam::MessageIdEquals(value) => Self::MessageIdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "starboard_entries";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            [
                "message_id",
                "star_channel_id",
                "star_message_id",
                "stars",
                "blocked_stars",
                "blocked",
                "dirty",
            ]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            blocked: bool,
            dirty: bool,
            messages: super::messages::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(blocked::set(blocked));
            _params.push(dirty::set(dirty));
            _params.push(messages::connect(messages));
            Create::new(self.client, _params)
        }
        pub fn create_many(self, data: Vec<(i64, bool, bool, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(message_id, blocked, dirty, mut _params)| {
                    _params.push(message_id::set(message_id));
                    _params.push(blocked::set(blocked));
                    _params.push(dirty::set(dirty));
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (blocked, dirty, messages, mut _params): (
                bool,
                bool,
                super::messages::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(blocked::set(blocked));
            _params.push(dirty::set(dirty));
            _params.push(messages::connect(messages));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod starboardblock {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::NotInVec(value))
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Lt(value))
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Lte(value))
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Gt(value))
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Gte(value))
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Not(value))
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod guild_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::GuildIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::GuildId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementGuildId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementGuildId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyGuildId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideGuildId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGuildId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GuildId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GuildId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
    }
    pub mod entity_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::EntityIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::EntityId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::EntityId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::EntityId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::EntityId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::EntityId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::EntityId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::EntityId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::EntityId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementEntityId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementEntityId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyEntityId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideEntityId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEntityId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::EntityId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("entity_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::EntityId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("entity_id").build()
            }
        }
    }
    pub mod actor_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::ActorIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ActorId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementActorId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementActorId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyActorId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideActorId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetActorId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ActorId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("actor_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ActorId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("actor_id").build()
            }
        }
    }
    pub fn guild_id_entity_id<T: From<UniqueWhereParam>>(guild_id: i64, entity_id: i64) -> T {
        UniqueWhereParam::GuildIdEntityIdEquals(guild_id, entity_id).into()
    }
    pub fn create(
        guild_id: i64,
        entity_id: i64,
        actor_id: i64,
        _params: Vec<SetParam>,
    ) -> (i64, i64, i64, Vec<SetParam>) {
        (guild_id, entity_id, actor_id, _params)
    }
    pub fn create_unchecked(
        guild_id: i64,
        entity_id: i64,
        actor_id: i64,
        _params: Vec<SetParam>,
    ) -> (i64, i64, i64, Vec<SetParam>) {
        (guild_id, entity_id, actor_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_starboardblock { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: starboardblock :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: starboardblock :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: starboardblock :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: starboardblock :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: starboardblock :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: starboardblock :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , guild_id , entity_id , actor_id } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: starboardblock :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: starboardblock :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: starboardblock :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: starboardblock :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: starboardblock :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: starboardblock :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "guild_id" , "entity_id" , "actor_id"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: starboardblock :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; guild_id) => { i64 } ; (@ field_type ; entity_id) => { i64 } ; (@ field_type ; actor_id) => { i64 } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Starboardblock" , available fields are "id, guild_id, entity_id, actor_id")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: starboardblock :: SelectParam > :: into ($ crate :: prisma :: starboardblock :: id :: Select) } ; (@ selection_field_to_selection_param ; guild_id) => { Into :: < $ crate :: prisma :: starboardblock :: SelectParam > :: into ($ crate :: prisma :: starboardblock :: guild_id :: Select) } ; (@ selection_field_to_selection_param ; entity_id) => { Into :: < $ crate :: prisma :: starboardblock :: SelectParam > :: into ($ crate :: prisma :: starboardblock :: entity_id :: Select) } ; (@ selection_field_to_selection_param ; actor_id) => { Into :: < $ crate :: prisma :: starboardblock :: SelectParam > :: into ($ crate :: prisma :: starboardblock :: actor_id :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: starboardblock :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; entity_id) => { "entity_id" } ; (@ field_serde_name ; actor_id) => { "actor_id" } ; }
    pub use _select_starboardblock as select;
    pub enum SelectParam {
        Id(id::Select),
        GuildId(guild_id::Select),
        EntityId(entity_id::Select),
        ActorId(actor_id::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::EntityId(data) => data.to_selection(),
                Self::ActorId(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_starboardblock { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: starboardblock :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: starboardblock :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: starboardblock :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: starboardblock :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: starboardblock :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: starboardblock :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: starboardblock :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: starboardblock :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub guild_id : i64 , pub entity_id : i64 , pub actor_id : i64 , $ (pub $ field : $ crate :: prisma :: starboardblock :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (guild_id) , stringify ! (entity_id) , stringify ! (actor_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; guild_id) , & self . guild_id) ? ; state . serialize_field ($ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; entity_id) , & self . entity_id) ? ; state . serialize_field ($ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; actor_id) , & self . actor_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , guild_id , entity_id , actor_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; guild_id) , ", " , $ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; entity_id) , ", " , $ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; actor_id) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; guild_id) => Ok (Field :: guild_id) , $ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; entity_id) => Ok (Field :: entity_id) , $ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; actor_id) => Ok (Field :: actor_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut guild_id = None ; let mut entity_id = None ; let mut actor_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: guild_id => { if guild_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; guild_id))) ; } guild_id = Some (map . next_value () ?) ; } Field :: entity_id => { if entity_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; entity_id))) ; } entity_id = Some (map . next_value () ?) ; } Field :: actor_id => { if actor_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; actor_id))) ; } actor_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; id))) ? ; let guild_id = guild_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; guild_id))) ? ; let entity_id = entity_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; entity_id))) ? ; let actor_id = actor_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: starboardblock :: include ! (@ field_serde_name ; actor_id))) ? ; Ok (Data { id , guild_id , entity_id , actor_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "guild_id" , "entity_id" , "actor_id"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: starboardblock :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Starboardblock" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: starboardblock :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; entity_id) => { "entity_id" } ; (@ field_serde_name ; actor_id) => { "actor_id" } ; }
    pub use _include_starboardblock as include;
    pub enum IncludeParam {
        Id(id::Include),
        GuildId(guild_id::Include),
        EntityId(entity_id::Include),
        ActorId(actor_id::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::EntityId(data) => data.to_selection(),
                Self::ActorId(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "guild_id")]
        pub guild_id: i64,
        #[serde(rename = "entity_id")]
        pub entity_id: i64,
        #[serde(rename = "actor_id")]
        pub actor_id: i64,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetGuildId(i64),
        IncrementGuildId(i64),
        DecrementGuildId(i64),
        MultiplyGuildId(i64),
        DivideGuildId(i64),
        SetEntityId(i64),
        IncrementEntityId(i64),
        DecrementEntityId(i64),
        MultiplyEntityId(i64),
        DivideEntityId(i64),
        SetActorId(i64),
        IncrementActorId(i64),
        DecrementActorId(i64),
        MultiplyActorId(i64),
        DivideActorId(i64),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetEntityId(value) => (
                    "entity_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementEntityId(value) => (
                    "entity_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementEntityId(value) => (
                    "entity_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyEntityId(value) => (
                    "entity_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideEntityId(value) => (
                    "entity_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetActorId(value) => (
                    "actor_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementActorId(value) => (
                    "actor_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementActorId(value) => (
                    "actor_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyActorId(value) => (
                    "actor_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideActorId(value) => (
                    "actor_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        GuildId(::prisma_client_rust::Direction),
        EntityId(::prisma_client_rust::Direction),
        ActorId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::GuildId(direction) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::EntityId(direction) => (
                    "entity_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ActorId(direction) => (
                    "actor_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        GuildIdEntityIdEquals(i64, i64),
        IdEquals(i32),
        Id(_prisma::read_filters::IntFilter),
        GuildIdEquals(i64),
        GuildId(_prisma::read_filters::BigIntFilter),
        EntityIdEquals(i64),
        EntityId(_prisma::read_filters::BigIntFilter),
        ActorIdEquals(i64),
        ActorId(_prisma::read_filters::BigIntFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::GuildIdEntityIdEquals(guild_id, entity_id) => (
                    "guild_id_entity_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            "guild_id".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(guild_id),
                        ),
                        (
                            "entity_id".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(entity_id),
                        ),
                    ]),
                ),
                Self::IdEquals(value) => (
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::Id(value) => ("id", value.into()),
                Self::GuildIdEquals(value) => (
                    "guild_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::GuildId(value) => ("guild_id", value.into()),
                Self::EntityIdEquals(value) => (
                    "entity_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::EntityId(value) => ("entity_id", value.into()),
                Self::ActorIdEquals(value) => (
                    "actor_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::ActorId(value) => ("actor_id", value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        GuildIdEntityIdEquals(i64, i64),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::GuildIdEntityIdEquals(guild_id, entity_id) => {
                    Self::GuildIdEntityIdEquals(guild_id, entity_id)
                }
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "starboardblock";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["id", "guild_id", "entity_id", "actor_id"]
                .into_iter()
                .map(|o| {
                    let builder = ::prisma_client_rust::Selection::builder(o);
                    builder.build()
                })
                .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            guild_id: i64,
            entity_id: i64,
            actor_id: i64,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(guild_id::set(guild_id));
            _params.push(entity_id::set(entity_id));
            _params.push(actor_id::set(actor_id));
            Create::new(self.client, _params)
        }
        pub fn create_many(self, data: Vec<(i64, i64, i64, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(guild_id, entity_id, actor_id, mut _params)| {
                    _params.push(guild_id::set(guild_id));
                    _params.push(entity_id::set(entity_id));
                    _params.push(actor_id::set(actor_id));
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (guild_id, entity_id, actor_id, mut _params): (i64, i64, i64, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(guild_id::set(guild_id));
            _params.push(entity_id::set(entity_id));
            _params.push(actor_id::set(actor_id));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod tags {
    use super::_prisma::*;
    use super::*;
    pub mod guild_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::GuildIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::GuildId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementGuildId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementGuildId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyGuildId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideGuildId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGuildId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GuildId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GuildId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
    }
    pub mod author_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::AuthorIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::AuthorId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementAuthorId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementAuthorId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyAuthorId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideAuthorId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAuthorId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AuthorId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("author_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AuthorId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("author_id").build()
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::NameEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetName(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("name").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("name").build()
            }
        }
    }
    pub mod content {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ContentEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Content(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Content(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetContent(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Content(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("content").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Content(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("content").build()
            }
        }
    }
    pub mod times_used {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::TimesUsedEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::TimesUsed(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::TimesUsed(_prisma::read_filters::IntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::TimesUsed(_prisma::read_filters::IntFilter::NotInVec(value))
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::TimesUsed(_prisma::read_filters::IntFilter::Lt(value))
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::TimesUsed(_prisma::read_filters::IntFilter::Lte(value))
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::TimesUsed(_prisma::read_filters::IntFilter::Gt(value))
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::TimesUsed(_prisma::read_filters::IntFilter::Gte(value))
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::TimesUsed(_prisma::read_filters::IntFilter::Not(value))
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementTimesUsed(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementTimesUsed(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyTimesUsed(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideTimesUsed(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTimesUsed(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TimesUsed(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("times_used").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TimesUsed(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("times_used").build()
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_at").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_at").build()
            }
        }
    }
    pub fn guild_id_name<T: From<UniqueWhereParam>>(guild_id: i64, name: String) -> T {
        UniqueWhereParam::GuildIdNameEquals(guild_id, name).into()
    }
    pub fn create(
        guild_id: i64,
        author_id: i64,
        name: String,
        content: String,
        times_used: i32,
        created_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        _params: Vec<SetParam>,
    ) -> (
        i64,
        i64,
        String,
        String,
        i32,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        Vec<SetParam>,
    ) {
        (
            guild_id, author_id, name, content, times_used, created_at, _params,
        )
    }
    pub fn create_unchecked(
        guild_id: i64,
        author_id: i64,
        name: String,
        content: String,
        times_used: i32,
        created_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        _params: Vec<SetParam>,
    ) -> (
        i64,
        i64,
        String,
        String,
        i32,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        Vec<SetParam>,
    ) {
        (
            guild_id, author_id, name, content, times_used, created_at, _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_tags { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: tags :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: tags :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: tags :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: tags :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: tags :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: tags :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { guild_id , author_id , name , content , times_used , created_at } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: tags :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: tags :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: tags :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: tags :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: tags :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: tags :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["guild_id" , "author_id" , "name" , "content" , "times_used" , "created_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: tags :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; guild_id) => { i64 } ; (@ field_type ; author_id) => { i64 } ; (@ field_type ; name) => { String } ; (@ field_type ; content) => { String } ; (@ field_type ; times_used) => { i32 } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Tags" , available fields are "guild_id, author_id, name, content, times_used, created_at")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; guild_id) => { Into :: < $ crate :: prisma :: tags :: SelectParam > :: into ($ crate :: prisma :: tags :: guild_id :: Select) } ; (@ selection_field_to_selection_param ; author_id) => { Into :: < $ crate :: prisma :: tags :: SelectParam > :: into ($ crate :: prisma :: tags :: author_id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < $ crate :: prisma :: tags :: SelectParam > :: into ($ crate :: prisma :: tags :: name :: Select) } ; (@ selection_field_to_selection_param ; content) => { Into :: < $ crate :: prisma :: tags :: SelectParam > :: into ($ crate :: prisma :: tags :: content :: Select) } ; (@ selection_field_to_selection_param ; times_used) => { Into :: < $ crate :: prisma :: tags :: SelectParam > :: into ($ crate :: prisma :: tags :: times_used :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < $ crate :: prisma :: tags :: SelectParam > :: into ($ crate :: prisma :: tags :: created_at :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: tags :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; author_id) => { "author_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; content) => { "content" } ; (@ field_serde_name ; times_used) => { "times_used" } ; (@ field_serde_name ; created_at) => { "created_at" } ; }
    pub use _select_tags as select;
    pub enum SelectParam {
        GuildId(guild_id::Select),
        AuthorId(author_id::Select),
        Name(name::Select),
        Content(content::Select),
        TimesUsed(times_used::Select),
        CreatedAt(created_at::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::GuildId(data) => data.to_selection(),
                Self::AuthorId(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Content(data) => data.to_selection(),
                Self::TimesUsed(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_tags { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: tags :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: tags :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: tags :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: tags :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: tags :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: tags :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: tags :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: tags :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub guild_id : i64 , pub author_id : i64 , pub name : String , pub content : String , pub times_used : i32 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : $ crate :: prisma :: tags :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (guild_id) , stringify ! (author_id) , stringify ! (name) , stringify ! (content) , stringify ! (times_used) , stringify ! (created_at)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; guild_id) , & self . guild_id) ? ; state . serialize_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; author_id) , & self . author_id) ? ; state . serialize_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; name) , & self . name) ? ; state . serialize_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; content) , & self . content) ? ; state . serialize_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; times_used) , & self . times_used) ? ; state . serialize_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; created_at) , & self . created_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , guild_id , author_id , name , content , times_used , created_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: tags :: include ! (@ field_serde_name ; guild_id) , ", " , $ crate :: prisma :: tags :: include ! (@ field_serde_name ; author_id) , ", " , $ crate :: prisma :: tags :: include ! (@ field_serde_name ; name) , ", " , $ crate :: prisma :: tags :: include ! (@ field_serde_name ; content) , ", " , $ crate :: prisma :: tags :: include ! (@ field_serde_name ; times_used) , ", " , $ crate :: prisma :: tags :: include ! (@ field_serde_name ; created_at) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: tags :: include ! (@ field_serde_name ; guild_id) => Ok (Field :: guild_id) , $ crate :: prisma :: tags :: include ! (@ field_serde_name ; author_id) => Ok (Field :: author_id) , $ crate :: prisma :: tags :: include ! (@ field_serde_name ; name) => Ok (Field :: name) , $ crate :: prisma :: tags :: include ! (@ field_serde_name ; content) => Ok (Field :: content) , $ crate :: prisma :: tags :: include ! (@ field_serde_name ; times_used) => Ok (Field :: times_used) , $ crate :: prisma :: tags :: include ! (@ field_serde_name ; created_at) => Ok (Field :: created_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut guild_id = None ; let mut author_id = None ; let mut name = None ; let mut content = None ; let mut times_used = None ; let mut created_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: guild_id => { if guild_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; guild_id))) ; } guild_id = Some (map . next_value () ?) ; } Field :: author_id => { if author_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; author_id))) ; } author_id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; name))) ; } name = Some (map . next_value () ?) ; } Field :: content => { if content . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; content))) ; } content = Some (map . next_value () ?) ; } Field :: times_used => { if times_used . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; times_used))) ; } times_used = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; created_at))) ; } created_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; $ field))) ? ;) * let guild_id = guild_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; guild_id))) ? ; let author_id = author_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; author_id))) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; name))) ? ; let content = content . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; content))) ? ; let times_used = times_used . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; times_used))) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: tags :: include ! (@ field_serde_name ; created_at))) ? ; Ok (Data { guild_id , author_id , name , content , times_used , created_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["guild_id" , "author_id" , "name" , "content" , "times_used" , "created_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: tags :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Tags" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: tags :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; author_id) => { "author_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; content) => { "content" } ; (@ field_serde_name ; times_used) => { "times_used" } ; (@ field_serde_name ; created_at) => { "created_at" } ; }
    pub use _include_tags as include;
    pub enum IncludeParam {
        GuildId(guild_id::Include),
        AuthorId(author_id::Include),
        Name(name::Include),
        Content(content::Include),
        TimesUsed(times_used::Include),
        CreatedAt(created_at::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::GuildId(data) => data.to_selection(),
                Self::AuthorId(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Content(data) => data.to_selection(),
                Self::TimesUsed(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "guild_id")]
        pub guild_id: i64,
        #[serde(rename = "author_id")]
        pub author_id: i64,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "content")]
        pub content: String,
        #[serde(rename = "times_used")]
        pub times_used: i32,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetGuildId(i64),
        IncrementGuildId(i64),
        DecrementGuildId(i64),
        MultiplyGuildId(i64),
        DivideGuildId(i64),
        SetAuthorId(i64),
        IncrementAuthorId(i64),
        DecrementAuthorId(i64),
        MultiplyAuthorId(i64),
        DivideAuthorId(i64),
        SetName(String),
        SetContent(String),
        SetTimesUsed(i32),
        IncrementTimesUsed(i32),
        DecrementTimesUsed(i32),
        MultiplyTimesUsed(i32),
        DivideTimesUsed(i32),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetAuthorId(value) => (
                    "author_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementAuthorId(value) => (
                    "author_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementAuthorId(value) => (
                    "author_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyAuthorId(value) => (
                    "author_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideAuthorId(value) => (
                    "author_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetName(value) => (
                    "name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetContent(value) => (
                    "content".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetTimesUsed(value) => (
                    "times_used".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementTimesUsed(value) => (
                    "times_used".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementTimesUsed(value) => (
                    "times_used".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyTimesUsed(value) => (
                    "times_used".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideTimesUsed(value) => (
                    "times_used".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    "created_at".to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        GuildId(::prisma_client_rust::Direction),
        AuthorId(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        Content(::prisma_client_rust::Direction),
        TimesUsed(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::GuildId(direction) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::AuthorId(direction) => (
                    "author_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    "name".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Content(direction) => (
                    "content".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::TimesUsed(direction) => (
                    "times_used".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    "created_at".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        GuildIdNameEquals(i64, String),
        GuildIdEquals(i64),
        GuildId(_prisma::read_filters::BigIntFilter),
        AuthorIdEquals(i64),
        AuthorId(_prisma::read_filters::BigIntFilter),
        NameEquals(String),
        Name(_prisma::read_filters::StringFilter),
        ContentEquals(String),
        Content(_prisma::read_filters::StringFilter),
        TimesUsedEquals(i32),
        TimesUsed(_prisma::read_filters::IntFilter),
        CreatedAtEquals(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::GuildIdNameEquals(guild_id, name) => (
                    "guild_id_name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            "guild_id".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(guild_id),
                        ),
                        (
                            "name".to_string(),
                            ::prisma_client_rust::PrismaValue::String(name),
                        ),
                    ]),
                ),
                Self::GuildIdEquals(value) => (
                    "guild_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::GuildId(value) => ("guild_id", value.into()),
                Self::AuthorIdEquals(value) => (
                    "author_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::AuthorId(value) => ("author_id", value.into()),
                Self::NameEquals(value) => (
                    "name",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::Name(value) => ("name", value.into()),
                Self::ContentEquals(value) => (
                    "content",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::Content(value) => ("content", value.into()),
                Self::TimesUsedEquals(value) => (
                    "times_used",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::TimesUsed(value) => ("times_used", value.into()),
                Self::CreatedAtEquals(value) => (
                    "created_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAt(value) => ("created_at", value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        GuildIdNameEquals(i64, String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::GuildIdNameEquals(guild_id, name) => {
                    Self::GuildIdNameEquals(guild_id, name)
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "tags";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            [
                "guild_id",
                "author_id",
                "name",
                "content",
                "times_used",
                "created_at",
            ]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            guild_id: i64,
            author_id: i64,
            name: String,
            content: String,
            times_used: i32,
            created_at: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(guild_id::set(guild_id));
            _params.push(author_id::set(author_id));
            _params.push(name::set(name));
            _params.push(content::set(content));
            _params.push(times_used::set(times_used));
            _params.push(created_at::set(created_at));
            Create::new(self.client, _params)
        }
        pub fn create_many(
            self,
            data: Vec<(
                i64,
                i64,
                String,
                String,
                i32,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(guild_id, author_id, name, content, times_used, created_at, mut _params)| {
                        _params.push(guild_id::set(guild_id));
                        _params.push(author_id::set(author_id));
                        _params.push(name::set(name));
                        _params.push(content::set(content));
                        _params.push(times_used::set(times_used));
                        _params.push(created_at::set(created_at));
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (guild_id, author_id, name, content, times_used, created_at, mut _params): (
                i64,
                i64,
                String,
                String,
                i32,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(guild_id::set(guild_id));
            _params.push(author_id::set(author_id));
            _params.push(name::set(name));
            _params.push(content::set(content));
            _params.push(times_used::set(times_used));
            _params.push(created_at::set(created_at));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod users {
    use super::_prisma::*;
    use super::*;
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("user_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("user_id").build()
            }
        }
    }
    pub mod username {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::UsernameEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Username(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Username(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUsername(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Username(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("username").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Username(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("username").build()
            }
        }
    }
    pub mod discriminator {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::DiscriminatorEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Discriminator(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Discriminator(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Discriminator(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Discriminator(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Discriminator(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Discriminator(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Discriminator(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Discriminator(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Discriminator(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Discriminator(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Discriminator(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Discriminator(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDiscriminator(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Discriminator(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("discriminator").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Discriminator(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("discriminator").build()
            }
        }
    }
    pub mod avatar {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::AvatarEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Avatar(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Avatar(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Avatar(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Avatar(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Avatar(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Avatar(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Avatar(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Avatar(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Avatar(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Avatar(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn mode(value: QueryMode) -> WhereParam {
            WhereParam::Avatar(_prisma::read_filters::StringFilter::Mode(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Avatar(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAvatar(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Avatar(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("avatar").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Avatar(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("avatar").build()
            }
        }
    }
    pub mod bot {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::BotEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Bot(direction)
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetBot(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Bot(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("bot").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Bot(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("bot").build()
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(
            value: Vec<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_at").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_at").build()
            }
        }
    }
    pub mod admin {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::AdminEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Admin(direction)
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAdmin(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Admin(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("admin").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Admin(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("admin").build()
            }
        }
    }
    pub fn user_id_username_discriminator<T: From<UniqueWhereParam>>(
        user_id: String,
        username: String,
        discriminator: String,
    ) -> T {
        UniqueWhereParam::UserIdUsernameDiscriminatorEquals(user_id, username, discriminator).into()
    }
    pub fn create(
        user_id: String,
        username: String,
        discriminator: String,
        bot: bool,
        created_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        admin: bool,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        bool,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        bool,
        Vec<SetParam>,
    ) {
        (
            user_id,
            username,
            discriminator,
            bot,
            created_at,
            admin,
            _params,
        )
    }
    pub fn create_unchecked(
        user_id: String,
        username: String,
        discriminator: String,
        bot: bool,
        created_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        admin: bool,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        bool,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        bool,
        Vec<SetParam>,
    ) {
        (
            user_id,
            username,
            discriminator,
            bot,
            created_at,
            admin,
            _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_users { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: users :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: users :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: users :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: users :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: users :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: users :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { user_id , username , discriminator , avatar , bot , created_at , admin } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: users :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: users :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: users :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: users :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: users :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: users :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["user_id" , "username" , "discriminator" , "avatar" , "bot" , "created_at" , "admin"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: users :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; user_id) => { String } ; (@ field_type ; username) => { String } ; (@ field_type ; discriminator) => { String } ; (@ field_type ; avatar) => { Option < String > } ; (@ field_type ; bot) => { bool } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; admin) => { bool } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Users" , available fields are "user_id, username, discriminator, avatar, bot, created_at, admin")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < $ crate :: prisma :: users :: SelectParam > :: into ($ crate :: prisma :: users :: user_id :: Select) } ; (@ selection_field_to_selection_param ; username) => { Into :: < $ crate :: prisma :: users :: SelectParam > :: into ($ crate :: prisma :: users :: username :: Select) } ; (@ selection_field_to_selection_param ; discriminator) => { Into :: < $ crate :: prisma :: users :: SelectParam > :: into ($ crate :: prisma :: users :: discriminator :: Select) } ; (@ selection_field_to_selection_param ; avatar) => { Into :: < $ crate :: prisma :: users :: SelectParam > :: into ($ crate :: prisma :: users :: avatar :: Select) } ; (@ selection_field_to_selection_param ; bot) => { Into :: < $ crate :: prisma :: users :: SelectParam > :: into ($ crate :: prisma :: users :: bot :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < $ crate :: prisma :: users :: SelectParam > :: into ($ crate :: prisma :: users :: created_at :: Select) } ; (@ selection_field_to_selection_param ; admin) => { Into :: < $ crate :: prisma :: users :: SelectParam > :: into ($ crate :: prisma :: users :: admin :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: users :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; username) => { "username" } ; (@ field_serde_name ; discriminator) => { "discriminator" } ; (@ field_serde_name ; avatar) => { "avatar" } ; (@ field_serde_name ; bot) => { "bot" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; admin) => { "admin" } ; }
    pub use _select_users as select;
    pub enum SelectParam {
        UserId(user_id::Select),
        Username(username::Select),
        Discriminator(discriminator::Select),
        Avatar(avatar::Select),
        Bot(bot::Select),
        CreatedAt(created_at::Select),
        Admin(admin::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::UserId(data) => data.to_selection(),
                Self::Username(data) => data.to_selection(),
                Self::Discriminator(data) => data.to_selection(),
                Self::Avatar(data) => data.to_selection(),
                Self::Bot(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Admin(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_users { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: users :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: users :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: users :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: users :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: users :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: users :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: users :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: users :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub user_id : String , pub username : String , pub discriminator : String , pub avatar : Option < String > , pub bot : bool , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub admin : bool , $ (pub $ field : $ crate :: prisma :: users :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (user_id) , stringify ! (username) , stringify ! (discriminator) , stringify ! (avatar) , stringify ! (bot) , stringify ! (created_at) , stringify ! (admin)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; user_id) , & self . user_id) ? ; state . serialize_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; username) , & self . username) ? ; state . serialize_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; discriminator) , & self . discriminator) ? ; state . serialize_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; avatar) , & self . avatar) ? ; state . serialize_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; bot) , & self . bot) ? ; state . serialize_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; created_at) , & self . created_at) ? ; state . serialize_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; admin) , & self . admin) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , user_id , username , discriminator , avatar , bot , created_at , admin } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: users :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: users :: include ! (@ field_serde_name ; user_id) , ", " , $ crate :: prisma :: users :: include ! (@ field_serde_name ; username) , ", " , $ crate :: prisma :: users :: include ! (@ field_serde_name ; discriminator) , ", " , $ crate :: prisma :: users :: include ! (@ field_serde_name ; avatar) , ", " , $ crate :: prisma :: users :: include ! (@ field_serde_name ; bot) , ", " , $ crate :: prisma :: users :: include ! (@ field_serde_name ; created_at) , ", " , $ crate :: prisma :: users :: include ! (@ field_serde_name ; admin) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: users :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: users :: include ! (@ field_serde_name ; user_id) => Ok (Field :: user_id) , $ crate :: prisma :: users :: include ! (@ field_serde_name ; username) => Ok (Field :: username) , $ crate :: prisma :: users :: include ! (@ field_serde_name ; discriminator) => Ok (Field :: discriminator) , $ crate :: prisma :: users :: include ! (@ field_serde_name ; avatar) => Ok (Field :: avatar) , $ crate :: prisma :: users :: include ! (@ field_serde_name ; bot) => Ok (Field :: bot) , $ crate :: prisma :: users :: include ! (@ field_serde_name ; created_at) => Ok (Field :: created_at) , $ crate :: prisma :: users :: include ! (@ field_serde_name ; admin) => Ok (Field :: admin) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut user_id = None ; let mut username = None ; let mut discriminator = None ; let mut avatar = None ; let mut bot = None ; let mut created_at = None ; let mut admin = None ; while let Some (key) = map . next_key () ? { match key { Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; user_id))) ; } user_id = Some (map . next_value () ?) ; } Field :: username => { if username . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; username))) ; } username = Some (map . next_value () ?) ; } Field :: discriminator => { if discriminator . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; discriminator))) ; } discriminator = Some (map . next_value () ?) ; } Field :: avatar => { if avatar . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; avatar))) ; } avatar = Some (map . next_value () ?) ; } Field :: bot => { if bot . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; bot))) ; } bot = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; created_at))) ; } created_at = Some (map . next_value () ?) ; } Field :: admin => { if admin . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; admin))) ; } admin = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; $ field))) ? ;) * let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; user_id))) ? ; let username = username . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; username))) ? ; let discriminator = discriminator . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; discriminator))) ? ; let avatar = avatar . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; avatar))) ? ; let bot = bot . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; bot))) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; created_at))) ? ; let admin = admin . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: users :: include ! (@ field_serde_name ; admin))) ? ; Ok (Data { user_id , username , discriminator , avatar , bot , created_at , admin , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["user_id" , "username" , "discriminator" , "avatar" , "bot" , "created_at" , "admin"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: users :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Users" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: users :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; username) => { "username" } ; (@ field_serde_name ; discriminator) => { "discriminator" } ; (@ field_serde_name ; avatar) => { "avatar" } ; (@ field_serde_name ; bot) => { "bot" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; admin) => { "admin" } ; }
    pub use _include_users as include;
    pub enum IncludeParam {
        UserId(user_id::Include),
        Username(username::Include),
        Discriminator(discriminator::Include),
        Avatar(avatar::Include),
        Bot(bot::Include),
        CreatedAt(created_at::Include),
        Admin(admin::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::UserId(data) => data.to_selection(),
                Self::Username(data) => data.to_selection(),
                Self::Discriminator(data) => data.to_selection(),
                Self::Avatar(data) => data.to_selection(),
                Self::Bot(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Admin(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "user_id")]
        pub user_id: String,
        #[serde(rename = "username")]
        pub username: String,
        #[serde(rename = "discriminator")]
        pub discriminator: String,
        #[serde(rename = "avatar")]
        pub avatar: Option<String>,
        #[serde(rename = "bot")]
        pub bot: bool,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "admin")]
        pub admin: bool,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetUserId(String),
        SetUsername(String),
        SetDiscriminator(String),
        SetAvatar(Option<String>),
        SetBot(bool),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetAdmin(bool),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetUsername(value) => (
                    "username".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetDiscriminator(value) => (
                    "discriminator".to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetAvatar(value) => (
                    "avatar".to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetBot(value) => (
                    "bot".to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetCreatedAt(value) => (
                    "created_at".to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetAdmin(value) => (
                    "admin".to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        UserId(::prisma_client_rust::Direction),
        Username(::prisma_client_rust::Direction),
        Discriminator(::prisma_client_rust::Direction),
        Avatar(::prisma_client_rust::Direction),
        Bot(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        Admin(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::UserId(direction) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Username(direction) => (
                    "username".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Discriminator(direction) => (
                    "discriminator".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Avatar(direction) => (
                    "avatar".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Bot(direction) => (
                    "bot".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    "created_at".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Admin(direction) => (
                    "admin".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        UserIdUsernameDiscriminatorEquals(String, String, String),
        UserIdEquals(String),
        UserId(_prisma::read_filters::StringFilter),
        UsernameEquals(String),
        Username(_prisma::read_filters::StringFilter),
        DiscriminatorEquals(String),
        Discriminator(_prisma::read_filters::StringFilter),
        AvatarEquals(Option<String>),
        Avatar(_prisma::read_filters::StringFilter),
        BotEquals(bool),
        CreatedAtEquals(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        AdminEquals(bool),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::UserIdUsernameDiscriminatorEquals(user_id, username, discriminator) => (
                    "user_id_username_discriminator",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            "user_id".to_string(),
                            ::prisma_client_rust::PrismaValue::String(user_id),
                        ),
                        (
                            "username".to_string(),
                            ::prisma_client_rust::PrismaValue::String(username),
                        ),
                        (
                            "discriminator".to_string(),
                            ::prisma_client_rust::PrismaValue::String(discriminator),
                        ),
                    ]),
                ),
                Self::UserIdEquals(value) => (
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::UserId(value) => ("user_id", value.into()),
                Self::UsernameEquals(value) => (
                    "username",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::Username(value) => ("username", value.into()),
                Self::DiscriminatorEquals(value) => (
                    "discriminator",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                ),
                Self::Discriminator(value) => ("discriminator", value.into()),
                Self::AvatarEquals(value) => (
                    "avatar",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or(::prisma_client_rust::PrismaValue::Null),
                    )]),
                ),
                Self::Avatar(value) => ("avatar", value.into()),
                Self::BotEquals(value) => (
                    "bot",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                ),
                Self::CreatedAtEquals(value) => (
                    "created_at",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                ),
                Self::CreatedAt(value) => ("created_at", value.into()),
                Self::AdminEquals(value) => (
                    "admin",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        UserIdUsernameDiscriminatorEquals(String, String, String),
        UserIdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::UserIdUsernameDiscriminatorEquals(
                    user_id,
                    username,
                    discriminator,
                ) => Self::UserIdUsernameDiscriminatorEquals(user_id, username, discriminator),
                UniqueWhereParam::UserIdEquals(value) => Self::UserIdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "Users";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            [
                "user_id",
                "username",
                "discriminator",
                "avatar",
                "bot",
                "created_at",
                "admin",
            ]
            .into_iter()
            .map(|o| {
                let builder = ::prisma_client_rust::Selection::builder(o);
                builder.build()
            })
            .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            user_id: String,
            username: String,
            discriminator: String,
            bot: bool,
            created_at: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            admin: bool,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(user_id::set(user_id));
            _params.push(username::set(username));
            _params.push(discriminator::set(discriminator));
            _params.push(bot::set(bot));
            _params.push(created_at::set(created_at));
            _params.push(admin::set(admin));
            Create::new(self.client, _params)
        }
        pub fn create_many(
            self,
            data: Vec<(
                String,
                String,
                String,
                bool,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                bool,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(user_id, username, discriminator, bot, created_at, admin, mut _params)| {
                        _params.push(user_id::set(user_id));
                        _params.push(username::set(username));
                        _params.push(discriminator::set(discriminator));
                        _params.push(bot::set(bot));
                        _params.push(created_at::set(created_at));
                        _params.push(admin::set(admin));
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (user_id, username, discriminator, bot, created_at, admin, mut _params): (
                String,
                String,
                String,
                bool,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                bool,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(user_id::set(user_id));
            _params.push(username::set(username));
            _params.push(discriminator::set(discriminator));
            _params.push(bot::set(bot));
            _params.push(created_at::set(created_at));
            _params.push(admin::set(admin));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod xp {
    use super::_prisma::*;
    use super::*;
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementUserId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementUserId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyUserId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideUserId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("user_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("user_id").build()
            }
        }
    }
    pub mod guild_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::GuildIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::GuildId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementGuildId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementGuildId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyGuildId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideGuildId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGuildId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GuildId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GuildId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
    }
    pub mod xp {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::XpEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Xp(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::Xp(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::Xp(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::Xp(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::Xp(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::Xp(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::Xp(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::Xp(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementXp(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementXp(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyXp(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideXp(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetXp(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Xp(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("xp").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Xp(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("xp").build()
            }
        }
    }
    pub fn guild_id_user_id<T: From<UniqueWhereParam>>(guild_id: i64, user_id: i64) -> T {
        UniqueWhereParam::GuildIdUserIdEquals(guild_id, user_id).into()
    }
    pub fn create(
        user_id: i64,
        guild_id: i64,
        xp: i64,
        _params: Vec<SetParam>,
    ) -> (i64, i64, i64, Vec<SetParam>) {
        (user_id, guild_id, xp, _params)
    }
    pub fn create_unchecked(
        user_id: i64,
        guild_id: i64,
        xp: i64,
        _params: Vec<SetParam>,
    ) -> (i64, i64, i64, Vec<SetParam>) {
        (user_id, guild_id, xp, _params)
    }
    #[macro_export]
    macro_rules ! _select_xp { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: xp :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: xp :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: xp :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: xp :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: xp :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: xp :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { user_id , guild_id , xp } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: xp :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: xp :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: xp :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: xp :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: xp :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: xp :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["user_id" , "guild_id" , "xp"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: xp :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; user_id) => { i64 } ; (@ field_type ; guild_id) => { i64 } ; (@ field_type ; xp) => { i64 } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Xp" , available fields are "user_id, guild_id, xp")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < $ crate :: prisma :: xp :: SelectParam > :: into ($ crate :: prisma :: xp :: user_id :: Select) } ; (@ selection_field_to_selection_param ; guild_id) => { Into :: < $ crate :: prisma :: xp :: SelectParam > :: into ($ crate :: prisma :: xp :: guild_id :: Select) } ; (@ selection_field_to_selection_param ; xp) => { Into :: < $ crate :: prisma :: xp :: SelectParam > :: into ($ crate :: prisma :: xp :: xp :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: xp :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; xp) => { "xp" } ; }
    pub use _select_xp as select;
    pub enum SelectParam {
        UserId(user_id::Select),
        GuildId(guild_id::Select),
        Xp(xp::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::UserId(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::Xp(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_xp { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: xp :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: xp :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: xp :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: xp :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: xp :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: xp :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: xp :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: xp :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub user_id : i64 , pub guild_id : i64 , pub xp : i64 , $ (pub $ field : $ crate :: prisma :: xp :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (user_id) , stringify ! (guild_id) , stringify ! (xp)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: xp :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: xp :: include ! (@ field_serde_name ; user_id) , & self . user_id) ? ; state . serialize_field ($ crate :: prisma :: xp :: include ! (@ field_serde_name ; guild_id) , & self . guild_id) ? ; state . serialize_field ($ crate :: prisma :: xp :: include ! (@ field_serde_name ; xp) , & self . xp) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , user_id , guild_id , xp } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: xp :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: xp :: include ! (@ field_serde_name ; user_id) , ", " , $ crate :: prisma :: xp :: include ! (@ field_serde_name ; guild_id) , ", " , $ crate :: prisma :: xp :: include ! (@ field_serde_name ; xp) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: xp :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: xp :: include ! (@ field_serde_name ; user_id) => Ok (Field :: user_id) , $ crate :: prisma :: xp :: include ! (@ field_serde_name ; guild_id) => Ok (Field :: guild_id) , $ crate :: prisma :: xp :: include ! (@ field_serde_name ; xp) => Ok (Field :: xp) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut user_id = None ; let mut guild_id = None ; let mut xp = None ; while let Some (key) = map . next_key () ? { match key { Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: xp :: include ! (@ field_serde_name ; user_id))) ; } user_id = Some (map . next_value () ?) ; } Field :: guild_id => { if guild_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: xp :: include ! (@ field_serde_name ; guild_id))) ; } guild_id = Some (map . next_value () ?) ; } Field :: xp => { if xp . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: xp :: include ! (@ field_serde_name ; xp))) ; } xp = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: xp :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: xp :: include ! (@ field_serde_name ; $ field))) ? ;) * let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: xp :: include ! (@ field_serde_name ; user_id))) ? ; let guild_id = guild_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: xp :: include ! (@ field_serde_name ; guild_id))) ? ; let xp = xp . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: xp :: include ! (@ field_serde_name ; xp))) ? ; Ok (Data { user_id , guild_id , xp , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["user_id" , "guild_id" , "xp"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: xp :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Xp" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: xp :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; xp) => { "xp" } ; }
    pub use _include_xp as include;
    pub enum IncludeParam {
        UserId(user_id::Include),
        GuildId(guild_id::Include),
        Xp(xp::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::UserId(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::Xp(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "user_id")]
        pub user_id: i64,
        #[serde(rename = "guild_id")]
        pub guild_id: i64,
        #[serde(rename = "xp")]
        pub xp: i64,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetUserId(i64),
        IncrementUserId(i64),
        DecrementUserId(i64),
        MultiplyUserId(i64),
        DivideUserId(i64),
        SetGuildId(i64),
        IncrementGuildId(i64),
        DecrementGuildId(i64),
        MultiplyGuildId(i64),
        DivideGuildId(i64),
        SetXp(i64),
        IncrementXp(i64),
        DecrementXp(i64),
        MultiplyXp(i64),
        DivideXp(i64),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetXp(value) => (
                    "xp".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementXp(value) => (
                    "xp".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementXp(value) => (
                    "xp".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyXp(value) => (
                    "xp".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideXp(value) => (
                    "xp".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        UserId(::prisma_client_rust::Direction),
        GuildId(::prisma_client_rust::Direction),
        Xp(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::UserId(direction) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::GuildId(direction) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Xp(direction) => (
                    "xp".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        GuildIdUserIdEquals(i64, i64),
        UserIdEquals(i64),
        UserId(_prisma::read_filters::BigIntFilter),
        GuildIdEquals(i64),
        GuildId(_prisma::read_filters::BigIntFilter),
        XpEquals(i64),
        Xp(_prisma::read_filters::BigIntFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::GuildIdUserIdEquals(guild_id, user_id) => (
                    "guild_id_user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            "guild_id".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(guild_id),
                        ),
                        (
                            "user_id".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(user_id),
                        ),
                    ]),
                ),
                Self::UserIdEquals(value) => (
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::UserId(value) => ("user_id", value.into()),
                Self::GuildIdEquals(value) => (
                    "guild_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::GuildId(value) => ("guild_id", value.into()),
                Self::XpEquals(value) => (
                    "xp",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::Xp(value) => ("xp", value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        GuildIdUserIdEquals(i64, i64),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::GuildIdUserIdEquals(guild_id, user_id) => {
                    Self::GuildIdUserIdEquals(guild_id, user_id)
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "xp";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["user_id", "guild_id", "xp"]
                .into_iter()
                .map(|o| {
                    let builder = ::prisma_client_rust::Selection::builder(o);
                    builder.build()
                })
                .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            user_id: i64,
            guild_id: i64,
            xp: i64,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(user_id::set(user_id));
            _params.push(guild_id::set(guild_id));
            _params.push(xp::set(xp));
            Create::new(self.client, _params)
        }
        pub fn create_many(self, data: Vec<(i64, i64, i64, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(user_id, guild_id, xp, mut _params)| {
                    _params.push(user_id::set(user_id));
                    _params.push(guild_id::set(guild_id));
                    _params.push(xp::set(xp));
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (user_id, guild_id, xp, mut _params): (i64, i64, i64, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(user_id::set(user_id));
            _params.push(guild_id::set(guild_id));
            _params.push(xp::set(xp));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod xpblock {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::NotInVec(value))
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Lt(value))
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Lte(value))
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Gt(value))
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Gte(value))
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::IntFilter::Not(value))
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod guild_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::GuildIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::GuildId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::GuildId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementGuildId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementGuildId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyGuildId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideGuildId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetGuildId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GuildId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GuildId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("guild_id").build()
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementUserId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementUserId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyUserId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideUserId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("user_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("user_id").build()
            }
        }
    }
    pub mod actor_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::ActorIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ActorId(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::ActorId(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementActorId(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementActorId(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyActorId(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideActorId(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetActorId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ActorId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("actor_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ActorId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("actor_id").build()
            }
        }
    }
    pub fn guild_id_user_id<T: From<UniqueWhereParam>>(guild_id: i64, user_id: i64) -> T {
        UniqueWhereParam::GuildIdUserIdEquals(guild_id, user_id).into()
    }
    pub fn create(
        guild_id: i64,
        user_id: i64,
        actor_id: i64,
        _params: Vec<SetParam>,
    ) -> (i64, i64, i64, Vec<SetParam>) {
        (guild_id, user_id, actor_id, _params)
    }
    pub fn create_unchecked(
        guild_id: i64,
        user_id: i64,
        actor_id: i64,
        _params: Vec<SetParam>,
    ) -> (i64, i64, i64, Vec<SetParam>) {
        (guild_id, user_id, actor_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_xpblock { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: xpblock :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: xpblock :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: xpblock :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: xpblock :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: xpblock :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: xpblock :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , guild_id , user_id , actor_id } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: xpblock :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: xpblock :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: xpblock :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: xpblock :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: xpblock :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: xpblock :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "guild_id" , "user_id" , "actor_id"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: xpblock :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; guild_id) => { i64 } ; (@ field_type ; user_id) => { i64 } ; (@ field_type ; actor_id) => { i64 } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Xpblock" , available fields are "id, guild_id, user_id, actor_id")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: xpblock :: SelectParam > :: into ($ crate :: prisma :: xpblock :: id :: Select) } ; (@ selection_field_to_selection_param ; guild_id) => { Into :: < $ crate :: prisma :: xpblock :: SelectParam > :: into ($ crate :: prisma :: xpblock :: guild_id :: Select) } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < $ crate :: prisma :: xpblock :: SelectParam > :: into ($ crate :: prisma :: xpblock :: user_id :: Select) } ; (@ selection_field_to_selection_param ; actor_id) => { Into :: < $ crate :: prisma :: xpblock :: SelectParam > :: into ($ crate :: prisma :: xpblock :: actor_id :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: xpblock :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; actor_id) => { "actor_id" } ; }
    pub use _select_xpblock as select;
    pub enum SelectParam {
        Id(id::Select),
        GuildId(guild_id::Select),
        UserId(user_id::Select),
        ActorId(actor_id::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::ActorId(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_xpblock { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: xpblock :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: xpblock :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: xpblock :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: xpblock :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: xpblock :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: xpblock :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: xpblock :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: xpblock :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub guild_id : i64 , pub user_id : i64 , pub actor_id : i64 , $ (pub $ field : $ crate :: prisma :: xpblock :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (guild_id) , stringify ! (user_id) , stringify ! (actor_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; guild_id) , & self . guild_id) ? ; state . serialize_field ($ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; user_id) , & self . user_id) ? ; state . serialize_field ($ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; actor_id) , & self . actor_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , guild_id , user_id , actor_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; guild_id) , ", " , $ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; user_id) , ", " , $ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; actor_id) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; guild_id) => Ok (Field :: guild_id) , $ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; user_id) => Ok (Field :: user_id) , $ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; actor_id) => Ok (Field :: actor_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut guild_id = None ; let mut user_id = None ; let mut actor_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: guild_id => { if guild_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; guild_id))) ; } guild_id = Some (map . next_value () ?) ; } Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; user_id))) ; } user_id = Some (map . next_value () ?) ; } Field :: actor_id => { if actor_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; actor_id))) ; } actor_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; id))) ? ; let guild_id = guild_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; guild_id))) ? ; let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; user_id))) ? ; let actor_id = actor_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: xpblock :: include ! (@ field_serde_name ; actor_id))) ? ; Ok (Data { id , guild_id , user_id , actor_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "guild_id" , "user_id" , "actor_id"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: xpblock :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Xpblock" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: xpblock :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; guild_id) => { "guild_id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; actor_id) => { "actor_id" } ; }
    pub use _include_xpblock as include;
    pub enum IncludeParam {
        Id(id::Include),
        GuildId(guild_id::Include),
        UserId(user_id::Include),
        ActorId(actor_id::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::GuildId(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::ActorId(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "guild_id")]
        pub guild_id: i64,
        #[serde(rename = "user_id")]
        pub user_id: i64,
        #[serde(rename = "actor_id")]
        pub actor_id: i64,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetGuildId(i64),
        IncrementGuildId(i64),
        DecrementGuildId(i64),
        MultiplyGuildId(i64),
        DivideGuildId(i64),
        SetUserId(i64),
        IncrementUserId(i64),
        DecrementUserId(i64),
        MultiplyUserId(i64),
        DivideUserId(i64),
        SetActorId(i64),
        IncrementActorId(i64),
        DecrementActorId(i64),
        MultiplyActorId(i64),
        DivideActorId(i64),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideGuildId(value) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideUserId(value) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::SetActorId(value) => (
                    "actor_id".to_string(),
                    ::prisma_client_rust::PrismaValue::BigInt(value),
                ),
                SetParam::IncrementActorId(value) => (
                    "actor_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DecrementActorId(value) => (
                    "actor_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::MultiplyActorId(value) => (
                    "actor_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                SetParam::DivideActorId(value) => (
                    "actor_id".to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        GuildId(::prisma_client_rust::Direction),
        UserId(::prisma_client_rust::Direction),
        ActorId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    "id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::GuildId(direction) => (
                    "guild_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    "user_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ActorId(direction) => (
                    "actor_id".to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        GuildIdUserIdEquals(i64, i64),
        IdEquals(i32),
        Id(_prisma::read_filters::IntFilter),
        GuildIdEquals(i64),
        GuildId(_prisma::read_filters::BigIntFilter),
        UserIdEquals(i64),
        UserId(_prisma::read_filters::BigIntFilter),
        ActorIdEquals(i64),
        ActorId(_prisma::read_filters::BigIntFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::GuildIdUserIdEquals(guild_id, user_id) => (
                    "guild_id_user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            "guild_id".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(guild_id),
                        ),
                        (
                            "user_id".to_string(),
                            ::prisma_client_rust::PrismaValue::BigInt(user_id),
                        ),
                    ]),
                ),
                Self::IdEquals(value) => (
                    "id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                Self::Id(value) => ("id", value.into()),
                Self::GuildIdEquals(value) => (
                    "guild_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::GuildId(value) => ("guild_id", value.into()),
                Self::UserIdEquals(value) => (
                    "user_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::UserId(value) => ("user_id", value.into()),
                Self::ActorIdEquals(value) => (
                    "actor_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                ),
                Self::ActorId(value) => ("actor_id", value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        GuildIdUserIdEquals(i64, i64),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::GuildIdUserIdEquals(guild_id, user_id) => {
                    Self::GuildIdUserIdEquals(guild_id, user_id)
                }
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "xpblock";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["id", "guild_id", "user_id", "actor_id"]
                .into_iter()
                .map(|o| {
                    let builder = ::prisma_client_rust::Selection::builder(o);
                    builder.build()
                })
                .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            guild_id: i64,
            user_id: i64,
            actor_id: i64,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.push(guild_id::set(guild_id));
            _params.push(user_id::set(user_id));
            _params.push(actor_id::set(actor_id));
            Create::new(self.client, _params)
        }
        pub fn create_many(self, data: Vec<(i64, i64, i64, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(guild_id, user_id, actor_id, mut _params)| {
                    _params.push(guild_id::set(guild_id));
                    _params.push(user_id::set(user_id));
                    _params.push(actor_id::set(actor_id));
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (guild_id, user_id, actor_id, mut _params): (i64, i64, i64, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.push(guild_id::set(guild_id));
            _params.push(user_id::set(user_id));
            _params.push(actor_id::set(actor_id));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod _prisma {
    pub struct PrismaClientBuilder {
        url: Option<String>,
        action_notifier: ::prisma_client_rust::ActionNotifier,
    }
    impl PrismaClientBuilder {
        pub fn new() -> Self {
            Self {
                url: None,
                action_notifier: ::prisma_client_rust::ActionNotifier::new(),
            }
        }
        pub fn with_url(mut self, url: String) -> Self {
            self.url = Some(url);
            self
        }
        pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
            let config =
                ::prisma_client_rust::datamodel::parse_configuration(super::DATAMODEL_STR)?.subject;
            let source = config
                .datasources
                .first()
                .expect("Please supply a datasource in your schema.prisma file");
            let url = match self.url {
                Some(url) => url,
                None => {
                    let url = if let Some(url) = source.load_shadow_database_url()? {
                        url
                    } else {
                        source.load_url(|key| std::env::var(key).ok())?
                    };
                    match url.starts_with("file:") {
                        true => {
                            let path = url.split(":").nth(1).unwrap();
                            if std::path::Path::new("./prisma/schema.prisma").exists() {
                                format!("file:./prisma/{}", path)
                            } else {
                                url
                            }
                        }
                        _ => url,
                    }
                }
            };
            let (db_name, executor) =
                ::prisma_client_rust::query_core::executor::load(&source, &[], &url).await?;
            let internal_model =
                ::prisma_client_rust::prisma_models::InternalDataModelBuilder::new(
                    super::DATAMODEL_STR,
                )
                .build(db_name);
            let query_schema =
                std::sync::Arc::new(prisma_client_rust::query_core::schema_builder::build(
                    internal_model,
                    true,
                    source.capabilities(),
                    vec![],
                    source.referential_integrity(),
                ));
            executor.primary_connector().get_connection().await?;
            Ok(PrismaClient(::prisma_client_rust::PrismaClientInternals {
                executor,
                query_schema,
                url,
                action_notifier: self.action_notifier,
            }))
        }
    }
    pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
    impl ::std::fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub fn _builder() -> PrismaClientBuilder {
            PrismaClientBuilder::new()
        }
        pub fn _query_raw<T: serde::de::DeserializeOwned>(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::QueryRaw<T> {
            ::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub fn _execute_raw(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::ExecuteRaw {
            ::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub async fn _batch<T: ::prisma_client_rust::BatchContainer<Marker>, Marker>(
            &self,
            queries: T,
        ) -> ::prisma_client_rust::Result<T::ReturnType> {
            ::prisma_client_rust::batch(queries, &self.0).await
        }
        pub fn channels(&self) -> super::channels::Actions {
            super::channels::Actions { client: &self.0 }
        }
        pub fn commands(&self) -> super::commands::Actions {
            super::commands::Actions { client: &self.0 }
        }
        pub fn events(&self) -> super::events::Actions {
            super::events::Actions { client: &self.0 }
        }
        pub fn guild_bans(&self) -> super::guild_bans::Actions {
            super::guild_bans::Actions { client: &self.0 }
        }
        pub fn guild_config_changes(&self) -> super::guild_config_changes::Actions {
            super::guild_config_changes::Actions { client: &self.0 }
        }
        pub fn guild_emojis(&self) -> super::guild_emojis::Actions {
            super::guild_emojis::Actions { client: &self.0 }
        }
        pub fn guild_member_backups(&self) -> super::guild_member_backups::Actions {
            super::guild_member_backups::Actions { client: &self.0 }
        }
        pub fn guild_voice_sessions(&self) -> super::guild_voice_sessions::Actions {
            super::guild_voice_sessions::Actions { client: &self.0 }
        }
        pub fn guilds(&self) -> super::guilds::Actions {
            super::guilds::Actions { client: &self.0 }
        }
        pub fn infractions(&self) -> super::infractions::Actions {
            super::infractions::Actions { client: &self.0 }
        }
        pub fn message_archives(&self) -> super::message_archives::Actions {
            super::message_archives::Actions { client: &self.0 }
        }
        pub fn messages(&self) -> super::messages::Actions {
            super::messages::Actions { client: &self.0 }
        }
        pub fn notifications(&self) -> super::notifications::Actions {
            super::notifications::Actions { client: &self.0 }
        }
        pub fn reactions(&self) -> super::reactions::Actions {
            super::reactions::Actions { client: &self.0 }
        }
        pub fn reminders(&self) -> super::reminders::Actions {
            super::reminders::Actions { client: &self.0 }
        }
        pub fn starboard_entries(&self) -> super::starboard_entries::Actions {
            super::starboard_entries::Actions { client: &self.0 }
        }
        pub fn starboardblock(&self) -> super::starboardblock::Actions {
            super::starboardblock::Actions { client: &self.0 }
        }
        pub fn tags(&self) -> super::tags::Actions {
            super::tags::Actions { client: &self.0 }
        }
        pub fn users(&self) -> super::users::Actions {
            super::users::Actions { client: &self.0 }
        }
        pub fn xp(&self) -> super::xp::Actions {
            super::xp::Actions { client: &self.0 }
        }
        pub fn xpblock(&self) -> super::xpblock::Actions {
            super::xpblock::Actions { client: &self.0 }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ChannelsScalarFieldEnum {
        #[serde(rename = "channel_id")]
        ChannelId,
        #[serde(rename = "guild_id")]
        GuildId,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "topic")]
        Topic,
        #[serde(rename = "type_")]
        Type_,
        #[serde(rename = "first_message_id")]
        FirstMessageId,
        #[serde(rename = "deleted")]
        Deleted,
    }
    impl ToString for ChannelsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::ChannelId => "channel_id".to_string(),
                Self::GuildId => "guild_id".to_string(),
                Self::Name => "name".to_string(),
                Self::Topic => "topic".to_string(),
                Self::Type_ => "type_".to_string(),
                Self::FirstMessageId => "first_message_id".to_string(),
                Self::Deleted => "deleted".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum CommandsScalarFieldEnum {
        #[serde(rename = "message_id")]
        MessageId,
        #[serde(rename = "plugin")]
        Plugin,
        #[serde(rename = "command")]
        Command,
        #[serde(rename = "version")]
        Version,
        #[serde(rename = "success")]
        Success,
        #[serde(rename = "traceback")]
        Traceback,
    }
    impl ToString for CommandsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::MessageId => "message_id".to_string(),
                Self::Plugin => "plugin".to_string(),
                Self::Command => "command".to_string(),
                Self::Version => "version".to_string(),
                Self::Success => "success".to_string(),
                Self::Traceback => "traceback".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum EventsScalarFieldEnum {
        #[serde(rename = "session")]
        Session,
        #[serde(rename = "seq")]
        Seq,
        #[serde(rename = "timestamp")]
        Timestamp,
        #[serde(rename = "event")]
        Event,
        #[serde(rename = "data")]
        Data,
    }
    impl ToString for EventsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Session => "session".to_string(),
                Self::Seq => "seq".to_string(),
                Self::Timestamp => "timestamp".to_string(),
                Self::Event => "event".to_string(),
                Self::Data => "data".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum GuildBansScalarFieldEnum {
        #[serde(rename = "user_id")]
        UserId,
        #[serde(rename = "guild_id")]
        GuildId,
        #[serde(rename = "reason")]
        Reason,
    }
    impl ToString for GuildBansScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::UserId => "user_id".to_string(),
                Self::GuildId => "guild_id".to_string(),
                Self::Reason => "reason".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum GuildConfigChangesScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "user_id")]
        UserId,
        #[serde(rename = "guild_id")]
        GuildId,
        #[serde(rename = "before_raw")]
        BeforeRaw,
        #[serde(rename = "after_raw")]
        AfterRaw,
        #[serde(rename = "created_at")]
        CreatedAt,
    }
    impl ToString for GuildConfigChangesScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::UserId => "user_id".to_string(),
                Self::GuildId => "guild_id".to_string(),
                Self::BeforeRaw => "before_raw".to_string(),
                Self::AfterRaw => "after_raw".to_string(),
                Self::CreatedAt => "created_at".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum GuildEmojisScalarFieldEnum {
        #[serde(rename = "emoji_id")]
        EmojiId,
        #[serde(rename = "guild_id")]
        GuildId,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "require_colons")]
        RequireColons,
        #[serde(rename = "managed")]
        Managed,
        #[serde(rename = "roles")]
        Roles,
        #[serde(rename = "deleted")]
        Deleted,
    }
    impl ToString for GuildEmojisScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::EmojiId => "emoji_id".to_string(),
                Self::GuildId => "guild_id".to_string(),
                Self::Name => "name".to_string(),
                Self::RequireColons => "require_colons".to_string(),
                Self::Managed => "managed".to_string(),
                Self::Roles => "roles".to_string(),
                Self::Deleted => "deleted".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum GuildMemberBackupsScalarFieldEnum {
        #[serde(rename = "user_id")]
        UserId,
        #[serde(rename = "guild_id")]
        GuildId,
        #[serde(rename = "nick")]
        Nick,
        #[serde(rename = "roles")]
        Roles,
        #[serde(rename = "mute")]
        Mute,
        #[serde(rename = "deaf")]
        Deaf,
    }
    impl ToString for GuildMemberBackupsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::UserId => "user_id".to_string(),
                Self::GuildId => "guild_id".to_string(),
                Self::Nick => "nick".to_string(),
                Self::Roles => "roles".to_string(),
                Self::Mute => "mute".to_string(),
                Self::Deaf => "deaf".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum GuildVoiceSessionsScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "session_id")]
        SessionId,
        #[serde(rename = "user_id")]
        UserId,
        #[serde(rename = "guild_id")]
        GuildId,
        #[serde(rename = "channel_id")]
        ChannelId,
        #[serde(rename = "started_at")]
        StartedAt,
        #[serde(rename = "ended_at")]
        EndedAt,
    }
    impl ToString for GuildVoiceSessionsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::SessionId => "session_id".to_string(),
                Self::UserId => "user_id".to_string(),
                Self::GuildId => "guild_id".to_string(),
                Self::ChannelId => "channel_id".to_string(),
                Self::StartedAt => "started_at".to_string(),
                Self::EndedAt => "ended_at".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum GuildsScalarFieldEnum {
        #[serde(rename = "guild_id")]
        GuildId,
        #[serde(rename = "owner_id")]
        OwnerId,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "icon")]
        Icon,
        #[serde(rename = "splash")]
        Splash,
        #[serde(rename = "region")]
        Region,
        #[serde(rename = "last_ban_sync")]
        LastBanSync,
        #[serde(rename = "config")]
        Config,
        #[serde(rename = "config_raw")]
        ConfigRaw,
        #[serde(rename = "enabled")]
        Enabled,
        #[serde(rename = "whitelist")]
        Whitelist,
        #[serde(rename = "added_at")]
        AddedAt,
    }
    impl ToString for GuildsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::GuildId => "guild_id".to_string(),
                Self::OwnerId => "owner_id".to_string(),
                Self::Name => "name".to_string(),
                Self::Icon => "icon".to_string(),
                Self::Splash => "splash".to_string(),
                Self::Region => "region".to_string(),
                Self::LastBanSync => "last_ban_sync".to_string(),
                Self::Config => "config".to_string(),
                Self::ConfigRaw => "config_raw".to_string(),
                Self::Enabled => "enabled".to_string(),
                Self::Whitelist => "whitelist".to_string(),
                Self::AddedAt => "added_at".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InfractionsScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "guild_id")]
        GuildId,
        #[serde(rename = "user_id")]
        UserId,
        #[serde(rename = "actor_id")]
        ActorId,
        #[serde(rename = "kind")]
        Kind,
        #[serde(rename = "reason")]
        Reason,
        #[serde(rename = "metadata")]
        Metadata,
        #[serde(rename = "expires_at")]
        ExpiresAt,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "active")]
        Active,
        #[serde(rename = "messaged")]
        Messaged,
    }
    impl ToString for InfractionsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::GuildId => "guild_id".to_string(),
                Self::UserId => "user_id".to_string(),
                Self::ActorId => "actor_id".to_string(),
                Self::Kind => "kind".to_string(),
                Self::Reason => "reason".to_string(),
                Self::Metadata => "metadata".to_string(),
                Self::ExpiresAt => "expires_at".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::Active => "active".to_string(),
                Self::Messaged => "messaged".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum JsonNullValueFilter {
        #[serde(rename = "DbNull")]
        DbNull,
        #[serde(rename = "JsonNull")]
        JsonNull,
        #[serde(rename = "AnyNull")]
        AnyNull,
    }
    impl ToString for JsonNullValueFilter {
        fn to_string(&self) -> String {
            match self {
                Self::DbNull => "DbNull".to_string(),
                Self::JsonNull => "JsonNull".to_string(),
                Self::AnyNull => "AnyNull".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum JsonNullValueInput {
        #[serde(rename = "JsonNull")]
        JsonNull,
    }
    impl ToString for JsonNullValueInput {
        fn to_string(&self) -> String {
            match self {
                Self::JsonNull => "JsonNull".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum MessageArchivesScalarFieldEnum {
        #[serde(rename = "archive_id")]
        ArchiveId,
        #[serde(rename = "message_ids")]
        MessageIds,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "expires_at")]
        ExpiresAt,
    }
    impl ToString for MessageArchivesScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::ArchiveId => "archive_id".to_string(),
                Self::MessageIds => "message_ids".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::ExpiresAt => "expires_at".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum MessagesScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "channel_id")]
        ChannelId,
        #[serde(rename = "guild_id")]
        GuildId,
        #[serde(rename = "author_id")]
        AuthorId,
        #[serde(rename = "content")]
        Content,
        #[serde(rename = "timestamp")]
        Timestamp,
        #[serde(rename = "edited_timestamp")]
        EditedTimestamp,
        #[serde(rename = "deleted")]
        Deleted,
        #[serde(rename = "num_edits")]
        NumEdits,
        #[serde(rename = "command")]
        Command,
        #[serde(rename = "mentions")]
        Mentions,
        #[serde(rename = "emojis")]
        Emojis,
        #[serde(rename = "attachments")]
        Attachments,
        #[serde(rename = "embeds")]
        Embeds,
    }
    impl ToString for MessagesScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::ChannelId => "channel_id".to_string(),
                Self::GuildId => "guild_id".to_string(),
                Self::AuthorId => "author_id".to_string(),
                Self::Content => "content".to_string(),
                Self::Timestamp => "timestamp".to_string(),
                Self::EditedTimestamp => "edited_timestamp".to_string(),
                Self::Deleted => "deleted".to_string(),
                Self::NumEdits => "num_edits".to_string(),
                Self::Command => "command".to_string(),
                Self::Mentions => "mentions".to_string(),
                Self::Emojis => "emojis".to_string(),
                Self::Attachments => "attachments".to_string(),
                Self::Embeds => "embeds".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum NotificationsScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "kind")]
        Kind,
        #[serde(rename = "metadata")]
        Metadata,
        #[serde(rename = "read")]
        Read,
        #[serde(rename = "created_at")]
        CreatedAt,
    }
    impl ToString for NotificationsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Kind => "kind".to_string(),
                Self::Metadata => "metadata".to_string(),
                Self::Read => "read".to_string(),
                Self::CreatedAt => "created_at".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum NullableJsonNullValueInput {
        #[serde(rename = "DbNull")]
        DbNull,
        #[serde(rename = "JsonNull")]
        JsonNull,
    }
    impl ToString for NullableJsonNullValueInput {
        fn to_string(&self) -> String {
            match self {
                Self::DbNull => "DbNull".to_string(),
                Self::JsonNull => "JsonNull".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum QueryMode {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "insensitive")]
        Insensitive,
    }
    impl ToString for QueryMode {
        fn to_string(&self) -> String {
            match self {
                Self::Default => "default".to_string(),
                Self::Insensitive => "insensitive".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ReactionsScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "message_id")]
        MessageId,
        #[serde(rename = "user_id")]
        UserId,
        #[serde(rename = "emoji_id")]
        EmojiId,
        #[serde(rename = "emoji_name")]
        EmojiName,
    }
    impl ToString for ReactionsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::MessageId => "message_id".to_string(),
                Self::UserId => "user_id".to_string(),
                Self::EmojiId => "emoji_id".to_string(),
                Self::EmojiName => "emoji_name".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum RemindersScalarFieldEnum {
        #[serde(rename = "message_id")]
        MessageId,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "remind_at")]
        RemindAt,
        #[serde(rename = "content")]
        Content,
    }
    impl ToString for RemindersScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::MessageId => "message_id".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::RemindAt => "remind_at".to_string(),
                Self::Content => "content".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum StarboardEntriesScalarFieldEnum {
        #[serde(rename = "message_id")]
        MessageId,
        #[serde(rename = "star_channel_id")]
        StarChannelId,
        #[serde(rename = "star_message_id")]
        StarMessageId,
        #[serde(rename = "stars")]
        Stars,
        #[serde(rename = "blocked_stars")]
        BlockedStars,
        #[serde(rename = "blocked")]
        Blocked,
        #[serde(rename = "dirty")]
        Dirty,
    }
    impl ToString for StarboardEntriesScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::MessageId => "message_id".to_string(),
                Self::StarChannelId => "star_channel_id".to_string(),
                Self::StarMessageId => "star_message_id".to_string(),
                Self::Stars => "stars".to_string(),
                Self::BlockedStars => "blocked_stars".to_string(),
                Self::Blocked => "blocked".to_string(),
                Self::Dirty => "dirty".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum StarboardblockScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "guild_id")]
        GuildId,
        #[serde(rename = "entity_id")]
        EntityId,
        #[serde(rename = "actor_id")]
        ActorId,
    }
    impl ToString for StarboardblockScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::GuildId => "guild_id".to_string(),
                Self::EntityId => "entity_id".to_string(),
                Self::ActorId => "actor_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum TagsScalarFieldEnum {
        #[serde(rename = "guild_id")]
        GuildId,
        #[serde(rename = "author_id")]
        AuthorId,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "content")]
        Content,
        #[serde(rename = "times_used")]
        TimesUsed,
        #[serde(rename = "created_at")]
        CreatedAt,
    }
    impl ToString for TagsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::GuildId => "guild_id".to_string(),
                Self::AuthorId => "author_id".to_string(),
                Self::Name => "name".to_string(),
                Self::Content => "content".to_string(),
                Self::TimesUsed => "times_used".to_string(),
                Self::CreatedAt => "created_at".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum TransactionIsolationLevel {
        #[serde(rename = "ReadUncommitted")]
        ReadUncommitted,
        #[serde(rename = "ReadCommitted")]
        ReadCommitted,
        #[serde(rename = "RepeatableRead")]
        RepeatableRead,
        #[serde(rename = "Serializable")]
        Serializable,
    }
    impl ToString for TransactionIsolationLevel {
        fn to_string(&self) -> String {
            match self {
                Self::ReadUncommitted => "ReadUncommitted".to_string(),
                Self::ReadCommitted => "ReadCommitted".to_string(),
                Self::RepeatableRead => "RepeatableRead".to_string(),
                Self::Serializable => "Serializable".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum UsersScalarFieldEnum {
        #[serde(rename = "user_id")]
        UserId,
        #[serde(rename = "username")]
        Username,
        #[serde(rename = "discriminator")]
        Discriminator,
        #[serde(rename = "avatar")]
        Avatar,
        #[serde(rename = "bot")]
        Bot,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "admin")]
        Admin,
    }
    impl ToString for UsersScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::UserId => "user_id".to_string(),
                Self::Username => "username".to_string(),
                Self::Discriminator => "discriminator".to_string(),
                Self::Avatar => "avatar".to_string(),
                Self::Bot => "bot".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::Admin => "admin".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum XpScalarFieldEnum {
        #[serde(rename = "user_id")]
        UserId,
        #[serde(rename = "guild_id")]
        GuildId,
        #[serde(rename = "xp")]
        Xp,
    }
    impl ToString for XpScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::UserId => "user_id".to_string(),
                Self::GuildId => "guild_id".to_string(),
                Self::Xp => "xp".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum XpblockScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "guild_id")]
        GuildId,
        #[serde(rename = "user_id")]
        UserId,
        #[serde(rename = "actor_id")]
        ActorId,
    }
    impl ToString for XpblockScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::GuildId => "guild_id".to_string(),
                Self::UserId => "user_id".to_string(),
                Self::ActorId => "actor_id".to_string(),
            }
        }
    }
    pub mod read_filters {
        use super::*;
        #[derive(Clone)]
        pub enum BigIntListFilter {
            Has(i64),
            HasEvery(Vec<i64>),
            HasSome(Vec<i64>),
            IsEmpty(bool),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for BigIntListFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Has(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "has".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::HasEvery(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "hasEvery".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::HasSome(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "hasSome".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::IsEmpty(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "isEmpty".to_string(),
                            ::prisma_client_rust::PrismaValue::Boolean(value),
                        )])
                    }
                }
            }
        }
        #[derive(Clone)]
        pub enum BigIntFilter {
            InVec(Vec<i64>),
            NotInVec(Vec<i64>),
            Lt(i64),
            Lte(i64),
            Gt(i64),
            Gte(i64),
            Not(i64),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for BigIntFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::BigInt(v))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::BigInt(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum StringListFilter {
            Has(String),
            HasEvery(Vec<String>),
            HasSome(Vec<String>),
            IsEmpty(bool),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringListFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Has(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "has".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::HasEvery(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "hasEvery".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::HasSome(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "hasSome".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::IsEmpty(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "isEmpty".to_string(),
                            ::prisma_client_rust::PrismaValue::Boolean(value),
                        )])
                    }
                }
            }
        }
        #[derive(Clone)]
        pub enum StringFilter {
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Mode(QueryMode),
            Not(String),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Mode(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "mode".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum IntFilter {
            InVec(Vec<i32>),
            NotInVec(Vec<i32>),
            Lt(i32),
            Lte(i32),
            Gt(i32),
            Gte(i32),
            Not(i32),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for IntFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum DateTimeFilter {
            InVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            NotInVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            Lt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Lte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Not(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum BytesFilter {
            InVec(Vec<Vec<u8>>),
            NotInVec(Vec<Vec<u8>>),
            Not(Vec<u8>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for BytesFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::Bytes(v))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::Bytes(v))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Bytes(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum JsonFilter {
            Path(Vec<String>),
            StringContains(String),
            StringStartsWith(String),
            StringEndsWith(String),
            ArrayContains(::prisma_client_rust::serde_json::Value),
            ArrayStartsWith(::prisma_client_rust::serde_json::Value),
            ArrayEndsWith(::prisma_client_rust::serde_json::Value),
            Lt(::prisma_client_rust::serde_json::Value),
            Lte(::prisma_client_rust::serde_json::Value),
            Gt(::prisma_client_rust::serde_json::Value),
            Gte(::prisma_client_rust::serde_json::Value),
            Not(JsonNullValueFilter),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for JsonFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Path(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "path".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::StringContains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "string_contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StringStartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "string_starts_with".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StringEndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "string_ends_with".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::ArrayContains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "array_contains".to_string(),
                            ::prisma_client_rust::PrismaValue::Json(
                                serde_json::to_string(&value).unwrap(),
                            ),
                        )])
                    }
                    Self::ArrayStartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "array_starts_with".to_string(),
                            ::prisma_client_rust::PrismaValue::Json(
                                serde_json::to_string(&value).unwrap(),
                            ),
                        )])
                    }
                    Self::ArrayEndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "array_ends_with".to_string(),
                            ::prisma_client_rust::PrismaValue::Json(
                                serde_json::to_string(&value).unwrap(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Json(
                            serde_json::to_string(&value).unwrap(),
                        ),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Json(
                            serde_json::to_string(&value).unwrap(),
                        ),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Json(
                            serde_json::to_string(&value).unwrap(),
                        ),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Json(
                            serde_json::to_string(&value).unwrap(),
                        ),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                }
            }
        }
    }
}
pub use _prisma::PrismaClient;
